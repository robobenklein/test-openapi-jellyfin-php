<?php
/**
 * NetworkConfiguration
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Jellyfin API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 10.8.10
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.0.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * NetworkConfiguration Class Doc Comment
 *
 * @category Class
 * @description Defines the Jellyfin.Networking.Configuration.NetworkConfiguration.
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class NetworkConfiguration implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'NetworkConfiguration';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'require_https' => 'bool',
        'certificate_path' => 'string',
        'certificate_password' => 'string',
        'base_url' => 'string',
        'public_https_port' => 'int',
        'http_server_port_number' => 'int',
        'https_port_number' => 'int',
        'enable_https' => 'bool',
        'public_port' => 'int',
        'upn_p_create_http_port_map' => 'bool',
        'udp_port_range' => 'string',
        'enable_ipv6' => 'bool',
        'enable_ipv4' => 'bool',
        'enable_ssdp_tracing' => 'bool',
        'ssdp_tracing_filter' => 'string',
        'udp_send_count' => 'int',
        'udp_send_delay' => 'int',
        'ignore_virtual_interfaces' => 'bool',
        'virtual_interface_names' => 'string',
        'gateway_monitor_period' => 'int',
        'enable_multi_socket_binding' => 'bool',
        'trust_all_ip6_interfaces' => 'bool',
        'hd_homerun_port_range' => 'string',
        'published_server_uri_by_subnet' => 'string[]',
        'auto_discovery_tracing' => 'bool',
        'auto_discovery' => 'bool',
        'remote_ip_filter' => 'string[]',
        'is_remote_ip_filter_blacklist' => 'bool',
        'enable_upn_p' => 'bool',
        'enable_remote_access' => 'bool',
        'local_network_subnets' => 'string[]',
        'local_network_addresses' => 'string[]',
        'known_proxies' => 'string[]',
        'enable_published_server_uri_by_request' => 'bool'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'require_https' => null,
        'certificate_path' => null,
        'certificate_password' => null,
        'base_url' => null,
        'public_https_port' => 'int32',
        'http_server_port_number' => 'int32',
        'https_port_number' => 'int32',
        'enable_https' => null,
        'public_port' => 'int32',
        'upn_p_create_http_port_map' => null,
        'udp_port_range' => null,
        'enable_ipv6' => null,
        'enable_ipv4' => null,
        'enable_ssdp_tracing' => null,
        'ssdp_tracing_filter' => null,
        'udp_send_count' => 'int32',
        'udp_send_delay' => 'int32',
        'ignore_virtual_interfaces' => null,
        'virtual_interface_names' => null,
        'gateway_monitor_period' => 'int32',
        'enable_multi_socket_binding' => null,
        'trust_all_ip6_interfaces' => null,
        'hd_homerun_port_range' => null,
        'published_server_uri_by_subnet' => null,
        'auto_discovery_tracing' => null,
        'auto_discovery' => null,
        'remote_ip_filter' => null,
        'is_remote_ip_filter_blacklist' => null,
        'enable_upn_p' => null,
        'enable_remote_access' => null,
        'local_network_subnets' => null,
        'local_network_addresses' => null,
        'known_proxies' => null,
        'enable_published_server_uri_by_request' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'require_https' => false,
		'certificate_path' => false,
		'certificate_password' => false,
		'base_url' => false,
		'public_https_port' => false,
		'http_server_port_number' => false,
		'https_port_number' => false,
		'enable_https' => false,
		'public_port' => false,
		'upn_p_create_http_port_map' => false,
		'udp_port_range' => false,
		'enable_ipv6' => false,
		'enable_ipv4' => false,
		'enable_ssdp_tracing' => false,
		'ssdp_tracing_filter' => false,
		'udp_send_count' => false,
		'udp_send_delay' => false,
		'ignore_virtual_interfaces' => false,
		'virtual_interface_names' => false,
		'gateway_monitor_period' => false,
		'enable_multi_socket_binding' => false,
		'trust_all_ip6_interfaces' => false,
		'hd_homerun_port_range' => false,
		'published_server_uri_by_subnet' => false,
		'auto_discovery_tracing' => false,
		'auto_discovery' => false,
		'remote_ip_filter' => false,
		'is_remote_ip_filter_blacklist' => false,
		'enable_upn_p' => false,
		'enable_remote_access' => false,
		'local_network_subnets' => false,
		'local_network_addresses' => false,
		'known_proxies' => false,
		'enable_published_server_uri_by_request' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'require_https' => 'RequireHttps',
        'certificate_path' => 'CertificatePath',
        'certificate_password' => 'CertificatePassword',
        'base_url' => 'BaseUrl',
        'public_https_port' => 'PublicHttpsPort',
        'http_server_port_number' => 'HttpServerPortNumber',
        'https_port_number' => 'HttpsPortNumber',
        'enable_https' => 'EnableHttps',
        'public_port' => 'PublicPort',
        'upn_p_create_http_port_map' => 'UPnPCreateHttpPortMap',
        'udp_port_range' => 'UDPPortRange',
        'enable_ipv6' => 'EnableIPV6',
        'enable_ipv4' => 'EnableIPV4',
        'enable_ssdp_tracing' => 'EnableSSDPTracing',
        'ssdp_tracing_filter' => 'SSDPTracingFilter',
        'udp_send_count' => 'UDPSendCount',
        'udp_send_delay' => 'UDPSendDelay',
        'ignore_virtual_interfaces' => 'IgnoreVirtualInterfaces',
        'virtual_interface_names' => 'VirtualInterfaceNames',
        'gateway_monitor_period' => 'GatewayMonitorPeriod',
        'enable_multi_socket_binding' => 'EnableMultiSocketBinding',
        'trust_all_ip6_interfaces' => 'TrustAllIP6Interfaces',
        'hd_homerun_port_range' => 'HDHomerunPortRange',
        'published_server_uri_by_subnet' => 'PublishedServerUriBySubnet',
        'auto_discovery_tracing' => 'AutoDiscoveryTracing',
        'auto_discovery' => 'AutoDiscovery',
        'remote_ip_filter' => 'RemoteIPFilter',
        'is_remote_ip_filter_blacklist' => 'IsRemoteIPFilterBlacklist',
        'enable_upn_p' => 'EnableUPnP',
        'enable_remote_access' => 'EnableRemoteAccess',
        'local_network_subnets' => 'LocalNetworkSubnets',
        'local_network_addresses' => 'LocalNetworkAddresses',
        'known_proxies' => 'KnownProxies',
        'enable_published_server_uri_by_request' => 'EnablePublishedServerUriByRequest'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'require_https' => 'setRequireHttps',
        'certificate_path' => 'setCertificatePath',
        'certificate_password' => 'setCertificatePassword',
        'base_url' => 'setBaseUrl',
        'public_https_port' => 'setPublicHttpsPort',
        'http_server_port_number' => 'setHttpServerPortNumber',
        'https_port_number' => 'setHttpsPortNumber',
        'enable_https' => 'setEnableHttps',
        'public_port' => 'setPublicPort',
        'upn_p_create_http_port_map' => 'setUpnPCreateHttpPortMap',
        'udp_port_range' => 'setUdpPortRange',
        'enable_ipv6' => 'setEnableIpv6',
        'enable_ipv4' => 'setEnableIpv4',
        'enable_ssdp_tracing' => 'setEnableSsdpTracing',
        'ssdp_tracing_filter' => 'setSsdpTracingFilter',
        'udp_send_count' => 'setUdpSendCount',
        'udp_send_delay' => 'setUdpSendDelay',
        'ignore_virtual_interfaces' => 'setIgnoreVirtualInterfaces',
        'virtual_interface_names' => 'setVirtualInterfaceNames',
        'gateway_monitor_period' => 'setGatewayMonitorPeriod',
        'enable_multi_socket_binding' => 'setEnableMultiSocketBinding',
        'trust_all_ip6_interfaces' => 'setTrustAllIp6Interfaces',
        'hd_homerun_port_range' => 'setHdHomerunPortRange',
        'published_server_uri_by_subnet' => 'setPublishedServerUriBySubnet',
        'auto_discovery_tracing' => 'setAutoDiscoveryTracing',
        'auto_discovery' => 'setAutoDiscovery',
        'remote_ip_filter' => 'setRemoteIpFilter',
        'is_remote_ip_filter_blacklist' => 'setIsRemoteIpFilterBlacklist',
        'enable_upn_p' => 'setEnableUpnP',
        'enable_remote_access' => 'setEnableRemoteAccess',
        'local_network_subnets' => 'setLocalNetworkSubnets',
        'local_network_addresses' => 'setLocalNetworkAddresses',
        'known_proxies' => 'setKnownProxies',
        'enable_published_server_uri_by_request' => 'setEnablePublishedServerUriByRequest'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'require_https' => 'getRequireHttps',
        'certificate_path' => 'getCertificatePath',
        'certificate_password' => 'getCertificatePassword',
        'base_url' => 'getBaseUrl',
        'public_https_port' => 'getPublicHttpsPort',
        'http_server_port_number' => 'getHttpServerPortNumber',
        'https_port_number' => 'getHttpsPortNumber',
        'enable_https' => 'getEnableHttps',
        'public_port' => 'getPublicPort',
        'upn_p_create_http_port_map' => 'getUpnPCreateHttpPortMap',
        'udp_port_range' => 'getUdpPortRange',
        'enable_ipv6' => 'getEnableIpv6',
        'enable_ipv4' => 'getEnableIpv4',
        'enable_ssdp_tracing' => 'getEnableSsdpTracing',
        'ssdp_tracing_filter' => 'getSsdpTracingFilter',
        'udp_send_count' => 'getUdpSendCount',
        'udp_send_delay' => 'getUdpSendDelay',
        'ignore_virtual_interfaces' => 'getIgnoreVirtualInterfaces',
        'virtual_interface_names' => 'getVirtualInterfaceNames',
        'gateway_monitor_period' => 'getGatewayMonitorPeriod',
        'enable_multi_socket_binding' => 'getEnableMultiSocketBinding',
        'trust_all_ip6_interfaces' => 'getTrustAllIp6Interfaces',
        'hd_homerun_port_range' => 'getHdHomerunPortRange',
        'published_server_uri_by_subnet' => 'getPublishedServerUriBySubnet',
        'auto_discovery_tracing' => 'getAutoDiscoveryTracing',
        'auto_discovery' => 'getAutoDiscovery',
        'remote_ip_filter' => 'getRemoteIpFilter',
        'is_remote_ip_filter_blacklist' => 'getIsRemoteIpFilterBlacklist',
        'enable_upn_p' => 'getEnableUpnP',
        'enable_remote_access' => 'getEnableRemoteAccess',
        'local_network_subnets' => 'getLocalNetworkSubnets',
        'local_network_addresses' => 'getLocalNetworkAddresses',
        'known_proxies' => 'getKnownProxies',
        'enable_published_server_uri_by_request' => 'getEnablePublishedServerUriByRequest'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('require_https', $data ?? [], null);
        $this->setIfExists('certificate_path', $data ?? [], null);
        $this->setIfExists('certificate_password', $data ?? [], null);
        $this->setIfExists('base_url', $data ?? [], null);
        $this->setIfExists('public_https_port', $data ?? [], null);
        $this->setIfExists('http_server_port_number', $data ?? [], null);
        $this->setIfExists('https_port_number', $data ?? [], null);
        $this->setIfExists('enable_https', $data ?? [], null);
        $this->setIfExists('public_port', $data ?? [], null);
        $this->setIfExists('upn_p_create_http_port_map', $data ?? [], null);
        $this->setIfExists('udp_port_range', $data ?? [], null);
        $this->setIfExists('enable_ipv6', $data ?? [], null);
        $this->setIfExists('enable_ipv4', $data ?? [], null);
        $this->setIfExists('enable_ssdp_tracing', $data ?? [], null);
        $this->setIfExists('ssdp_tracing_filter', $data ?? [], null);
        $this->setIfExists('udp_send_count', $data ?? [], null);
        $this->setIfExists('udp_send_delay', $data ?? [], null);
        $this->setIfExists('ignore_virtual_interfaces', $data ?? [], null);
        $this->setIfExists('virtual_interface_names', $data ?? [], null);
        $this->setIfExists('gateway_monitor_period', $data ?? [], null);
        $this->setIfExists('enable_multi_socket_binding', $data ?? [], null);
        $this->setIfExists('trust_all_ip6_interfaces', $data ?? [], null);
        $this->setIfExists('hd_homerun_port_range', $data ?? [], null);
        $this->setIfExists('published_server_uri_by_subnet', $data ?? [], null);
        $this->setIfExists('auto_discovery_tracing', $data ?? [], null);
        $this->setIfExists('auto_discovery', $data ?? [], null);
        $this->setIfExists('remote_ip_filter', $data ?? [], null);
        $this->setIfExists('is_remote_ip_filter_blacklist', $data ?? [], null);
        $this->setIfExists('enable_upn_p', $data ?? [], null);
        $this->setIfExists('enable_remote_access', $data ?? [], null);
        $this->setIfExists('local_network_subnets', $data ?? [], null);
        $this->setIfExists('local_network_addresses', $data ?? [], null);
        $this->setIfExists('known_proxies', $data ?? [], null);
        $this->setIfExists('enable_published_server_uri_by_request', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets require_https
     *
     * @return bool|null
     */
    public function getRequireHttps()
    {
        return $this->container['require_https'];
    }

    /**
     * Sets require_https
     *
     * @param bool|null $require_https Gets or sets a value indicating whether the server should force connections over HTTPS.
     *
     * @return self
     */
    public function setRequireHttps($require_https)
    {
        if (is_null($require_https)) {
            throw new \InvalidArgumentException('non-nullable require_https cannot be null');
        }
        $this->container['require_https'] = $require_https;

        return $this;
    }

    /**
     * Gets certificate_path
     *
     * @return string|null
     */
    public function getCertificatePath()
    {
        return $this->container['certificate_path'];
    }

    /**
     * Sets certificate_path
     *
     * @param string|null $certificate_path Gets or sets the filesystem path of an X.509 certificate to use for SSL.
     *
     * @return self
     */
    public function setCertificatePath($certificate_path)
    {
        if (is_null($certificate_path)) {
            throw new \InvalidArgumentException('non-nullable certificate_path cannot be null');
        }
        $this->container['certificate_path'] = $certificate_path;

        return $this;
    }

    /**
     * Gets certificate_password
     *
     * @return string|null
     */
    public function getCertificatePassword()
    {
        return $this->container['certificate_password'];
    }

    /**
     * Sets certificate_password
     *
     * @param string|null $certificate_password Gets or sets the password required to access the X.509 certificate data in the file specified by Jellyfin.Networking.Configuration.NetworkConfiguration.CertificatePath.
     *
     * @return self
     */
    public function setCertificatePassword($certificate_password)
    {
        if (is_null($certificate_password)) {
            throw new \InvalidArgumentException('non-nullable certificate_password cannot be null');
        }
        $this->container['certificate_password'] = $certificate_password;

        return $this;
    }

    /**
     * Gets base_url
     *
     * @return string|null
     */
    public function getBaseUrl()
    {
        return $this->container['base_url'];
    }

    /**
     * Sets base_url
     *
     * @param string|null $base_url Gets or sets a value used to specify the URL prefix that your Jellyfin instance can be accessed at.
     *
     * @return self
     */
    public function setBaseUrl($base_url)
    {
        if (is_null($base_url)) {
            throw new \InvalidArgumentException('non-nullable base_url cannot be null');
        }
        $this->container['base_url'] = $base_url;

        return $this;
    }

    /**
     * Gets public_https_port
     *
     * @return int|null
     */
    public function getPublicHttpsPort()
    {
        return $this->container['public_https_port'];
    }

    /**
     * Sets public_https_port
     *
     * @param int|null $public_https_port Gets or sets the public HTTPS port.
     *
     * @return self
     */
    public function setPublicHttpsPort($public_https_port)
    {
        if (is_null($public_https_port)) {
            throw new \InvalidArgumentException('non-nullable public_https_port cannot be null');
        }
        $this->container['public_https_port'] = $public_https_port;

        return $this;
    }

    /**
     * Gets http_server_port_number
     *
     * @return int|null
     */
    public function getHttpServerPortNumber()
    {
        return $this->container['http_server_port_number'];
    }

    /**
     * Sets http_server_port_number
     *
     * @param int|null $http_server_port_number Gets or sets the HTTP server port number.
     *
     * @return self
     */
    public function setHttpServerPortNumber($http_server_port_number)
    {
        if (is_null($http_server_port_number)) {
            throw new \InvalidArgumentException('non-nullable http_server_port_number cannot be null');
        }
        $this->container['http_server_port_number'] = $http_server_port_number;

        return $this;
    }

    /**
     * Gets https_port_number
     *
     * @return int|null
     */
    public function getHttpsPortNumber()
    {
        return $this->container['https_port_number'];
    }

    /**
     * Sets https_port_number
     *
     * @param int|null $https_port_number Gets or sets the HTTPS server port number.
     *
     * @return self
     */
    public function setHttpsPortNumber($https_port_number)
    {
        if (is_null($https_port_number)) {
            throw new \InvalidArgumentException('non-nullable https_port_number cannot be null');
        }
        $this->container['https_port_number'] = $https_port_number;

        return $this;
    }

    /**
     * Gets enable_https
     *
     * @return bool|null
     */
    public function getEnableHttps()
    {
        return $this->container['enable_https'];
    }

    /**
     * Sets enable_https
     *
     * @param bool|null $enable_https Gets or sets a value indicating whether to use HTTPS.
     *
     * @return self
     */
    public function setEnableHttps($enable_https)
    {
        if (is_null($enable_https)) {
            throw new \InvalidArgumentException('non-nullable enable_https cannot be null');
        }
        $this->container['enable_https'] = $enable_https;

        return $this;
    }

    /**
     * Gets public_port
     *
     * @return int|null
     */
    public function getPublicPort()
    {
        return $this->container['public_port'];
    }

    /**
     * Sets public_port
     *
     * @param int|null $public_port Gets or sets the public mapped port.
     *
     * @return self
     */
    public function setPublicPort($public_port)
    {
        if (is_null($public_port)) {
            throw new \InvalidArgumentException('non-nullable public_port cannot be null');
        }
        $this->container['public_port'] = $public_port;

        return $this;
    }

    /**
     * Gets upn_p_create_http_port_map
     *
     * @return bool|null
     */
    public function getUpnPCreateHttpPortMap()
    {
        return $this->container['upn_p_create_http_port_map'];
    }

    /**
     * Sets upn_p_create_http_port_map
     *
     * @param bool|null $upn_p_create_http_port_map Gets or sets a value indicating whether the http port should be mapped as part of UPnP automatic port forwarding.
     *
     * @return self
     */
    public function setUpnPCreateHttpPortMap($upn_p_create_http_port_map)
    {
        if (is_null($upn_p_create_http_port_map)) {
            throw new \InvalidArgumentException('non-nullable upn_p_create_http_port_map cannot be null');
        }
        $this->container['upn_p_create_http_port_map'] = $upn_p_create_http_port_map;

        return $this;
    }

    /**
     * Gets udp_port_range
     *
     * @return string|null
     */
    public function getUdpPortRange()
    {
        return $this->container['udp_port_range'];
    }

    /**
     * Sets udp_port_range
     *
     * @param string|null $udp_port_range Gets or sets the UDPPortRange.
     *
     * @return self
     */
    public function setUdpPortRange($udp_port_range)
    {
        if (is_null($udp_port_range)) {
            throw new \InvalidArgumentException('non-nullable udp_port_range cannot be null');
        }
        $this->container['udp_port_range'] = $udp_port_range;

        return $this;
    }

    /**
     * Gets enable_ipv6
     *
     * @return bool|null
     */
    public function getEnableIpv6()
    {
        return $this->container['enable_ipv6'];
    }

    /**
     * Sets enable_ipv6
     *
     * @param bool|null $enable_ipv6 Gets or sets a value indicating whether gets or sets IPV6 capability.
     *
     * @return self
     */
    public function setEnableIpv6($enable_ipv6)
    {
        if (is_null($enable_ipv6)) {
            throw new \InvalidArgumentException('non-nullable enable_ipv6 cannot be null');
        }
        $this->container['enable_ipv6'] = $enable_ipv6;

        return $this;
    }

    /**
     * Gets enable_ipv4
     *
     * @return bool|null
     */
    public function getEnableIpv4()
    {
        return $this->container['enable_ipv4'];
    }

    /**
     * Sets enable_ipv4
     *
     * @param bool|null $enable_ipv4 Gets or sets a value indicating whether gets or sets IPV4 capability.
     *
     * @return self
     */
    public function setEnableIpv4($enable_ipv4)
    {
        if (is_null($enable_ipv4)) {
            throw new \InvalidArgumentException('non-nullable enable_ipv4 cannot be null');
        }
        $this->container['enable_ipv4'] = $enable_ipv4;

        return $this;
    }

    /**
     * Gets enable_ssdp_tracing
     *
     * @return bool|null
     */
    public function getEnableSsdpTracing()
    {
        return $this->container['enable_ssdp_tracing'];
    }

    /**
     * Sets enable_ssdp_tracing
     *
     * @param bool|null $enable_ssdp_tracing Gets or sets a value indicating whether detailed SSDP logs are sent to the console/log.  \"Emby.Dlna\": \"Debug\" must be set in logging.default.json for this property to have any effect.
     *
     * @return self
     */
    public function setEnableSsdpTracing($enable_ssdp_tracing)
    {
        if (is_null($enable_ssdp_tracing)) {
            throw new \InvalidArgumentException('non-nullable enable_ssdp_tracing cannot be null');
        }
        $this->container['enable_ssdp_tracing'] = $enable_ssdp_tracing;

        return $this;
    }

    /**
     * Gets ssdp_tracing_filter
     *
     * @return string|null
     */
    public function getSsdpTracingFilter()
    {
        return $this->container['ssdp_tracing_filter'];
    }

    /**
     * Sets ssdp_tracing_filter
     *
     * @param string|null $ssdp_tracing_filter Gets or sets the SSDPTracingFilter  Gets or sets a value indicating whether an IP address is to be used to filter the detailed ssdp logs that are being sent to the console/log.  If the setting \"Emby.Dlna\": \"Debug\" msut be set in logging.default.json for this property to work.
     *
     * @return self
     */
    public function setSsdpTracingFilter($ssdp_tracing_filter)
    {
        if (is_null($ssdp_tracing_filter)) {
            throw new \InvalidArgumentException('non-nullable ssdp_tracing_filter cannot be null');
        }
        $this->container['ssdp_tracing_filter'] = $ssdp_tracing_filter;

        return $this;
    }

    /**
     * Gets udp_send_count
     *
     * @return int|null
     */
    public function getUdpSendCount()
    {
        return $this->container['udp_send_count'];
    }

    /**
     * Sets udp_send_count
     *
     * @param int|null $udp_send_count Gets or sets the number of times SSDP UDP messages are sent.
     *
     * @return self
     */
    public function setUdpSendCount($udp_send_count)
    {
        if (is_null($udp_send_count)) {
            throw new \InvalidArgumentException('non-nullable udp_send_count cannot be null');
        }
        $this->container['udp_send_count'] = $udp_send_count;

        return $this;
    }

    /**
     * Gets udp_send_delay
     *
     * @return int|null
     */
    public function getUdpSendDelay()
    {
        return $this->container['udp_send_delay'];
    }

    /**
     * Sets udp_send_delay
     *
     * @param int|null $udp_send_delay Gets or sets the delay between each groups of SSDP messages (in ms).
     *
     * @return self
     */
    public function setUdpSendDelay($udp_send_delay)
    {
        if (is_null($udp_send_delay)) {
            throw new \InvalidArgumentException('non-nullable udp_send_delay cannot be null');
        }
        $this->container['udp_send_delay'] = $udp_send_delay;

        return $this;
    }

    /**
     * Gets ignore_virtual_interfaces
     *
     * @return bool|null
     */
    public function getIgnoreVirtualInterfaces()
    {
        return $this->container['ignore_virtual_interfaces'];
    }

    /**
     * Sets ignore_virtual_interfaces
     *
     * @param bool|null $ignore_virtual_interfaces Gets or sets a value indicating whether address names that match Jellyfin.Networking.Configuration.NetworkConfiguration.VirtualInterfaceNames should be Ignore for the purposes of binding.
     *
     * @return self
     */
    public function setIgnoreVirtualInterfaces($ignore_virtual_interfaces)
    {
        if (is_null($ignore_virtual_interfaces)) {
            throw new \InvalidArgumentException('non-nullable ignore_virtual_interfaces cannot be null');
        }
        $this->container['ignore_virtual_interfaces'] = $ignore_virtual_interfaces;

        return $this;
    }

    /**
     * Gets virtual_interface_names
     *
     * @return string|null
     */
    public function getVirtualInterfaceNames()
    {
        return $this->container['virtual_interface_names'];
    }

    /**
     * Sets virtual_interface_names
     *
     * @param string|null $virtual_interface_names Gets or sets a value indicating the interfaces that should be ignored. The list can be comma separated. <seealso cref=\"P:Jellyfin.Networking.Configuration.NetworkConfiguration.IgnoreVirtualInterfaces\" />.
     *
     * @return self
     */
    public function setVirtualInterfaceNames($virtual_interface_names)
    {
        if (is_null($virtual_interface_names)) {
            throw new \InvalidArgumentException('non-nullable virtual_interface_names cannot be null');
        }
        $this->container['virtual_interface_names'] = $virtual_interface_names;

        return $this;
    }

    /**
     * Gets gateway_monitor_period
     *
     * @return int|null
     */
    public function getGatewayMonitorPeriod()
    {
        return $this->container['gateway_monitor_period'];
    }

    /**
     * Sets gateway_monitor_period
     *
     * @param int|null $gateway_monitor_period Gets or sets the time (in seconds) between the pings of SSDP gateway monitor.
     *
     * @return self
     */
    public function setGatewayMonitorPeriod($gateway_monitor_period)
    {
        if (is_null($gateway_monitor_period)) {
            throw new \InvalidArgumentException('non-nullable gateway_monitor_period cannot be null');
        }
        $this->container['gateway_monitor_period'] = $gateway_monitor_period;

        return $this;
    }

    /**
     * Gets enable_multi_socket_binding
     *
     * @return bool|null
     */
    public function getEnableMultiSocketBinding()
    {
        return $this->container['enable_multi_socket_binding'];
    }

    /**
     * Sets enable_multi_socket_binding
     *
     * @param bool|null $enable_multi_socket_binding Gets a value indicating whether multi-socket binding is available.
     *
     * @return self
     */
    public function setEnableMultiSocketBinding($enable_multi_socket_binding)
    {
        if (is_null($enable_multi_socket_binding)) {
            throw new \InvalidArgumentException('non-nullable enable_multi_socket_binding cannot be null');
        }
        $this->container['enable_multi_socket_binding'] = $enable_multi_socket_binding;

        return $this;
    }

    /**
     * Gets trust_all_ip6_interfaces
     *
     * @return bool|null
     */
    public function getTrustAllIp6Interfaces()
    {
        return $this->container['trust_all_ip6_interfaces'];
    }

    /**
     * Sets trust_all_ip6_interfaces
     *
     * @param bool|null $trust_all_ip6_interfaces Gets or sets a value indicating whether all IPv6 interfaces should be treated as on the internal network.  Depending on the address range implemented ULA ranges might not be used.
     *
     * @return self
     */
    public function setTrustAllIp6Interfaces($trust_all_ip6_interfaces)
    {
        if (is_null($trust_all_ip6_interfaces)) {
            throw new \InvalidArgumentException('non-nullable trust_all_ip6_interfaces cannot be null');
        }
        $this->container['trust_all_ip6_interfaces'] = $trust_all_ip6_interfaces;

        return $this;
    }

    /**
     * Gets hd_homerun_port_range
     *
     * @return string|null
     */
    public function getHdHomerunPortRange()
    {
        return $this->container['hd_homerun_port_range'];
    }

    /**
     * Sets hd_homerun_port_range
     *
     * @param string|null $hd_homerun_port_range Gets or sets the ports that HDHomerun uses.
     *
     * @return self
     */
    public function setHdHomerunPortRange($hd_homerun_port_range)
    {
        if (is_null($hd_homerun_port_range)) {
            throw new \InvalidArgumentException('non-nullable hd_homerun_port_range cannot be null');
        }
        $this->container['hd_homerun_port_range'] = $hd_homerun_port_range;

        return $this;
    }

    /**
     * Gets published_server_uri_by_subnet
     *
     * @return string[]|null
     */
    public function getPublishedServerUriBySubnet()
    {
        return $this->container['published_server_uri_by_subnet'];
    }

    /**
     * Sets published_server_uri_by_subnet
     *
     * @param string[]|null $published_server_uri_by_subnet Gets or sets the PublishedServerUriBySubnet  Gets or sets PublishedServerUri to advertise for specific subnets.
     *
     * @return self
     */
    public function setPublishedServerUriBySubnet($published_server_uri_by_subnet)
    {
        if (is_null($published_server_uri_by_subnet)) {
            throw new \InvalidArgumentException('non-nullable published_server_uri_by_subnet cannot be null');
        }
        $this->container['published_server_uri_by_subnet'] = $published_server_uri_by_subnet;

        return $this;
    }

    /**
     * Gets auto_discovery_tracing
     *
     * @return bool|null
     */
    public function getAutoDiscoveryTracing()
    {
        return $this->container['auto_discovery_tracing'];
    }

    /**
     * Sets auto_discovery_tracing
     *
     * @param bool|null $auto_discovery_tracing Gets or sets a value indicating whether Autodiscovery tracing is enabled.
     *
     * @return self
     */
    public function setAutoDiscoveryTracing($auto_discovery_tracing)
    {
        if (is_null($auto_discovery_tracing)) {
            throw new \InvalidArgumentException('non-nullable auto_discovery_tracing cannot be null');
        }
        $this->container['auto_discovery_tracing'] = $auto_discovery_tracing;

        return $this;
    }

    /**
     * Gets auto_discovery
     *
     * @return bool|null
     */
    public function getAutoDiscovery()
    {
        return $this->container['auto_discovery'];
    }

    /**
     * Sets auto_discovery
     *
     * @param bool|null $auto_discovery Gets or sets a value indicating whether Autodiscovery is enabled.
     *
     * @return self
     */
    public function setAutoDiscovery($auto_discovery)
    {
        if (is_null($auto_discovery)) {
            throw new \InvalidArgumentException('non-nullable auto_discovery cannot be null');
        }
        $this->container['auto_discovery'] = $auto_discovery;

        return $this;
    }

    /**
     * Gets remote_ip_filter
     *
     * @return string[]|null
     */
    public function getRemoteIpFilter()
    {
        return $this->container['remote_ip_filter'];
    }

    /**
     * Sets remote_ip_filter
     *
     * @param string[]|null $remote_ip_filter Gets or sets the filter for remote IP connectivity. Used in conjuntion with <seealso cref=\"P:Jellyfin.Networking.Configuration.NetworkConfiguration.IsRemoteIPFilterBlacklist\" />.
     *
     * @return self
     */
    public function setRemoteIpFilter($remote_ip_filter)
    {
        if (is_null($remote_ip_filter)) {
            throw new \InvalidArgumentException('non-nullable remote_ip_filter cannot be null');
        }
        $this->container['remote_ip_filter'] = $remote_ip_filter;

        return $this;
    }

    /**
     * Gets is_remote_ip_filter_blacklist
     *
     * @return bool|null
     */
    public function getIsRemoteIpFilterBlacklist()
    {
        return $this->container['is_remote_ip_filter_blacklist'];
    }

    /**
     * Sets is_remote_ip_filter_blacklist
     *
     * @param bool|null $is_remote_ip_filter_blacklist Gets or sets a value indicating whether <seealso cref=\"P:Jellyfin.Networking.Configuration.NetworkConfiguration.RemoteIPFilter\" /> contains a blacklist or a whitelist. Default is a whitelist.
     *
     * @return self
     */
    public function setIsRemoteIpFilterBlacklist($is_remote_ip_filter_blacklist)
    {
        if (is_null($is_remote_ip_filter_blacklist)) {
            throw new \InvalidArgumentException('non-nullable is_remote_ip_filter_blacklist cannot be null');
        }
        $this->container['is_remote_ip_filter_blacklist'] = $is_remote_ip_filter_blacklist;

        return $this;
    }

    /**
     * Gets enable_upn_p
     *
     * @return bool|null
     */
    public function getEnableUpnP()
    {
        return $this->container['enable_upn_p'];
    }

    /**
     * Sets enable_upn_p
     *
     * @param bool|null $enable_upn_p Gets or sets a value indicating whether to enable automatic port forwarding.
     *
     * @return self
     */
    public function setEnableUpnP($enable_upn_p)
    {
        if (is_null($enable_upn_p)) {
            throw new \InvalidArgumentException('non-nullable enable_upn_p cannot be null');
        }
        $this->container['enable_upn_p'] = $enable_upn_p;

        return $this;
    }

    /**
     * Gets enable_remote_access
     *
     * @return bool|null
     */
    public function getEnableRemoteAccess()
    {
        return $this->container['enable_remote_access'];
    }

    /**
     * Sets enable_remote_access
     *
     * @param bool|null $enable_remote_access Gets or sets a value indicating whether access outside of the LAN is permitted.
     *
     * @return self
     */
    public function setEnableRemoteAccess($enable_remote_access)
    {
        if (is_null($enable_remote_access)) {
            throw new \InvalidArgumentException('non-nullable enable_remote_access cannot be null');
        }
        $this->container['enable_remote_access'] = $enable_remote_access;

        return $this;
    }

    /**
     * Gets local_network_subnets
     *
     * @return string[]|null
     */
    public function getLocalNetworkSubnets()
    {
        return $this->container['local_network_subnets'];
    }

    /**
     * Sets local_network_subnets
     *
     * @param string[]|null $local_network_subnets Gets or sets the subnets that are deemed to make up the LAN.
     *
     * @return self
     */
    public function setLocalNetworkSubnets($local_network_subnets)
    {
        if (is_null($local_network_subnets)) {
            throw new \InvalidArgumentException('non-nullable local_network_subnets cannot be null');
        }
        $this->container['local_network_subnets'] = $local_network_subnets;

        return $this;
    }

    /**
     * Gets local_network_addresses
     *
     * @return string[]|null
     */
    public function getLocalNetworkAddresses()
    {
        return $this->container['local_network_addresses'];
    }

    /**
     * Sets local_network_addresses
     *
     * @param string[]|null $local_network_addresses Gets or sets the interface addresses which Jellyfin will bind to. If empty, all interfaces will be used.
     *
     * @return self
     */
    public function setLocalNetworkAddresses($local_network_addresses)
    {
        if (is_null($local_network_addresses)) {
            throw new \InvalidArgumentException('non-nullable local_network_addresses cannot be null');
        }
        $this->container['local_network_addresses'] = $local_network_addresses;

        return $this;
    }

    /**
     * Gets known_proxies
     *
     * @return string[]|null
     */
    public function getKnownProxies()
    {
        return $this->container['known_proxies'];
    }

    /**
     * Sets known_proxies
     *
     * @param string[]|null $known_proxies Gets or sets the known proxies. If the proxy is a network, it's added to the KnownNetworks.
     *
     * @return self
     */
    public function setKnownProxies($known_proxies)
    {
        if (is_null($known_proxies)) {
            throw new \InvalidArgumentException('non-nullable known_proxies cannot be null');
        }
        $this->container['known_proxies'] = $known_proxies;

        return $this;
    }

    /**
     * Gets enable_published_server_uri_by_request
     *
     * @return bool|null
     */
    public function getEnablePublishedServerUriByRequest()
    {
        return $this->container['enable_published_server_uri_by_request'];
    }

    /**
     * Sets enable_published_server_uri_by_request
     *
     * @param bool|null $enable_published_server_uri_by_request Gets or sets a value indicating whether the published server uri is based on information in HTTP requests.
     *
     * @return self
     */
    public function setEnablePublishedServerUriByRequest($enable_published_server_uri_by_request)
    {
        if (is_null($enable_published_server_uri_by_request)) {
            throw new \InvalidArgumentException('non-nullable enable_published_server_uri_by_request cannot be null');
        }
        $this->container['enable_published_server_uri_by_request'] = $enable_published_server_uri_by_request;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


