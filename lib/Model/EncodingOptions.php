<?php
/**
 * EncodingOptions
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Jellyfin API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 10.8.10
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.0.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * EncodingOptions Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class EncodingOptions implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'EncodingOptions';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'encoding_thread_count' => 'int',
        'transcoding_temp_path' => 'string',
        'fallback_font_path' => 'string',
        'enable_fallback_font' => 'bool',
        'down_mix_audio_boost' => 'float',
        'max_muxing_queue_size' => 'int',
        'enable_throttling' => 'bool',
        'throttle_delay_seconds' => 'int',
        'hardware_acceleration_type' => 'string',
        'encoder_app_path' => 'string',
        'encoder_app_path_display' => 'string',
        'vaapi_device' => 'string',
        'enable_tonemapping' => 'bool',
        'enable_vpp_tonemapping' => 'bool',
        'tonemapping_algorithm' => 'string',
        'tonemapping_mode' => 'string',
        'tonemapping_range' => 'string',
        'tonemapping_desat' => 'float',
        'tonemapping_peak' => 'float',
        'tonemapping_param' => 'float',
        'vpp_tonemapping_brightness' => 'float',
        'vpp_tonemapping_contrast' => 'float',
        'h264_crf' => 'int',
        'h265_crf' => 'int',
        'encoder_preset' => 'string',
        'deinterlace_double_rate' => 'bool',
        'deinterlace_method' => 'string',
        'enable_decoding_color_depth10_hevc' => 'bool',
        'enable_decoding_color_depth10_vp9' => 'bool',
        'enable_enhanced_nvdec_decoder' => 'bool',
        'prefer_system_native_hw_decoder' => 'bool',
        'enable_intel_low_power_h264_hw_encoder' => 'bool',
        'enable_intel_low_power_hevc_hw_encoder' => 'bool',
        'enable_hardware_encoding' => 'bool',
        'allow_hevc_encoding' => 'bool',
        'enable_subtitle_extraction' => 'bool',
        'hardware_decoding_codecs' => 'string[]',
        'allow_on_demand_metadata_based_keyframe_extraction_for_extensions' => 'string[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'encoding_thread_count' => 'int32',
        'transcoding_temp_path' => null,
        'fallback_font_path' => null,
        'enable_fallback_font' => null,
        'down_mix_audio_boost' => 'double',
        'max_muxing_queue_size' => 'int32',
        'enable_throttling' => null,
        'throttle_delay_seconds' => 'int32',
        'hardware_acceleration_type' => null,
        'encoder_app_path' => null,
        'encoder_app_path_display' => null,
        'vaapi_device' => null,
        'enable_tonemapping' => null,
        'enable_vpp_tonemapping' => null,
        'tonemapping_algorithm' => null,
        'tonemapping_mode' => null,
        'tonemapping_range' => null,
        'tonemapping_desat' => 'double',
        'tonemapping_peak' => 'double',
        'tonemapping_param' => 'double',
        'vpp_tonemapping_brightness' => 'double',
        'vpp_tonemapping_contrast' => 'double',
        'h264_crf' => 'int32',
        'h265_crf' => 'int32',
        'encoder_preset' => null,
        'deinterlace_double_rate' => null,
        'deinterlace_method' => null,
        'enable_decoding_color_depth10_hevc' => null,
        'enable_decoding_color_depth10_vp9' => null,
        'enable_enhanced_nvdec_decoder' => null,
        'prefer_system_native_hw_decoder' => null,
        'enable_intel_low_power_h264_hw_encoder' => null,
        'enable_intel_low_power_hevc_hw_encoder' => null,
        'enable_hardware_encoding' => null,
        'allow_hevc_encoding' => null,
        'enable_subtitle_extraction' => null,
        'hardware_decoding_codecs' => null,
        'allow_on_demand_metadata_based_keyframe_extraction_for_extensions' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'encoding_thread_count' => false,
		'transcoding_temp_path' => true,
		'fallback_font_path' => true,
		'enable_fallback_font' => false,
		'down_mix_audio_boost' => false,
		'max_muxing_queue_size' => false,
		'enable_throttling' => false,
		'throttle_delay_seconds' => false,
		'hardware_acceleration_type' => true,
		'encoder_app_path' => true,
		'encoder_app_path_display' => true,
		'vaapi_device' => true,
		'enable_tonemapping' => false,
		'enable_vpp_tonemapping' => false,
		'tonemapping_algorithm' => true,
		'tonemapping_mode' => true,
		'tonemapping_range' => true,
		'tonemapping_desat' => false,
		'tonemapping_peak' => false,
		'tonemapping_param' => false,
		'vpp_tonemapping_brightness' => false,
		'vpp_tonemapping_contrast' => false,
		'h264_crf' => false,
		'h265_crf' => false,
		'encoder_preset' => true,
		'deinterlace_double_rate' => false,
		'deinterlace_method' => true,
		'enable_decoding_color_depth10_hevc' => false,
		'enable_decoding_color_depth10_vp9' => false,
		'enable_enhanced_nvdec_decoder' => false,
		'prefer_system_native_hw_decoder' => false,
		'enable_intel_low_power_h264_hw_encoder' => false,
		'enable_intel_low_power_hevc_hw_encoder' => false,
		'enable_hardware_encoding' => false,
		'allow_hevc_encoding' => false,
		'enable_subtitle_extraction' => false,
		'hardware_decoding_codecs' => true,
		'allow_on_demand_metadata_based_keyframe_extraction_for_extensions' => true
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'encoding_thread_count' => 'EncodingThreadCount',
        'transcoding_temp_path' => 'TranscodingTempPath',
        'fallback_font_path' => 'FallbackFontPath',
        'enable_fallback_font' => 'EnableFallbackFont',
        'down_mix_audio_boost' => 'DownMixAudioBoost',
        'max_muxing_queue_size' => 'MaxMuxingQueueSize',
        'enable_throttling' => 'EnableThrottling',
        'throttle_delay_seconds' => 'ThrottleDelaySeconds',
        'hardware_acceleration_type' => 'HardwareAccelerationType',
        'encoder_app_path' => 'EncoderAppPath',
        'encoder_app_path_display' => 'EncoderAppPathDisplay',
        'vaapi_device' => 'VaapiDevice',
        'enable_tonemapping' => 'EnableTonemapping',
        'enable_vpp_tonemapping' => 'EnableVppTonemapping',
        'tonemapping_algorithm' => 'TonemappingAlgorithm',
        'tonemapping_mode' => 'TonemappingMode',
        'tonemapping_range' => 'TonemappingRange',
        'tonemapping_desat' => 'TonemappingDesat',
        'tonemapping_peak' => 'TonemappingPeak',
        'tonemapping_param' => 'TonemappingParam',
        'vpp_tonemapping_brightness' => 'VppTonemappingBrightness',
        'vpp_tonemapping_contrast' => 'VppTonemappingContrast',
        'h264_crf' => 'H264Crf',
        'h265_crf' => 'H265Crf',
        'encoder_preset' => 'EncoderPreset',
        'deinterlace_double_rate' => 'DeinterlaceDoubleRate',
        'deinterlace_method' => 'DeinterlaceMethod',
        'enable_decoding_color_depth10_hevc' => 'EnableDecodingColorDepth10Hevc',
        'enable_decoding_color_depth10_vp9' => 'EnableDecodingColorDepth10Vp9',
        'enable_enhanced_nvdec_decoder' => 'EnableEnhancedNvdecDecoder',
        'prefer_system_native_hw_decoder' => 'PreferSystemNativeHwDecoder',
        'enable_intel_low_power_h264_hw_encoder' => 'EnableIntelLowPowerH264HwEncoder',
        'enable_intel_low_power_hevc_hw_encoder' => 'EnableIntelLowPowerHevcHwEncoder',
        'enable_hardware_encoding' => 'EnableHardwareEncoding',
        'allow_hevc_encoding' => 'AllowHevcEncoding',
        'enable_subtitle_extraction' => 'EnableSubtitleExtraction',
        'hardware_decoding_codecs' => 'HardwareDecodingCodecs',
        'allow_on_demand_metadata_based_keyframe_extraction_for_extensions' => 'AllowOnDemandMetadataBasedKeyframeExtractionForExtensions'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'encoding_thread_count' => 'setEncodingThreadCount',
        'transcoding_temp_path' => 'setTranscodingTempPath',
        'fallback_font_path' => 'setFallbackFontPath',
        'enable_fallback_font' => 'setEnableFallbackFont',
        'down_mix_audio_boost' => 'setDownMixAudioBoost',
        'max_muxing_queue_size' => 'setMaxMuxingQueueSize',
        'enable_throttling' => 'setEnableThrottling',
        'throttle_delay_seconds' => 'setThrottleDelaySeconds',
        'hardware_acceleration_type' => 'setHardwareAccelerationType',
        'encoder_app_path' => 'setEncoderAppPath',
        'encoder_app_path_display' => 'setEncoderAppPathDisplay',
        'vaapi_device' => 'setVaapiDevice',
        'enable_tonemapping' => 'setEnableTonemapping',
        'enable_vpp_tonemapping' => 'setEnableVppTonemapping',
        'tonemapping_algorithm' => 'setTonemappingAlgorithm',
        'tonemapping_mode' => 'setTonemappingMode',
        'tonemapping_range' => 'setTonemappingRange',
        'tonemapping_desat' => 'setTonemappingDesat',
        'tonemapping_peak' => 'setTonemappingPeak',
        'tonemapping_param' => 'setTonemappingParam',
        'vpp_tonemapping_brightness' => 'setVppTonemappingBrightness',
        'vpp_tonemapping_contrast' => 'setVppTonemappingContrast',
        'h264_crf' => 'setH264Crf',
        'h265_crf' => 'setH265Crf',
        'encoder_preset' => 'setEncoderPreset',
        'deinterlace_double_rate' => 'setDeinterlaceDoubleRate',
        'deinterlace_method' => 'setDeinterlaceMethod',
        'enable_decoding_color_depth10_hevc' => 'setEnableDecodingColorDepth10Hevc',
        'enable_decoding_color_depth10_vp9' => 'setEnableDecodingColorDepth10Vp9',
        'enable_enhanced_nvdec_decoder' => 'setEnableEnhancedNvdecDecoder',
        'prefer_system_native_hw_decoder' => 'setPreferSystemNativeHwDecoder',
        'enable_intel_low_power_h264_hw_encoder' => 'setEnableIntelLowPowerH264HwEncoder',
        'enable_intel_low_power_hevc_hw_encoder' => 'setEnableIntelLowPowerHevcHwEncoder',
        'enable_hardware_encoding' => 'setEnableHardwareEncoding',
        'allow_hevc_encoding' => 'setAllowHevcEncoding',
        'enable_subtitle_extraction' => 'setEnableSubtitleExtraction',
        'hardware_decoding_codecs' => 'setHardwareDecodingCodecs',
        'allow_on_demand_metadata_based_keyframe_extraction_for_extensions' => 'setAllowOnDemandMetadataBasedKeyframeExtractionForExtensions'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'encoding_thread_count' => 'getEncodingThreadCount',
        'transcoding_temp_path' => 'getTranscodingTempPath',
        'fallback_font_path' => 'getFallbackFontPath',
        'enable_fallback_font' => 'getEnableFallbackFont',
        'down_mix_audio_boost' => 'getDownMixAudioBoost',
        'max_muxing_queue_size' => 'getMaxMuxingQueueSize',
        'enable_throttling' => 'getEnableThrottling',
        'throttle_delay_seconds' => 'getThrottleDelaySeconds',
        'hardware_acceleration_type' => 'getHardwareAccelerationType',
        'encoder_app_path' => 'getEncoderAppPath',
        'encoder_app_path_display' => 'getEncoderAppPathDisplay',
        'vaapi_device' => 'getVaapiDevice',
        'enable_tonemapping' => 'getEnableTonemapping',
        'enable_vpp_tonemapping' => 'getEnableVppTonemapping',
        'tonemapping_algorithm' => 'getTonemappingAlgorithm',
        'tonemapping_mode' => 'getTonemappingMode',
        'tonemapping_range' => 'getTonemappingRange',
        'tonemapping_desat' => 'getTonemappingDesat',
        'tonemapping_peak' => 'getTonemappingPeak',
        'tonemapping_param' => 'getTonemappingParam',
        'vpp_tonemapping_brightness' => 'getVppTonemappingBrightness',
        'vpp_tonemapping_contrast' => 'getVppTonemappingContrast',
        'h264_crf' => 'getH264Crf',
        'h265_crf' => 'getH265Crf',
        'encoder_preset' => 'getEncoderPreset',
        'deinterlace_double_rate' => 'getDeinterlaceDoubleRate',
        'deinterlace_method' => 'getDeinterlaceMethod',
        'enable_decoding_color_depth10_hevc' => 'getEnableDecodingColorDepth10Hevc',
        'enable_decoding_color_depth10_vp9' => 'getEnableDecodingColorDepth10Vp9',
        'enable_enhanced_nvdec_decoder' => 'getEnableEnhancedNvdecDecoder',
        'prefer_system_native_hw_decoder' => 'getPreferSystemNativeHwDecoder',
        'enable_intel_low_power_h264_hw_encoder' => 'getEnableIntelLowPowerH264HwEncoder',
        'enable_intel_low_power_hevc_hw_encoder' => 'getEnableIntelLowPowerHevcHwEncoder',
        'enable_hardware_encoding' => 'getEnableHardwareEncoding',
        'allow_hevc_encoding' => 'getAllowHevcEncoding',
        'enable_subtitle_extraction' => 'getEnableSubtitleExtraction',
        'hardware_decoding_codecs' => 'getHardwareDecodingCodecs',
        'allow_on_demand_metadata_based_keyframe_extraction_for_extensions' => 'getAllowOnDemandMetadataBasedKeyframeExtractionForExtensions'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('encoding_thread_count', $data ?? [], null);
        $this->setIfExists('transcoding_temp_path', $data ?? [], null);
        $this->setIfExists('fallback_font_path', $data ?? [], null);
        $this->setIfExists('enable_fallback_font', $data ?? [], null);
        $this->setIfExists('down_mix_audio_boost', $data ?? [], null);
        $this->setIfExists('max_muxing_queue_size', $data ?? [], null);
        $this->setIfExists('enable_throttling', $data ?? [], null);
        $this->setIfExists('throttle_delay_seconds', $data ?? [], null);
        $this->setIfExists('hardware_acceleration_type', $data ?? [], null);
        $this->setIfExists('encoder_app_path', $data ?? [], null);
        $this->setIfExists('encoder_app_path_display', $data ?? [], null);
        $this->setIfExists('vaapi_device', $data ?? [], null);
        $this->setIfExists('enable_tonemapping', $data ?? [], null);
        $this->setIfExists('enable_vpp_tonemapping', $data ?? [], null);
        $this->setIfExists('tonemapping_algorithm', $data ?? [], null);
        $this->setIfExists('tonemapping_mode', $data ?? [], null);
        $this->setIfExists('tonemapping_range', $data ?? [], null);
        $this->setIfExists('tonemapping_desat', $data ?? [], null);
        $this->setIfExists('tonemapping_peak', $data ?? [], null);
        $this->setIfExists('tonemapping_param', $data ?? [], null);
        $this->setIfExists('vpp_tonemapping_brightness', $data ?? [], null);
        $this->setIfExists('vpp_tonemapping_contrast', $data ?? [], null);
        $this->setIfExists('h264_crf', $data ?? [], null);
        $this->setIfExists('h265_crf', $data ?? [], null);
        $this->setIfExists('encoder_preset', $data ?? [], null);
        $this->setIfExists('deinterlace_double_rate', $data ?? [], null);
        $this->setIfExists('deinterlace_method', $data ?? [], null);
        $this->setIfExists('enable_decoding_color_depth10_hevc', $data ?? [], null);
        $this->setIfExists('enable_decoding_color_depth10_vp9', $data ?? [], null);
        $this->setIfExists('enable_enhanced_nvdec_decoder', $data ?? [], null);
        $this->setIfExists('prefer_system_native_hw_decoder', $data ?? [], null);
        $this->setIfExists('enable_intel_low_power_h264_hw_encoder', $data ?? [], null);
        $this->setIfExists('enable_intel_low_power_hevc_hw_encoder', $data ?? [], null);
        $this->setIfExists('enable_hardware_encoding', $data ?? [], null);
        $this->setIfExists('allow_hevc_encoding', $data ?? [], null);
        $this->setIfExists('enable_subtitle_extraction', $data ?? [], null);
        $this->setIfExists('hardware_decoding_codecs', $data ?? [], null);
        $this->setIfExists('allow_on_demand_metadata_based_keyframe_extraction_for_extensions', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets encoding_thread_count
     *
     * @return int|null
     */
    public function getEncodingThreadCount()
    {
        return $this->container['encoding_thread_count'];
    }

    /**
     * Sets encoding_thread_count
     *
     * @param int|null $encoding_thread_count encoding_thread_count
     *
     * @return self
     */
    public function setEncodingThreadCount($encoding_thread_count)
    {
        if (is_null($encoding_thread_count)) {
            throw new \InvalidArgumentException('non-nullable encoding_thread_count cannot be null');
        }
        $this->container['encoding_thread_count'] = $encoding_thread_count;

        return $this;
    }

    /**
     * Gets transcoding_temp_path
     *
     * @return string|null
     */
    public function getTranscodingTempPath()
    {
        return $this->container['transcoding_temp_path'];
    }

    /**
     * Sets transcoding_temp_path
     *
     * @param string|null $transcoding_temp_path transcoding_temp_path
     *
     * @return self
     */
    public function setTranscodingTempPath($transcoding_temp_path)
    {
        if (is_null($transcoding_temp_path)) {
            array_push($this->openAPINullablesSetToNull, 'transcoding_temp_path');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('transcoding_temp_path', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['transcoding_temp_path'] = $transcoding_temp_path;

        return $this;
    }

    /**
     * Gets fallback_font_path
     *
     * @return string|null
     */
    public function getFallbackFontPath()
    {
        return $this->container['fallback_font_path'];
    }

    /**
     * Sets fallback_font_path
     *
     * @param string|null $fallback_font_path fallback_font_path
     *
     * @return self
     */
    public function setFallbackFontPath($fallback_font_path)
    {
        if (is_null($fallback_font_path)) {
            array_push($this->openAPINullablesSetToNull, 'fallback_font_path');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('fallback_font_path', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['fallback_font_path'] = $fallback_font_path;

        return $this;
    }

    /**
     * Gets enable_fallback_font
     *
     * @return bool|null
     */
    public function getEnableFallbackFont()
    {
        return $this->container['enable_fallback_font'];
    }

    /**
     * Sets enable_fallback_font
     *
     * @param bool|null $enable_fallback_font enable_fallback_font
     *
     * @return self
     */
    public function setEnableFallbackFont($enable_fallback_font)
    {
        if (is_null($enable_fallback_font)) {
            throw new \InvalidArgumentException('non-nullable enable_fallback_font cannot be null');
        }
        $this->container['enable_fallback_font'] = $enable_fallback_font;

        return $this;
    }

    /**
     * Gets down_mix_audio_boost
     *
     * @return float|null
     */
    public function getDownMixAudioBoost()
    {
        return $this->container['down_mix_audio_boost'];
    }

    /**
     * Sets down_mix_audio_boost
     *
     * @param float|null $down_mix_audio_boost down_mix_audio_boost
     *
     * @return self
     */
    public function setDownMixAudioBoost($down_mix_audio_boost)
    {
        if (is_null($down_mix_audio_boost)) {
            throw new \InvalidArgumentException('non-nullable down_mix_audio_boost cannot be null');
        }
        $this->container['down_mix_audio_boost'] = $down_mix_audio_boost;

        return $this;
    }

    /**
     * Gets max_muxing_queue_size
     *
     * @return int|null
     */
    public function getMaxMuxingQueueSize()
    {
        return $this->container['max_muxing_queue_size'];
    }

    /**
     * Sets max_muxing_queue_size
     *
     * @param int|null $max_muxing_queue_size max_muxing_queue_size
     *
     * @return self
     */
    public function setMaxMuxingQueueSize($max_muxing_queue_size)
    {
        if (is_null($max_muxing_queue_size)) {
            throw new \InvalidArgumentException('non-nullable max_muxing_queue_size cannot be null');
        }
        $this->container['max_muxing_queue_size'] = $max_muxing_queue_size;

        return $this;
    }

    /**
     * Gets enable_throttling
     *
     * @return bool|null
     */
    public function getEnableThrottling()
    {
        return $this->container['enable_throttling'];
    }

    /**
     * Sets enable_throttling
     *
     * @param bool|null $enable_throttling enable_throttling
     *
     * @return self
     */
    public function setEnableThrottling($enable_throttling)
    {
        if (is_null($enable_throttling)) {
            throw new \InvalidArgumentException('non-nullable enable_throttling cannot be null');
        }
        $this->container['enable_throttling'] = $enable_throttling;

        return $this;
    }

    /**
     * Gets throttle_delay_seconds
     *
     * @return int|null
     */
    public function getThrottleDelaySeconds()
    {
        return $this->container['throttle_delay_seconds'];
    }

    /**
     * Sets throttle_delay_seconds
     *
     * @param int|null $throttle_delay_seconds throttle_delay_seconds
     *
     * @return self
     */
    public function setThrottleDelaySeconds($throttle_delay_seconds)
    {
        if (is_null($throttle_delay_seconds)) {
            throw new \InvalidArgumentException('non-nullable throttle_delay_seconds cannot be null');
        }
        $this->container['throttle_delay_seconds'] = $throttle_delay_seconds;

        return $this;
    }

    /**
     * Gets hardware_acceleration_type
     *
     * @return string|null
     */
    public function getHardwareAccelerationType()
    {
        return $this->container['hardware_acceleration_type'];
    }

    /**
     * Sets hardware_acceleration_type
     *
     * @param string|null $hardware_acceleration_type hardware_acceleration_type
     *
     * @return self
     */
    public function setHardwareAccelerationType($hardware_acceleration_type)
    {
        if (is_null($hardware_acceleration_type)) {
            array_push($this->openAPINullablesSetToNull, 'hardware_acceleration_type');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('hardware_acceleration_type', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['hardware_acceleration_type'] = $hardware_acceleration_type;

        return $this;
    }

    /**
     * Gets encoder_app_path
     *
     * @return string|null
     */
    public function getEncoderAppPath()
    {
        return $this->container['encoder_app_path'];
    }

    /**
     * Sets encoder_app_path
     *
     * @param string|null $encoder_app_path Gets or sets the FFmpeg path as set by the user via the UI.
     *
     * @return self
     */
    public function setEncoderAppPath($encoder_app_path)
    {
        if (is_null($encoder_app_path)) {
            array_push($this->openAPINullablesSetToNull, 'encoder_app_path');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('encoder_app_path', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['encoder_app_path'] = $encoder_app_path;

        return $this;
    }

    /**
     * Gets encoder_app_path_display
     *
     * @return string|null
     */
    public function getEncoderAppPathDisplay()
    {
        return $this->container['encoder_app_path_display'];
    }

    /**
     * Sets encoder_app_path_display
     *
     * @param string|null $encoder_app_path_display Gets or sets the current FFmpeg path being used by the system and displayed on the transcode page.
     *
     * @return self
     */
    public function setEncoderAppPathDisplay($encoder_app_path_display)
    {
        if (is_null($encoder_app_path_display)) {
            array_push($this->openAPINullablesSetToNull, 'encoder_app_path_display');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('encoder_app_path_display', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['encoder_app_path_display'] = $encoder_app_path_display;

        return $this;
    }

    /**
     * Gets vaapi_device
     *
     * @return string|null
     */
    public function getVaapiDevice()
    {
        return $this->container['vaapi_device'];
    }

    /**
     * Sets vaapi_device
     *
     * @param string|null $vaapi_device vaapi_device
     *
     * @return self
     */
    public function setVaapiDevice($vaapi_device)
    {
        if (is_null($vaapi_device)) {
            array_push($this->openAPINullablesSetToNull, 'vaapi_device');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('vaapi_device', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['vaapi_device'] = $vaapi_device;

        return $this;
    }

    /**
     * Gets enable_tonemapping
     *
     * @return bool|null
     */
    public function getEnableTonemapping()
    {
        return $this->container['enable_tonemapping'];
    }

    /**
     * Sets enable_tonemapping
     *
     * @param bool|null $enable_tonemapping enable_tonemapping
     *
     * @return self
     */
    public function setEnableTonemapping($enable_tonemapping)
    {
        if (is_null($enable_tonemapping)) {
            throw new \InvalidArgumentException('non-nullable enable_tonemapping cannot be null');
        }
        $this->container['enable_tonemapping'] = $enable_tonemapping;

        return $this;
    }

    /**
     * Gets enable_vpp_tonemapping
     *
     * @return bool|null
     */
    public function getEnableVppTonemapping()
    {
        return $this->container['enable_vpp_tonemapping'];
    }

    /**
     * Sets enable_vpp_tonemapping
     *
     * @param bool|null $enable_vpp_tonemapping enable_vpp_tonemapping
     *
     * @return self
     */
    public function setEnableVppTonemapping($enable_vpp_tonemapping)
    {
        if (is_null($enable_vpp_tonemapping)) {
            throw new \InvalidArgumentException('non-nullable enable_vpp_tonemapping cannot be null');
        }
        $this->container['enable_vpp_tonemapping'] = $enable_vpp_tonemapping;

        return $this;
    }

    /**
     * Gets tonemapping_algorithm
     *
     * @return string|null
     */
    public function getTonemappingAlgorithm()
    {
        return $this->container['tonemapping_algorithm'];
    }

    /**
     * Sets tonemapping_algorithm
     *
     * @param string|null $tonemapping_algorithm tonemapping_algorithm
     *
     * @return self
     */
    public function setTonemappingAlgorithm($tonemapping_algorithm)
    {
        if (is_null($tonemapping_algorithm)) {
            array_push($this->openAPINullablesSetToNull, 'tonemapping_algorithm');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('tonemapping_algorithm', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['tonemapping_algorithm'] = $tonemapping_algorithm;

        return $this;
    }

    /**
     * Gets tonemapping_mode
     *
     * @return string|null
     */
    public function getTonemappingMode()
    {
        return $this->container['tonemapping_mode'];
    }

    /**
     * Sets tonemapping_mode
     *
     * @param string|null $tonemapping_mode tonemapping_mode
     *
     * @return self
     */
    public function setTonemappingMode($tonemapping_mode)
    {
        if (is_null($tonemapping_mode)) {
            array_push($this->openAPINullablesSetToNull, 'tonemapping_mode');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('tonemapping_mode', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['tonemapping_mode'] = $tonemapping_mode;

        return $this;
    }

    /**
     * Gets tonemapping_range
     *
     * @return string|null
     */
    public function getTonemappingRange()
    {
        return $this->container['tonemapping_range'];
    }

    /**
     * Sets tonemapping_range
     *
     * @param string|null $tonemapping_range tonemapping_range
     *
     * @return self
     */
    public function setTonemappingRange($tonemapping_range)
    {
        if (is_null($tonemapping_range)) {
            array_push($this->openAPINullablesSetToNull, 'tonemapping_range');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('tonemapping_range', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['tonemapping_range'] = $tonemapping_range;

        return $this;
    }

    /**
     * Gets tonemapping_desat
     *
     * @return float|null
     */
    public function getTonemappingDesat()
    {
        return $this->container['tonemapping_desat'];
    }

    /**
     * Sets tonemapping_desat
     *
     * @param float|null $tonemapping_desat tonemapping_desat
     *
     * @return self
     */
    public function setTonemappingDesat($tonemapping_desat)
    {
        if (is_null($tonemapping_desat)) {
            throw new \InvalidArgumentException('non-nullable tonemapping_desat cannot be null');
        }
        $this->container['tonemapping_desat'] = $tonemapping_desat;

        return $this;
    }

    /**
     * Gets tonemapping_peak
     *
     * @return float|null
     */
    public function getTonemappingPeak()
    {
        return $this->container['tonemapping_peak'];
    }

    /**
     * Sets tonemapping_peak
     *
     * @param float|null $tonemapping_peak tonemapping_peak
     *
     * @return self
     */
    public function setTonemappingPeak($tonemapping_peak)
    {
        if (is_null($tonemapping_peak)) {
            throw new \InvalidArgumentException('non-nullable tonemapping_peak cannot be null');
        }
        $this->container['tonemapping_peak'] = $tonemapping_peak;

        return $this;
    }

    /**
     * Gets tonemapping_param
     *
     * @return float|null
     */
    public function getTonemappingParam()
    {
        return $this->container['tonemapping_param'];
    }

    /**
     * Sets tonemapping_param
     *
     * @param float|null $tonemapping_param tonemapping_param
     *
     * @return self
     */
    public function setTonemappingParam($tonemapping_param)
    {
        if (is_null($tonemapping_param)) {
            throw new \InvalidArgumentException('non-nullable tonemapping_param cannot be null');
        }
        $this->container['tonemapping_param'] = $tonemapping_param;

        return $this;
    }

    /**
     * Gets vpp_tonemapping_brightness
     *
     * @return float|null
     */
    public function getVppTonemappingBrightness()
    {
        return $this->container['vpp_tonemapping_brightness'];
    }

    /**
     * Sets vpp_tonemapping_brightness
     *
     * @param float|null $vpp_tonemapping_brightness vpp_tonemapping_brightness
     *
     * @return self
     */
    public function setVppTonemappingBrightness($vpp_tonemapping_brightness)
    {
        if (is_null($vpp_tonemapping_brightness)) {
            throw new \InvalidArgumentException('non-nullable vpp_tonemapping_brightness cannot be null');
        }
        $this->container['vpp_tonemapping_brightness'] = $vpp_tonemapping_brightness;

        return $this;
    }

    /**
     * Gets vpp_tonemapping_contrast
     *
     * @return float|null
     */
    public function getVppTonemappingContrast()
    {
        return $this->container['vpp_tonemapping_contrast'];
    }

    /**
     * Sets vpp_tonemapping_contrast
     *
     * @param float|null $vpp_tonemapping_contrast vpp_tonemapping_contrast
     *
     * @return self
     */
    public function setVppTonemappingContrast($vpp_tonemapping_contrast)
    {
        if (is_null($vpp_tonemapping_contrast)) {
            throw new \InvalidArgumentException('non-nullable vpp_tonemapping_contrast cannot be null');
        }
        $this->container['vpp_tonemapping_contrast'] = $vpp_tonemapping_contrast;

        return $this;
    }

    /**
     * Gets h264_crf
     *
     * @return int|null
     */
    public function getH264Crf()
    {
        return $this->container['h264_crf'];
    }

    /**
     * Sets h264_crf
     *
     * @param int|null $h264_crf h264_crf
     *
     * @return self
     */
    public function setH264Crf($h264_crf)
    {
        if (is_null($h264_crf)) {
            throw new \InvalidArgumentException('non-nullable h264_crf cannot be null');
        }
        $this->container['h264_crf'] = $h264_crf;

        return $this;
    }

    /**
     * Gets h265_crf
     *
     * @return int|null
     */
    public function getH265Crf()
    {
        return $this->container['h265_crf'];
    }

    /**
     * Sets h265_crf
     *
     * @param int|null $h265_crf h265_crf
     *
     * @return self
     */
    public function setH265Crf($h265_crf)
    {
        if (is_null($h265_crf)) {
            throw new \InvalidArgumentException('non-nullable h265_crf cannot be null');
        }
        $this->container['h265_crf'] = $h265_crf;

        return $this;
    }

    /**
     * Gets encoder_preset
     *
     * @return string|null
     */
    public function getEncoderPreset()
    {
        return $this->container['encoder_preset'];
    }

    /**
     * Sets encoder_preset
     *
     * @param string|null $encoder_preset encoder_preset
     *
     * @return self
     */
    public function setEncoderPreset($encoder_preset)
    {
        if (is_null($encoder_preset)) {
            array_push($this->openAPINullablesSetToNull, 'encoder_preset');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('encoder_preset', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['encoder_preset'] = $encoder_preset;

        return $this;
    }

    /**
     * Gets deinterlace_double_rate
     *
     * @return bool|null
     */
    public function getDeinterlaceDoubleRate()
    {
        return $this->container['deinterlace_double_rate'];
    }

    /**
     * Sets deinterlace_double_rate
     *
     * @param bool|null $deinterlace_double_rate deinterlace_double_rate
     *
     * @return self
     */
    public function setDeinterlaceDoubleRate($deinterlace_double_rate)
    {
        if (is_null($deinterlace_double_rate)) {
            throw new \InvalidArgumentException('non-nullable deinterlace_double_rate cannot be null');
        }
        $this->container['deinterlace_double_rate'] = $deinterlace_double_rate;

        return $this;
    }

    /**
     * Gets deinterlace_method
     *
     * @return string|null
     */
    public function getDeinterlaceMethod()
    {
        return $this->container['deinterlace_method'];
    }

    /**
     * Sets deinterlace_method
     *
     * @param string|null $deinterlace_method deinterlace_method
     *
     * @return self
     */
    public function setDeinterlaceMethod($deinterlace_method)
    {
        if (is_null($deinterlace_method)) {
            array_push($this->openAPINullablesSetToNull, 'deinterlace_method');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('deinterlace_method', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['deinterlace_method'] = $deinterlace_method;

        return $this;
    }

    /**
     * Gets enable_decoding_color_depth10_hevc
     *
     * @return bool|null
     */
    public function getEnableDecodingColorDepth10Hevc()
    {
        return $this->container['enable_decoding_color_depth10_hevc'];
    }

    /**
     * Sets enable_decoding_color_depth10_hevc
     *
     * @param bool|null $enable_decoding_color_depth10_hevc enable_decoding_color_depth10_hevc
     *
     * @return self
     */
    public function setEnableDecodingColorDepth10Hevc($enable_decoding_color_depth10_hevc)
    {
        if (is_null($enable_decoding_color_depth10_hevc)) {
            throw new \InvalidArgumentException('non-nullable enable_decoding_color_depth10_hevc cannot be null');
        }
        $this->container['enable_decoding_color_depth10_hevc'] = $enable_decoding_color_depth10_hevc;

        return $this;
    }

    /**
     * Gets enable_decoding_color_depth10_vp9
     *
     * @return bool|null
     */
    public function getEnableDecodingColorDepth10Vp9()
    {
        return $this->container['enable_decoding_color_depth10_vp9'];
    }

    /**
     * Sets enable_decoding_color_depth10_vp9
     *
     * @param bool|null $enable_decoding_color_depth10_vp9 enable_decoding_color_depth10_vp9
     *
     * @return self
     */
    public function setEnableDecodingColorDepth10Vp9($enable_decoding_color_depth10_vp9)
    {
        if (is_null($enable_decoding_color_depth10_vp9)) {
            throw new \InvalidArgumentException('non-nullable enable_decoding_color_depth10_vp9 cannot be null');
        }
        $this->container['enable_decoding_color_depth10_vp9'] = $enable_decoding_color_depth10_vp9;

        return $this;
    }

    /**
     * Gets enable_enhanced_nvdec_decoder
     *
     * @return bool|null
     */
    public function getEnableEnhancedNvdecDecoder()
    {
        return $this->container['enable_enhanced_nvdec_decoder'];
    }

    /**
     * Sets enable_enhanced_nvdec_decoder
     *
     * @param bool|null $enable_enhanced_nvdec_decoder enable_enhanced_nvdec_decoder
     *
     * @return self
     */
    public function setEnableEnhancedNvdecDecoder($enable_enhanced_nvdec_decoder)
    {
        if (is_null($enable_enhanced_nvdec_decoder)) {
            throw new \InvalidArgumentException('non-nullable enable_enhanced_nvdec_decoder cannot be null');
        }
        $this->container['enable_enhanced_nvdec_decoder'] = $enable_enhanced_nvdec_decoder;

        return $this;
    }

    /**
     * Gets prefer_system_native_hw_decoder
     *
     * @return bool|null
     */
    public function getPreferSystemNativeHwDecoder()
    {
        return $this->container['prefer_system_native_hw_decoder'];
    }

    /**
     * Sets prefer_system_native_hw_decoder
     *
     * @param bool|null $prefer_system_native_hw_decoder prefer_system_native_hw_decoder
     *
     * @return self
     */
    public function setPreferSystemNativeHwDecoder($prefer_system_native_hw_decoder)
    {
        if (is_null($prefer_system_native_hw_decoder)) {
            throw new \InvalidArgumentException('non-nullable prefer_system_native_hw_decoder cannot be null');
        }
        $this->container['prefer_system_native_hw_decoder'] = $prefer_system_native_hw_decoder;

        return $this;
    }

    /**
     * Gets enable_intel_low_power_h264_hw_encoder
     *
     * @return bool|null
     */
    public function getEnableIntelLowPowerH264HwEncoder()
    {
        return $this->container['enable_intel_low_power_h264_hw_encoder'];
    }

    /**
     * Sets enable_intel_low_power_h264_hw_encoder
     *
     * @param bool|null $enable_intel_low_power_h264_hw_encoder enable_intel_low_power_h264_hw_encoder
     *
     * @return self
     */
    public function setEnableIntelLowPowerH264HwEncoder($enable_intel_low_power_h264_hw_encoder)
    {
        if (is_null($enable_intel_low_power_h264_hw_encoder)) {
            throw new \InvalidArgumentException('non-nullable enable_intel_low_power_h264_hw_encoder cannot be null');
        }
        $this->container['enable_intel_low_power_h264_hw_encoder'] = $enable_intel_low_power_h264_hw_encoder;

        return $this;
    }

    /**
     * Gets enable_intel_low_power_hevc_hw_encoder
     *
     * @return bool|null
     */
    public function getEnableIntelLowPowerHevcHwEncoder()
    {
        return $this->container['enable_intel_low_power_hevc_hw_encoder'];
    }

    /**
     * Sets enable_intel_low_power_hevc_hw_encoder
     *
     * @param bool|null $enable_intel_low_power_hevc_hw_encoder enable_intel_low_power_hevc_hw_encoder
     *
     * @return self
     */
    public function setEnableIntelLowPowerHevcHwEncoder($enable_intel_low_power_hevc_hw_encoder)
    {
        if (is_null($enable_intel_low_power_hevc_hw_encoder)) {
            throw new \InvalidArgumentException('non-nullable enable_intel_low_power_hevc_hw_encoder cannot be null');
        }
        $this->container['enable_intel_low_power_hevc_hw_encoder'] = $enable_intel_low_power_hevc_hw_encoder;

        return $this;
    }

    /**
     * Gets enable_hardware_encoding
     *
     * @return bool|null
     */
    public function getEnableHardwareEncoding()
    {
        return $this->container['enable_hardware_encoding'];
    }

    /**
     * Sets enable_hardware_encoding
     *
     * @param bool|null $enable_hardware_encoding enable_hardware_encoding
     *
     * @return self
     */
    public function setEnableHardwareEncoding($enable_hardware_encoding)
    {
        if (is_null($enable_hardware_encoding)) {
            throw new \InvalidArgumentException('non-nullable enable_hardware_encoding cannot be null');
        }
        $this->container['enable_hardware_encoding'] = $enable_hardware_encoding;

        return $this;
    }

    /**
     * Gets allow_hevc_encoding
     *
     * @return bool|null
     */
    public function getAllowHevcEncoding()
    {
        return $this->container['allow_hevc_encoding'];
    }

    /**
     * Sets allow_hevc_encoding
     *
     * @param bool|null $allow_hevc_encoding allow_hevc_encoding
     *
     * @return self
     */
    public function setAllowHevcEncoding($allow_hevc_encoding)
    {
        if (is_null($allow_hevc_encoding)) {
            throw new \InvalidArgumentException('non-nullable allow_hevc_encoding cannot be null');
        }
        $this->container['allow_hevc_encoding'] = $allow_hevc_encoding;

        return $this;
    }

    /**
     * Gets enable_subtitle_extraction
     *
     * @return bool|null
     */
    public function getEnableSubtitleExtraction()
    {
        return $this->container['enable_subtitle_extraction'];
    }

    /**
     * Sets enable_subtitle_extraction
     *
     * @param bool|null $enable_subtitle_extraction enable_subtitle_extraction
     *
     * @return self
     */
    public function setEnableSubtitleExtraction($enable_subtitle_extraction)
    {
        if (is_null($enable_subtitle_extraction)) {
            throw new \InvalidArgumentException('non-nullable enable_subtitle_extraction cannot be null');
        }
        $this->container['enable_subtitle_extraction'] = $enable_subtitle_extraction;

        return $this;
    }

    /**
     * Gets hardware_decoding_codecs
     *
     * @return string[]|null
     */
    public function getHardwareDecodingCodecs()
    {
        return $this->container['hardware_decoding_codecs'];
    }

    /**
     * Sets hardware_decoding_codecs
     *
     * @param string[]|null $hardware_decoding_codecs hardware_decoding_codecs
     *
     * @return self
     */
    public function setHardwareDecodingCodecs($hardware_decoding_codecs)
    {
        if (is_null($hardware_decoding_codecs)) {
            array_push($this->openAPINullablesSetToNull, 'hardware_decoding_codecs');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('hardware_decoding_codecs', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['hardware_decoding_codecs'] = $hardware_decoding_codecs;

        return $this;
    }

    /**
     * Gets allow_on_demand_metadata_based_keyframe_extraction_for_extensions
     *
     * @return string[]|null
     */
    public function getAllowOnDemandMetadataBasedKeyframeExtractionForExtensions()
    {
        return $this->container['allow_on_demand_metadata_based_keyframe_extraction_for_extensions'];
    }

    /**
     * Sets allow_on_demand_metadata_based_keyframe_extraction_for_extensions
     *
     * @param string[]|null $allow_on_demand_metadata_based_keyframe_extraction_for_extensions allow_on_demand_metadata_based_keyframe_extraction_for_extensions
     *
     * @return self
     */
    public function setAllowOnDemandMetadataBasedKeyframeExtractionForExtensions($allow_on_demand_metadata_based_keyframe_extraction_for_extensions)
    {
        if (is_null($allow_on_demand_metadata_based_keyframe_extraction_for_extensions)) {
            array_push($this->openAPINullablesSetToNull, 'allow_on_demand_metadata_based_keyframe_extraction_for_extensions');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('allow_on_demand_metadata_based_keyframe_extraction_for_extensions', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['allow_on_demand_metadata_based_keyframe_extraction_for_extensions'] = $allow_on_demand_metadata_based_keyframe_extraction_for_extensions;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


