<?php
/**
 * ImageApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Jellyfin API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 10.8.10
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.0.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * ImageApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ImageApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'deleteCustomSplashscreen' => [
            'application/json',
        ],
        'deleteItemImage' => [
            'application/json',
        ],
        'deleteItemImageByIndex' => [
            'application/json',
        ],
        'deleteUserImage' => [
            'application/json',
        ],
        'deleteUserImageByIndex' => [
            'application/json',
        ],
        'getArtistImage' => [
            'application/json',
        ],
        'getGenreImage' => [
            'application/json',
        ],
        'getGenreImageByIndex' => [
            'application/json',
        ],
        'getItemImage' => [
            'application/json',
        ],
        'getItemImage2' => [
            'application/json',
        ],
        'getItemImageByIndex' => [
            'application/json',
        ],
        'getItemImageInfos' => [
            'application/json',
        ],
        'getMusicGenreImage' => [
            'application/json',
        ],
        'getMusicGenreImageByIndex' => [
            'application/json',
        ],
        'getPersonImage' => [
            'application/json',
        ],
        'getPersonImageByIndex' => [
            'application/json',
        ],
        'getSplashscreen' => [
            'application/json',
        ],
        'getStudioImage' => [
            'application/json',
        ],
        'getStudioImageByIndex' => [
            'application/json',
        ],
        'getUserImage' => [
            'application/json',
        ],
        'getUserImageByIndex' => [
            'application/json',
        ],
        'headArtistImage' => [
            'application/json',
        ],
        'headGenreImage' => [
            'application/json',
        ],
        'headGenreImageByIndex' => [
            'application/json',
        ],
        'headItemImage' => [
            'application/json',
        ],
        'headItemImage2' => [
            'application/json',
        ],
        'headItemImageByIndex' => [
            'application/json',
        ],
        'headMusicGenreImage' => [
            'application/json',
        ],
        'headMusicGenreImageByIndex' => [
            'application/json',
        ],
        'headPersonImage' => [
            'application/json',
        ],
        'headPersonImageByIndex' => [
            'application/json',
        ],
        'headStudioImage' => [
            'application/json',
        ],
        'headStudioImageByIndex' => [
            'application/json',
        ],
        'headUserImage' => [
            'application/json',
        ],
        'headUserImageByIndex' => [
            'application/json',
        ],
        'postUserImage' => [
            'image/*',
        ],
        'postUserImageByIndex' => [
            'image/*',
        ],
        'setItemImage' => [
            'image/*',
        ],
        'setItemImageByIndex' => [
            'image/*',
        ],
        'updateItemImageIndex' => [
            'application/json',
        ],
        'uploadCustomSplashscreen' => [
            'image/*',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation deleteCustomSplashscreen
     *
     * Delete a custom splashscreen.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCustomSplashscreen'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCustomSplashscreen(string $contentType = self::contentTypes['deleteCustomSplashscreen'][0])
    {
        $this->deleteCustomSplashscreenWithHttpInfo($contentType);
    }

    /**
     * Operation deleteCustomSplashscreenWithHttpInfo
     *
     * Delete a custom splashscreen.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCustomSplashscreen'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCustomSplashscreenWithHttpInfo(string $contentType = self::contentTypes['deleteCustomSplashscreen'][0])
    {
        $request = $this->deleteCustomSplashscreenRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCustomSplashscreenAsync
     *
     * Delete a custom splashscreen.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCustomSplashscreen'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCustomSplashscreenAsync(string $contentType = self::contentTypes['deleteCustomSplashscreen'][0])
    {
        return $this->deleteCustomSplashscreenAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCustomSplashscreenAsyncWithHttpInfo
     *
     * Delete a custom splashscreen.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCustomSplashscreen'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCustomSplashscreenAsyncWithHttpInfo(string $contentType = self::contentTypes['deleteCustomSplashscreen'][0])
    {
        $returnType = '';
        $request = $this->deleteCustomSplashscreenRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCustomSplashscreen'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCustomSplashscreen'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteCustomSplashscreenRequest(string $contentType = self::contentTypes['deleteCustomSplashscreen'][0])
    {


        $resourcePath = '/Branding/Splashscreen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteItemImage
     *
     * Delete an item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index The image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteItemImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteItemImage($item_id, $image_type, $image_index = null, string $contentType = self::contentTypes['deleteItemImage'][0])
    {
        $this->deleteItemImageWithHttpInfo($item_id, $image_type, $image_index, $contentType);
    }

    /**
     * Operation deleteItemImageWithHttpInfo
     *
     * Delete an item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index The image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteItemImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteItemImageWithHttpInfo($item_id, $image_type, $image_index = null, string $contentType = self::contentTypes['deleteItemImage'][0])
    {
        $request = $this->deleteItemImageRequest($item_id, $image_type, $image_index, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteItemImageAsync
     *
     * Delete an item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index The image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteItemImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteItemImageAsync($item_id, $image_type, $image_index = null, string $contentType = self::contentTypes['deleteItemImage'][0])
    {
        return $this->deleteItemImageAsyncWithHttpInfo($item_id, $image_type, $image_index, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteItemImageAsyncWithHttpInfo
     *
     * Delete an item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index The image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteItemImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteItemImageAsyncWithHttpInfo($item_id, $image_type, $image_index = null, string $contentType = self::contentTypes['deleteItemImage'][0])
    {
        $returnType = '';
        $request = $this->deleteItemImageRequest($item_id, $image_type, $image_index, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteItemImage'
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index The image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteItemImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteItemImageRequest($item_id, $image_type, $image_index = null, string $contentType = self::contentTypes['deleteItemImage'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling deleteItemImage'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling deleteItemImage'
            );
        }



        $resourcePath = '/Items/{itemId}/Images/{imageType}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_index,
            'imageIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteItemImageByIndex
     *
     * Delete an item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index The image index. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteItemImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteItemImageByIndex($item_id, $image_type, $image_index, string $contentType = self::contentTypes['deleteItemImageByIndex'][0])
    {
        $this->deleteItemImageByIndexWithHttpInfo($item_id, $image_type, $image_index, $contentType);
    }

    /**
     * Operation deleteItemImageByIndexWithHttpInfo
     *
     * Delete an item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index The image index. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteItemImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteItemImageByIndexWithHttpInfo($item_id, $image_type, $image_index, string $contentType = self::contentTypes['deleteItemImageByIndex'][0])
    {
        $request = $this->deleteItemImageByIndexRequest($item_id, $image_type, $image_index, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteItemImageByIndexAsync
     *
     * Delete an item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index The image index. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteItemImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteItemImageByIndexAsync($item_id, $image_type, $image_index, string $contentType = self::contentTypes['deleteItemImageByIndex'][0])
    {
        return $this->deleteItemImageByIndexAsyncWithHttpInfo($item_id, $image_type, $image_index, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteItemImageByIndexAsyncWithHttpInfo
     *
     * Delete an item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index The image index. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteItemImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteItemImageByIndexAsyncWithHttpInfo($item_id, $image_type, $image_index, string $contentType = self::contentTypes['deleteItemImageByIndex'][0])
    {
        $returnType = '';
        $request = $this->deleteItemImageByIndexRequest($item_id, $image_type, $image_index, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteItemImageByIndex'
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index The image index. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteItemImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteItemImageByIndexRequest($item_id, $image_type, $image_index, string $contentType = self::contentTypes['deleteItemImageByIndex'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling deleteItemImageByIndex'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling deleteItemImageByIndex'
            );
        }

        // verify the required parameter 'image_index' is set
        if ($image_index === null || (is_array($image_index) && count($image_index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_index when calling deleteItemImageByIndex'
            );
        }


        $resourcePath = '/Items/{itemId}/Images/{imageType}/{imageIndex}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }
        // path params
        if ($image_index !== null) {
            $resourcePath = str_replace(
                '{' . 'imageIndex' . '}',
                ObjectSerializer::toPathValue($image_index),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteUserImage
     *
     * Delete the user&#39;s image.
     *
     * @param  string $user_id User Id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type (Unused) Image type. (required)
     * @param  int $index (Unused) Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteUserImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteUserImage($user_id, $image_type, $index = null, string $contentType = self::contentTypes['deleteUserImage'][0])
    {
        $this->deleteUserImageWithHttpInfo($user_id, $image_type, $index, $contentType);
    }

    /**
     * Operation deleteUserImageWithHttpInfo
     *
     * Delete the user&#39;s image.
     *
     * @param  string $user_id User Id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type (Unused) Image type. (required)
     * @param  int $index (Unused) Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteUserImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteUserImageWithHttpInfo($user_id, $image_type, $index = null, string $contentType = self::contentTypes['deleteUserImage'][0])
    {
        $request = $this->deleteUserImageRequest($user_id, $image_type, $index, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteUserImageAsync
     *
     * Delete the user&#39;s image.
     *
     * @param  string $user_id User Id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type (Unused) Image type. (required)
     * @param  int $index (Unused) Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteUserImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteUserImageAsync($user_id, $image_type, $index = null, string $contentType = self::contentTypes['deleteUserImage'][0])
    {
        return $this->deleteUserImageAsyncWithHttpInfo($user_id, $image_type, $index, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteUserImageAsyncWithHttpInfo
     *
     * Delete the user&#39;s image.
     *
     * @param  string $user_id User Id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type (Unused) Image type. (required)
     * @param  int $index (Unused) Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteUserImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteUserImageAsyncWithHttpInfo($user_id, $image_type, $index = null, string $contentType = self::contentTypes['deleteUserImage'][0])
    {
        $returnType = '';
        $request = $this->deleteUserImageRequest($user_id, $image_type, $index, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteUserImage'
     *
     * @param  string $user_id User Id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type (Unused) Image type. (required)
     * @param  int $index (Unused) Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteUserImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteUserImageRequest($user_id, $image_type, $index = null, string $contentType = self::contentTypes['deleteUserImage'][0])
    {

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling deleteUserImage'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling deleteUserImage'
            );
        }



        $resourcePath = '/Users/{userId}/Images/{imageType}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $index,
            'index', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteUserImageByIndex
     *
     * Delete the user&#39;s image.
     *
     * @param  string $user_id User Id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type (Unused) Image type. (required)
     * @param  int $index (Unused) Image index. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteUserImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteUserImageByIndex($user_id, $image_type, $index, string $contentType = self::contentTypes['deleteUserImageByIndex'][0])
    {
        $this->deleteUserImageByIndexWithHttpInfo($user_id, $image_type, $index, $contentType);
    }

    /**
     * Operation deleteUserImageByIndexWithHttpInfo
     *
     * Delete the user&#39;s image.
     *
     * @param  string $user_id User Id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type (Unused) Image type. (required)
     * @param  int $index (Unused) Image index. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteUserImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteUserImageByIndexWithHttpInfo($user_id, $image_type, $index, string $contentType = self::contentTypes['deleteUserImageByIndex'][0])
    {
        $request = $this->deleteUserImageByIndexRequest($user_id, $image_type, $index, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteUserImageByIndexAsync
     *
     * Delete the user&#39;s image.
     *
     * @param  string $user_id User Id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type (Unused) Image type. (required)
     * @param  int $index (Unused) Image index. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteUserImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteUserImageByIndexAsync($user_id, $image_type, $index, string $contentType = self::contentTypes['deleteUserImageByIndex'][0])
    {
        return $this->deleteUserImageByIndexAsyncWithHttpInfo($user_id, $image_type, $index, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteUserImageByIndexAsyncWithHttpInfo
     *
     * Delete the user&#39;s image.
     *
     * @param  string $user_id User Id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type (Unused) Image type. (required)
     * @param  int $index (Unused) Image index. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteUserImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteUserImageByIndexAsyncWithHttpInfo($user_id, $image_type, $index, string $contentType = self::contentTypes['deleteUserImageByIndex'][0])
    {
        $returnType = '';
        $request = $this->deleteUserImageByIndexRequest($user_id, $image_type, $index, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteUserImageByIndex'
     *
     * @param  string $user_id User Id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type (Unused) Image type. (required)
     * @param  int $index (Unused) Image index. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteUserImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteUserImageByIndexRequest($user_id, $image_type, $index, string $contentType = self::contentTypes['deleteUserImageByIndex'][0])
    {

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling deleteUserImageByIndex'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling deleteUserImageByIndex'
            );
        }

        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling deleteUserImageByIndex'
            );
        }


        $resourcePath = '/Users/{userId}/Images/{imageType}/{index}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArtistImage
     *
     * Get artist image by name.
     *
     * @param  string $name Artist name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getArtistImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function getArtistImage($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getArtistImage'][0])
    {
        list($response) = $this->getArtistImageWithHttpInfo($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);
        return $response;
    }

    /**
     * Operation getArtistImageWithHttpInfo
     *
     * Get artist image by name.
     *
     * @param  string $name Artist name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getArtistImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArtistImageWithHttpInfo($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getArtistImage'][0])
    {
        $request = $this->getArtistImageRequest($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArtistImageAsync
     *
     * Get artist image by name.
     *
     * @param  string $name Artist name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getArtistImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArtistImageAsync($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getArtistImage'][0])
    {
        return $this->getArtistImageAsyncWithHttpInfo($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArtistImageAsyncWithHttpInfo
     *
     * Get artist image by name.
     *
     * @param  string $name Artist name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getArtistImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArtistImageAsyncWithHttpInfo($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getArtistImage'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getArtistImageRequest($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArtistImage'
     *
     * @param  string $name Artist name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getArtistImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getArtistImageRequest($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getArtistImage'][0])
    {

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getArtistImage'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling getArtistImage'
            );
        }

        // verify the required parameter 'image_index' is set
        if ($image_index === null || (is_array($image_index) && count($image_index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_index when calling getArtistImage'
            );
        }


















        $resourcePath = '/Artists/{name}/Images/{imageType}/{imageIndex}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ImageFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $percent_played,
            'percentPlayed', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unplayed_count,
            'unplayedCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }
        // path params
        if ($image_index !== null) {
            $resourcePath = str_replace(
                '{' . 'imageIndex' . '}',
                ObjectSerializer::toPathValue($image_index),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGenreImage
     *
     * Get genre image by name.
     *
     * @param  string $name Genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGenreImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function getGenreImage($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getGenreImage'][0])
    {
        list($response) = $this->getGenreImageWithHttpInfo($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);
        return $response;
    }

    /**
     * Operation getGenreImageWithHttpInfo
     *
     * Get genre image by name.
     *
     * @param  string $name Genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGenreImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGenreImageWithHttpInfo($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getGenreImage'][0])
    {
        $request = $this->getGenreImageRequest($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGenreImageAsync
     *
     * Get genre image by name.
     *
     * @param  string $name Genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGenreImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGenreImageAsync($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getGenreImage'][0])
    {
        return $this->getGenreImageAsyncWithHttpInfo($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGenreImageAsyncWithHttpInfo
     *
     * Get genre image by name.
     *
     * @param  string $name Genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGenreImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGenreImageAsyncWithHttpInfo($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getGenreImage'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getGenreImageRequest($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGenreImage'
     *
     * @param  string $name Genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGenreImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGenreImageRequest($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getGenreImage'][0])
    {

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getGenreImage'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling getGenreImage'
            );
        }



















        $resourcePath = '/Genres/{name}/Images/{imageType}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ImageFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $percent_played,
            'percentPlayed', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unplayed_count,
            'unplayedCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_index,
            'imageIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGenreImageByIndex
     *
     * Get genre image by name.
     *
     * @param  string $name Genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGenreImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function getGenreImageByIndex($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getGenreImageByIndex'][0])
    {
        list($response) = $this->getGenreImageByIndexWithHttpInfo($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);
        return $response;
    }

    /**
     * Operation getGenreImageByIndexWithHttpInfo
     *
     * Get genre image by name.
     *
     * @param  string $name Genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGenreImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGenreImageByIndexWithHttpInfo($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getGenreImageByIndex'][0])
    {
        $request = $this->getGenreImageByIndexRequest($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGenreImageByIndexAsync
     *
     * Get genre image by name.
     *
     * @param  string $name Genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGenreImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGenreImageByIndexAsync($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getGenreImageByIndex'][0])
    {
        return $this->getGenreImageByIndexAsyncWithHttpInfo($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGenreImageByIndexAsyncWithHttpInfo
     *
     * Get genre image by name.
     *
     * @param  string $name Genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGenreImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGenreImageByIndexAsyncWithHttpInfo($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getGenreImageByIndex'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getGenreImageByIndexRequest($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGenreImageByIndex'
     *
     * @param  string $name Genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGenreImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGenreImageByIndexRequest($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getGenreImageByIndex'][0])
    {

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getGenreImageByIndex'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling getGenreImageByIndex'
            );
        }

        // verify the required parameter 'image_index' is set
        if ($image_index === null || (is_array($image_index) && count($image_index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_index when calling getGenreImageByIndex'
            );
        }


















        $resourcePath = '/Genres/{name}/Images/{imageType}/{imageIndex}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ImageFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $percent_played,
            'percentPlayed', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unplayed_count,
            'unplayedCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }
        // path params
        if ($image_index !== null) {
            $resourcePath = str_replace(
                '{' . 'imageIndex' . '}',
                ObjectSerializer::toPathValue($image_index),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getItemImage
     *
     * Gets the item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image. (optional)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getItemImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function getItemImage($item_id, $image_type, $max_width = null, $max_height = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $tag = null, $crop_whitespace = null, $format = null, $add_played_indicator = null, $percent_played = null, $unplayed_count = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getItemImage'][0])
    {
        list($response) = $this->getItemImageWithHttpInfo($item_id, $image_type, $max_width, $max_height, $width, $height, $quality, $fill_width, $fill_height, $tag, $crop_whitespace, $format, $add_played_indicator, $percent_played, $unplayed_count, $blur, $background_color, $foreground_layer, $image_index, $contentType);
        return $response;
    }

    /**
     * Operation getItemImageWithHttpInfo
     *
     * Gets the item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image. (optional)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getItemImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function getItemImageWithHttpInfo($item_id, $image_type, $max_width = null, $max_height = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $tag = null, $crop_whitespace = null, $format = null, $add_played_indicator = null, $percent_played = null, $unplayed_count = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getItemImage'][0])
    {
        $request = $this->getItemImageRequest($item_id, $image_type, $max_width, $max_height, $width, $height, $quality, $fill_width, $fill_height, $tag, $crop_whitespace, $format, $add_played_indicator, $percent_played, $unplayed_count, $blur, $background_color, $foreground_layer, $image_index, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getItemImageAsync
     *
     * Gets the item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image. (optional)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getItemImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getItemImageAsync($item_id, $image_type, $max_width = null, $max_height = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $tag = null, $crop_whitespace = null, $format = null, $add_played_indicator = null, $percent_played = null, $unplayed_count = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getItemImage'][0])
    {
        return $this->getItemImageAsyncWithHttpInfo($item_id, $image_type, $max_width, $max_height, $width, $height, $quality, $fill_width, $fill_height, $tag, $crop_whitespace, $format, $add_played_indicator, $percent_played, $unplayed_count, $blur, $background_color, $foreground_layer, $image_index, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getItemImageAsyncWithHttpInfo
     *
     * Gets the item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image. (optional)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getItemImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getItemImageAsyncWithHttpInfo($item_id, $image_type, $max_width = null, $max_height = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $tag = null, $crop_whitespace = null, $format = null, $add_played_indicator = null, $percent_played = null, $unplayed_count = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getItemImage'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getItemImageRequest($item_id, $image_type, $max_width, $max_height, $width, $height, $quality, $fill_width, $fill_height, $tag, $crop_whitespace, $format, $add_played_indicator, $percent_played, $unplayed_count, $blur, $background_color, $foreground_layer, $image_index, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getItemImage'
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image. (optional)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getItemImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getItemImageRequest($item_id, $image_type, $max_width = null, $max_height = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $tag = null, $crop_whitespace = null, $format = null, $add_played_indicator = null, $percent_played = null, $unplayed_count = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getItemImage'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling getItemImage'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling getItemImage'
            );
        }



















        $resourcePath = '/Items/{itemId}/Images/{imageType}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ImageFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $percent_played,
            'percentPlayed', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unplayed_count,
            'unplayedCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_index,
            'imageIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getItemImage2
     *
     * Gets the item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $max_width The maximum image width to return. (required)
     * @param  int $max_height The maximum image height to return. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (required)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (required)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (required)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (required)
     * @param  int $image_index Image index. (required)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getItemImage2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function getItemImage2($item_id, $image_type, $max_width, $max_height, $tag, $format, $percent_played, $unplayed_count, $image_index, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getItemImage2'][0])
    {
        list($response) = $this->getItemImage2WithHttpInfo($item_id, $image_type, $max_width, $max_height, $tag, $format, $percent_played, $unplayed_count, $image_index, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);
        return $response;
    }

    /**
     * Operation getItemImage2WithHttpInfo
     *
     * Gets the item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $max_width The maximum image width to return. (required)
     * @param  int $max_height The maximum image height to return. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (required)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (required)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (required)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (required)
     * @param  int $image_index Image index. (required)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getItemImage2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function getItemImage2WithHttpInfo($item_id, $image_type, $max_width, $max_height, $tag, $format, $percent_played, $unplayed_count, $image_index, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getItemImage2'][0])
    {
        $request = $this->getItemImage2Request($item_id, $image_type, $max_width, $max_height, $tag, $format, $percent_played, $unplayed_count, $image_index, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getItemImage2Async
     *
     * Gets the item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $max_width The maximum image width to return. (required)
     * @param  int $max_height The maximum image height to return. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (required)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (required)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (required)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (required)
     * @param  int $image_index Image index. (required)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getItemImage2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getItemImage2Async($item_id, $image_type, $max_width, $max_height, $tag, $format, $percent_played, $unplayed_count, $image_index, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getItemImage2'][0])
    {
        return $this->getItemImage2AsyncWithHttpInfo($item_id, $image_type, $max_width, $max_height, $tag, $format, $percent_played, $unplayed_count, $image_index, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getItemImage2AsyncWithHttpInfo
     *
     * Gets the item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $max_width The maximum image width to return. (required)
     * @param  int $max_height The maximum image height to return. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (required)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (required)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (required)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (required)
     * @param  int $image_index Image index. (required)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getItemImage2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getItemImage2AsyncWithHttpInfo($item_id, $image_type, $max_width, $max_height, $tag, $format, $percent_played, $unplayed_count, $image_index, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getItemImage2'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getItemImage2Request($item_id, $image_type, $max_width, $max_height, $tag, $format, $percent_played, $unplayed_count, $image_index, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getItemImage2'
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $max_width The maximum image width to return. (required)
     * @param  int $max_height The maximum image height to return. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (required)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (required)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (required)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (required)
     * @param  int $image_index Image index. (required)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getItemImage2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getItemImage2Request($item_id, $image_type, $max_width, $max_height, $tag, $format, $percent_played, $unplayed_count, $image_index, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getItemImage2'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling getItemImage2'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling getItemImage2'
            );
        }

        // verify the required parameter 'max_width' is set
        if ($max_width === null || (is_array($max_width) && count($max_width) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $max_width when calling getItemImage2'
            );
        }

        // verify the required parameter 'max_height' is set
        if ($max_height === null || (is_array($max_height) && count($max_height) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $max_height when calling getItemImage2'
            );
        }

        // verify the required parameter 'tag' is set
        if ($tag === null || (is_array($tag) && count($tag) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tag when calling getItemImage2'
            );
        }

        // verify the required parameter 'format' is set
        if ($format === null || (is_array($format) && count($format) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $format when calling getItemImage2'
            );
        }

        // verify the required parameter 'percent_played' is set
        if ($percent_played === null || (is_array($percent_played) && count($percent_played) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $percent_played when calling getItemImage2'
            );
        }

        // verify the required parameter 'unplayed_count' is set
        if ($unplayed_count === null || (is_array($unplayed_count) && count($unplayed_count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $unplayed_count when calling getItemImage2'
            );
        }

        // verify the required parameter 'image_index' is set
        if ($image_index === null || (is_array($image_index) && count($image_index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_index when calling getItemImage2'
            );
        }












        $resourcePath = '/Items/{itemId}/Images/{imageType}/{imageIndex}/{tag}/{format}/{maxWidth}/{maxHeight}/{percentPlayed}/{unplayedCount}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }
        // path params
        if ($max_width !== null) {
            $resourcePath = str_replace(
                '{' . 'maxWidth' . '}',
                ObjectSerializer::toPathValue($max_width),
                $resourcePath
            );
        }
        // path params
        if ($max_height !== null) {
            $resourcePath = str_replace(
                '{' . 'maxHeight' . '}',
                ObjectSerializer::toPathValue($max_height),
                $resourcePath
            );
        }
        // path params
        if ($tag !== null) {
            $resourcePath = str_replace(
                '{' . 'tag' . '}',
                ObjectSerializer::toPathValue($tag),
                $resourcePath
            );
        }
        // path params
        if ($format !== null) {
            $resourcePath = str_replace(
                '{' . 'format' . '}',
                ObjectSerializer::toPathValue($format),
                $resourcePath
            );
        }
        // path params
        if ($percent_played !== null) {
            $resourcePath = str_replace(
                '{' . 'percentPlayed' . '}',
                ObjectSerializer::toPathValue($percent_played),
                $resourcePath
            );
        }
        // path params
        if ($unplayed_count !== null) {
            $resourcePath = str_replace(
                '{' . 'unplayedCount' . '}',
                ObjectSerializer::toPathValue($unplayed_count),
                $resourcePath
            );
        }
        // path params
        if ($image_index !== null) {
            $resourcePath = str_replace(
                '{' . 'imageIndex' . '}',
                ObjectSerializer::toPathValue($image_index),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getItemImageByIndex
     *
     * Gets the item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image. (optional)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getItemImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function getItemImageByIndex($item_id, $image_type, $image_index, $max_width = null, $max_height = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $tag = null, $crop_whitespace = null, $format = null, $add_played_indicator = null, $percent_played = null, $unplayed_count = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getItemImageByIndex'][0])
    {
        list($response) = $this->getItemImageByIndexWithHttpInfo($item_id, $image_type, $image_index, $max_width, $max_height, $width, $height, $quality, $fill_width, $fill_height, $tag, $crop_whitespace, $format, $add_played_indicator, $percent_played, $unplayed_count, $blur, $background_color, $foreground_layer, $contentType);
        return $response;
    }

    /**
     * Operation getItemImageByIndexWithHttpInfo
     *
     * Gets the item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image. (optional)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getItemImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function getItemImageByIndexWithHttpInfo($item_id, $image_type, $image_index, $max_width = null, $max_height = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $tag = null, $crop_whitespace = null, $format = null, $add_played_indicator = null, $percent_played = null, $unplayed_count = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getItemImageByIndex'][0])
    {
        $request = $this->getItemImageByIndexRequest($item_id, $image_type, $image_index, $max_width, $max_height, $width, $height, $quality, $fill_width, $fill_height, $tag, $crop_whitespace, $format, $add_played_indicator, $percent_played, $unplayed_count, $blur, $background_color, $foreground_layer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getItemImageByIndexAsync
     *
     * Gets the item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image. (optional)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getItemImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getItemImageByIndexAsync($item_id, $image_type, $image_index, $max_width = null, $max_height = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $tag = null, $crop_whitespace = null, $format = null, $add_played_indicator = null, $percent_played = null, $unplayed_count = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getItemImageByIndex'][0])
    {
        return $this->getItemImageByIndexAsyncWithHttpInfo($item_id, $image_type, $image_index, $max_width, $max_height, $width, $height, $quality, $fill_width, $fill_height, $tag, $crop_whitespace, $format, $add_played_indicator, $percent_played, $unplayed_count, $blur, $background_color, $foreground_layer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getItemImageByIndexAsyncWithHttpInfo
     *
     * Gets the item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image. (optional)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getItemImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getItemImageByIndexAsyncWithHttpInfo($item_id, $image_type, $image_index, $max_width = null, $max_height = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $tag = null, $crop_whitespace = null, $format = null, $add_played_indicator = null, $percent_played = null, $unplayed_count = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getItemImageByIndex'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getItemImageByIndexRequest($item_id, $image_type, $image_index, $max_width, $max_height, $width, $height, $quality, $fill_width, $fill_height, $tag, $crop_whitespace, $format, $add_played_indicator, $percent_played, $unplayed_count, $blur, $background_color, $foreground_layer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getItemImageByIndex'
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image. (optional)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getItemImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getItemImageByIndexRequest($item_id, $image_type, $image_index, $max_width = null, $max_height = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $tag = null, $crop_whitespace = null, $format = null, $add_played_indicator = null, $percent_played = null, $unplayed_count = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getItemImageByIndex'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling getItemImageByIndex'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling getItemImageByIndex'
            );
        }

        // verify the required parameter 'image_index' is set
        if ($image_index === null || (is_array($image_index) && count($image_index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_index when calling getItemImageByIndex'
            );
        }


















        $resourcePath = '/Items/{itemId}/Images/{imageType}/{imageIndex}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ImageFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $percent_played,
            'percentPlayed', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unplayed_count,
            'unplayedCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }
        // path params
        if ($image_index !== null) {
            $resourcePath = str_replace(
                '{' . 'imageIndex' . '}',
                ObjectSerializer::toPathValue($image_index),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getItemImageInfos
     *
     * Get item image infos.
     *
     * @param  string $item_id Item id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getItemImageInfos'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ImageInfo[]|\OpenAPI\Client\Model\ProblemDetails
     */
    public function getItemImageInfos($item_id, string $contentType = self::contentTypes['getItemImageInfos'][0])
    {
        list($response) = $this->getItemImageInfosWithHttpInfo($item_id, $contentType);
        return $response;
    }

    /**
     * Operation getItemImageInfosWithHttpInfo
     *
     * Get item image infos.
     *
     * @param  string $item_id Item id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getItemImageInfos'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ImageInfo[]|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function getItemImageInfosWithHttpInfo($item_id, string $contentType = self::contentTypes['getItemImageInfos'][0])
    {
        $request = $this->getItemImageInfosRequest($item_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ImageInfo[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ImageInfo[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ImageInfo[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ImageInfo[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ImageInfo[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getItemImageInfosAsync
     *
     * Get item image infos.
     *
     * @param  string $item_id Item id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getItemImageInfos'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getItemImageInfosAsync($item_id, string $contentType = self::contentTypes['getItemImageInfos'][0])
    {
        return $this->getItemImageInfosAsyncWithHttpInfo($item_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getItemImageInfosAsyncWithHttpInfo
     *
     * Get item image infos.
     *
     * @param  string $item_id Item id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getItemImageInfos'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getItemImageInfosAsyncWithHttpInfo($item_id, string $contentType = self::contentTypes['getItemImageInfos'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ImageInfo[]';
        $request = $this->getItemImageInfosRequest($item_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getItemImageInfos'
     *
     * @param  string $item_id Item id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getItemImageInfos'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getItemImageInfosRequest($item_id, string $contentType = self::contentTypes['getItemImageInfos'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling getItemImageInfos'
            );
        }


        $resourcePath = '/Items/{itemId}/Images';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMusicGenreImage
     *
     * Get music genre image by name.
     *
     * @param  string $name Music genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMusicGenreImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function getMusicGenreImage($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getMusicGenreImage'][0])
    {
        list($response) = $this->getMusicGenreImageWithHttpInfo($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);
        return $response;
    }

    /**
     * Operation getMusicGenreImageWithHttpInfo
     *
     * Get music genre image by name.
     *
     * @param  string $name Music genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMusicGenreImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMusicGenreImageWithHttpInfo($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getMusicGenreImage'][0])
    {
        $request = $this->getMusicGenreImageRequest($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMusicGenreImageAsync
     *
     * Get music genre image by name.
     *
     * @param  string $name Music genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMusicGenreImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMusicGenreImageAsync($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getMusicGenreImage'][0])
    {
        return $this->getMusicGenreImageAsyncWithHttpInfo($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMusicGenreImageAsyncWithHttpInfo
     *
     * Get music genre image by name.
     *
     * @param  string $name Music genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMusicGenreImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMusicGenreImageAsyncWithHttpInfo($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getMusicGenreImage'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getMusicGenreImageRequest($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMusicGenreImage'
     *
     * @param  string $name Music genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMusicGenreImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMusicGenreImageRequest($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getMusicGenreImage'][0])
    {

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getMusicGenreImage'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling getMusicGenreImage'
            );
        }



















        $resourcePath = '/MusicGenres/{name}/Images/{imageType}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ImageFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $percent_played,
            'percentPlayed', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unplayed_count,
            'unplayedCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_index,
            'imageIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMusicGenreImageByIndex
     *
     * Get music genre image by name.
     *
     * @param  string $name Music genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMusicGenreImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function getMusicGenreImageByIndex($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getMusicGenreImageByIndex'][0])
    {
        list($response) = $this->getMusicGenreImageByIndexWithHttpInfo($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);
        return $response;
    }

    /**
     * Operation getMusicGenreImageByIndexWithHttpInfo
     *
     * Get music genre image by name.
     *
     * @param  string $name Music genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMusicGenreImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMusicGenreImageByIndexWithHttpInfo($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getMusicGenreImageByIndex'][0])
    {
        $request = $this->getMusicGenreImageByIndexRequest($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMusicGenreImageByIndexAsync
     *
     * Get music genre image by name.
     *
     * @param  string $name Music genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMusicGenreImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMusicGenreImageByIndexAsync($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getMusicGenreImageByIndex'][0])
    {
        return $this->getMusicGenreImageByIndexAsyncWithHttpInfo($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMusicGenreImageByIndexAsyncWithHttpInfo
     *
     * Get music genre image by name.
     *
     * @param  string $name Music genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMusicGenreImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMusicGenreImageByIndexAsyncWithHttpInfo($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getMusicGenreImageByIndex'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getMusicGenreImageByIndexRequest($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMusicGenreImageByIndex'
     *
     * @param  string $name Music genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMusicGenreImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMusicGenreImageByIndexRequest($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getMusicGenreImageByIndex'][0])
    {

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getMusicGenreImageByIndex'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling getMusicGenreImageByIndex'
            );
        }

        // verify the required parameter 'image_index' is set
        if ($image_index === null || (is_array($image_index) && count($image_index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_index when calling getMusicGenreImageByIndex'
            );
        }


















        $resourcePath = '/MusicGenres/{name}/Images/{imageType}/{imageIndex}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ImageFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $percent_played,
            'percentPlayed', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unplayed_count,
            'unplayedCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }
        // path params
        if ($image_index !== null) {
            $resourcePath = str_replace(
                '{' . 'imageIndex' . '}',
                ObjectSerializer::toPathValue($image_index),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPersonImage
     *
     * Get person image by name.
     *
     * @param  string $name Person name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPersonImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function getPersonImage($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getPersonImage'][0])
    {
        list($response) = $this->getPersonImageWithHttpInfo($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);
        return $response;
    }

    /**
     * Operation getPersonImageWithHttpInfo
     *
     * Get person image by name.
     *
     * @param  string $name Person name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPersonImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPersonImageWithHttpInfo($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getPersonImage'][0])
    {
        $request = $this->getPersonImageRequest($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPersonImageAsync
     *
     * Get person image by name.
     *
     * @param  string $name Person name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPersonImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonImageAsync($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getPersonImage'][0])
    {
        return $this->getPersonImageAsyncWithHttpInfo($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPersonImageAsyncWithHttpInfo
     *
     * Get person image by name.
     *
     * @param  string $name Person name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPersonImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonImageAsyncWithHttpInfo($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getPersonImage'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getPersonImageRequest($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPersonImage'
     *
     * @param  string $name Person name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPersonImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPersonImageRequest($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getPersonImage'][0])
    {

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPersonImage'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling getPersonImage'
            );
        }



















        $resourcePath = '/Persons/{name}/Images/{imageType}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ImageFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $percent_played,
            'percentPlayed', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unplayed_count,
            'unplayedCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_index,
            'imageIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPersonImageByIndex
     *
     * Get person image by name.
     *
     * @param  string $name Person name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPersonImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function getPersonImageByIndex($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getPersonImageByIndex'][0])
    {
        list($response) = $this->getPersonImageByIndexWithHttpInfo($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);
        return $response;
    }

    /**
     * Operation getPersonImageByIndexWithHttpInfo
     *
     * Get person image by name.
     *
     * @param  string $name Person name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPersonImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPersonImageByIndexWithHttpInfo($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getPersonImageByIndex'][0])
    {
        $request = $this->getPersonImageByIndexRequest($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPersonImageByIndexAsync
     *
     * Get person image by name.
     *
     * @param  string $name Person name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPersonImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonImageByIndexAsync($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getPersonImageByIndex'][0])
    {
        return $this->getPersonImageByIndexAsyncWithHttpInfo($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPersonImageByIndexAsyncWithHttpInfo
     *
     * Get person image by name.
     *
     * @param  string $name Person name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPersonImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonImageByIndexAsyncWithHttpInfo($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getPersonImageByIndex'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getPersonImageByIndexRequest($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPersonImageByIndex'
     *
     * @param  string $name Person name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPersonImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPersonImageByIndexRequest($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getPersonImageByIndex'][0])
    {

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getPersonImageByIndex'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling getPersonImageByIndex'
            );
        }

        // verify the required parameter 'image_index' is set
        if ($image_index === null || (is_array($image_index) && count($image_index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_index when calling getPersonImageByIndex'
            );
        }


















        $resourcePath = '/Persons/{name}/Images/{imageType}/{imageIndex}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ImageFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $percent_played,
            'percentPlayed', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unplayed_count,
            'unplayedCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }
        // path params
        if ($image_index !== null) {
            $resourcePath = str_replace(
                '{' . 'imageIndex' . '}',
                ObjectSerializer::toPathValue($image_index),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSplashscreen
     *
     * Generates or gets the splashscreen.
     *
     * @param  string $tag Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  int $blur Blur image. (optional)
     * @param  string $background_color Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Apply a foreground layer on top of the image. (optional)
     * @param  int $quality Quality setting, from 0-100. (optional, default to 90)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSplashscreen'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getSplashscreen($tag = null, $format = null, $max_width = null, $max_height = null, $width = null, $height = null, $fill_width = null, $fill_height = null, $blur = null, $background_color = null, $foreground_layer = null, $quality = 90, string $contentType = self::contentTypes['getSplashscreen'][0])
    {
        list($response) = $this->getSplashscreenWithHttpInfo($tag, $format, $max_width, $max_height, $width, $height, $fill_width, $fill_height, $blur, $background_color, $foreground_layer, $quality, $contentType);
        return $response;
    }

    /**
     * Operation getSplashscreenWithHttpInfo
     *
     * Generates or gets the splashscreen.
     *
     * @param  string $tag Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  int $blur Blur image. (optional)
     * @param  string $background_color Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Apply a foreground layer on top of the image. (optional)
     * @param  int $quality Quality setting, from 0-100. (optional, default to 90)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSplashscreen'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSplashscreenWithHttpInfo($tag = null, $format = null, $max_width = null, $max_height = null, $width = null, $height = null, $fill_width = null, $fill_height = null, $blur = null, $background_color = null, $foreground_layer = null, $quality = 90, string $contentType = self::contentTypes['getSplashscreen'][0])
    {
        $request = $this->getSplashscreenRequest($tag, $format, $max_width, $max_height, $width, $height, $fill_width, $fill_height, $blur, $background_color, $foreground_layer, $quality, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSplashscreenAsync
     *
     * Generates or gets the splashscreen.
     *
     * @param  string $tag Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  int $blur Blur image. (optional)
     * @param  string $background_color Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Apply a foreground layer on top of the image. (optional)
     * @param  int $quality Quality setting, from 0-100. (optional, default to 90)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSplashscreen'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSplashscreenAsync($tag = null, $format = null, $max_width = null, $max_height = null, $width = null, $height = null, $fill_width = null, $fill_height = null, $blur = null, $background_color = null, $foreground_layer = null, $quality = 90, string $contentType = self::contentTypes['getSplashscreen'][0])
    {
        return $this->getSplashscreenAsyncWithHttpInfo($tag, $format, $max_width, $max_height, $width, $height, $fill_width, $fill_height, $blur, $background_color, $foreground_layer, $quality, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSplashscreenAsyncWithHttpInfo
     *
     * Generates or gets the splashscreen.
     *
     * @param  string $tag Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  int $blur Blur image. (optional)
     * @param  string $background_color Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Apply a foreground layer on top of the image. (optional)
     * @param  int $quality Quality setting, from 0-100. (optional, default to 90)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSplashscreen'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSplashscreenAsyncWithHttpInfo($tag = null, $format = null, $max_width = null, $max_height = null, $width = null, $height = null, $fill_width = null, $fill_height = null, $blur = null, $background_color = null, $foreground_layer = null, $quality = 90, string $contentType = self::contentTypes['getSplashscreen'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getSplashscreenRequest($tag, $format, $max_width, $max_height, $width, $height, $fill_width, $fill_height, $blur, $background_color, $foreground_layer, $quality, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSplashscreen'
     *
     * @param  string $tag Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  int $blur Blur image. (optional)
     * @param  string $background_color Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Apply a foreground layer on top of the image. (optional)
     * @param  int $quality Quality setting, from 0-100. (optional, default to 90)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSplashscreen'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSplashscreenRequest($tag = null, $format = null, $max_width = null, $max_height = null, $width = null, $height = null, $fill_width = null, $fill_height = null, $blur = null, $background_color = null, $foreground_layer = null, $quality = 90, string $contentType = self::contentTypes['getSplashscreen'][0])
    {












        if ($quality !== null && $quality > 100) {
            throw new \InvalidArgumentException('invalid value for "$quality" when calling ImageApi.getSplashscreen, must be smaller than or equal to 100.');
        }
        if ($quality !== null && $quality < 0) {
            throw new \InvalidArgumentException('invalid value for "$quality" when calling ImageApi.getSplashscreen, must be bigger than or equal to 0.');
        }
        

        $resourcePath = '/Branding/Splashscreen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ImageFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['image/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStudioImage
     *
     * Get studio image by name.
     *
     * @param  string $name Studio name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStudioImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function getStudioImage($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getStudioImage'][0])
    {
        list($response) = $this->getStudioImageWithHttpInfo($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);
        return $response;
    }

    /**
     * Operation getStudioImageWithHttpInfo
     *
     * Get studio image by name.
     *
     * @param  string $name Studio name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStudioImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStudioImageWithHttpInfo($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getStudioImage'][0])
    {
        $request = $this->getStudioImageRequest($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStudioImageAsync
     *
     * Get studio image by name.
     *
     * @param  string $name Studio name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStudioImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStudioImageAsync($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getStudioImage'][0])
    {
        return $this->getStudioImageAsyncWithHttpInfo($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStudioImageAsyncWithHttpInfo
     *
     * Get studio image by name.
     *
     * @param  string $name Studio name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStudioImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStudioImageAsyncWithHttpInfo($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getStudioImage'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getStudioImageRequest($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStudioImage'
     *
     * @param  string $name Studio name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStudioImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getStudioImageRequest($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getStudioImage'][0])
    {

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getStudioImage'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling getStudioImage'
            );
        }



















        $resourcePath = '/Studios/{name}/Images/{imageType}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ImageFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $percent_played,
            'percentPlayed', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unplayed_count,
            'unplayedCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_index,
            'imageIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStudioImageByIndex
     *
     * Get studio image by name.
     *
     * @param  string $name Studio name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStudioImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function getStudioImageByIndex($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getStudioImageByIndex'][0])
    {
        list($response) = $this->getStudioImageByIndexWithHttpInfo($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);
        return $response;
    }

    /**
     * Operation getStudioImageByIndexWithHttpInfo
     *
     * Get studio image by name.
     *
     * @param  string $name Studio name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStudioImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStudioImageByIndexWithHttpInfo($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getStudioImageByIndex'][0])
    {
        $request = $this->getStudioImageByIndexRequest($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStudioImageByIndexAsync
     *
     * Get studio image by name.
     *
     * @param  string $name Studio name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStudioImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStudioImageByIndexAsync($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getStudioImageByIndex'][0])
    {
        return $this->getStudioImageByIndexAsyncWithHttpInfo($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStudioImageByIndexAsyncWithHttpInfo
     *
     * Get studio image by name.
     *
     * @param  string $name Studio name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStudioImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStudioImageByIndexAsyncWithHttpInfo($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getStudioImageByIndex'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getStudioImageByIndexRequest($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStudioImageByIndex'
     *
     * @param  string $name Studio name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStudioImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getStudioImageByIndexRequest($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getStudioImageByIndex'][0])
    {

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getStudioImageByIndex'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling getStudioImageByIndex'
            );
        }

        // verify the required parameter 'image_index' is set
        if ($image_index === null || (is_array($image_index) && count($image_index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_index when calling getStudioImageByIndex'
            );
        }


















        $resourcePath = '/Studios/{name}/Images/{imageType}/{imageIndex}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ImageFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $percent_played,
            'percentPlayed', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unplayed_count,
            'unplayedCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }
        // path params
        if ($image_index !== null) {
            $resourcePath = str_replace(
                '{' . 'imageIndex' . '}',
                ObjectSerializer::toPathValue($image_index),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUserImage
     *
     * Get user profile image.
     *
     * @param  string $user_id User id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function getUserImage($user_id, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getUserImage'][0])
    {
        list($response) = $this->getUserImageWithHttpInfo($user_id, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);
        return $response;
    }

    /**
     * Operation getUserImageWithHttpInfo
     *
     * Get user profile image.
     *
     * @param  string $user_id User id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserImageWithHttpInfo($user_id, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getUserImage'][0])
    {
        $request = $this->getUserImageRequest($user_id, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getUserImageAsync
     *
     * Get user profile image.
     *
     * @param  string $user_id User id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserImageAsync($user_id, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getUserImage'][0])
    {
        return $this->getUserImageAsyncWithHttpInfo($user_id, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserImageAsyncWithHttpInfo
     *
     * Get user profile image.
     *
     * @param  string $user_id User id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserImageAsyncWithHttpInfo($user_id, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getUserImage'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getUserImageRequest($user_id, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUserImage'
     *
     * @param  string $user_id User id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getUserImageRequest($user_id, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['getUserImage'][0])
    {

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling getUserImage'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling getUserImage'
            );
        }



















        $resourcePath = '/Users/{userId}/Images/{imageType}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ImageFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $percent_played,
            'percentPlayed', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unplayed_count,
            'unplayedCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_index,
            'imageIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUserImageByIndex
     *
     * Get user profile image.
     *
     * @param  string $user_id User id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function getUserImageByIndex($user_id, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getUserImageByIndex'][0])
    {
        list($response) = $this->getUserImageByIndexWithHttpInfo($user_id, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);
        return $response;
    }

    /**
     * Operation getUserImageByIndexWithHttpInfo
     *
     * Get user profile image.
     *
     * @param  string $user_id User id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserImageByIndexWithHttpInfo($user_id, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getUserImageByIndex'][0])
    {
        $request = $this->getUserImageByIndexRequest($user_id, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getUserImageByIndexAsync
     *
     * Get user profile image.
     *
     * @param  string $user_id User id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserImageByIndexAsync($user_id, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getUserImageByIndex'][0])
    {
        return $this->getUserImageByIndexAsyncWithHttpInfo($user_id, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserImageByIndexAsyncWithHttpInfo
     *
     * Get user profile image.
     *
     * @param  string $user_id User id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserImageByIndexAsyncWithHttpInfo($user_id, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getUserImageByIndex'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getUserImageByIndexRequest($user_id, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUserImageByIndex'
     *
     * @param  string $user_id User id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getUserImageByIndexRequest($user_id, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['getUserImageByIndex'][0])
    {

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling getUserImageByIndex'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling getUserImageByIndex'
            );
        }

        // verify the required parameter 'image_index' is set
        if ($image_index === null || (is_array($image_index) && count($image_index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_index when calling getUserImageByIndex'
            );
        }


















        $resourcePath = '/Users/{userId}/Images/{imageType}/{imageIndex}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ImageFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $percent_played,
            'percentPlayed', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unplayed_count,
            'unplayedCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }
        // path params
        if ($image_index !== null) {
            $resourcePath = str_replace(
                '{' . 'imageIndex' . '}',
                ObjectSerializer::toPathValue($image_index),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation headArtistImage
     *
     * Get artist image by name.
     *
     * @param  string $name Artist name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headArtistImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function headArtistImage($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headArtistImage'][0])
    {
        list($response) = $this->headArtistImageWithHttpInfo($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);
        return $response;
    }

    /**
     * Operation headArtistImageWithHttpInfo
     *
     * Get artist image by name.
     *
     * @param  string $name Artist name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headArtistImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function headArtistImageWithHttpInfo($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headArtistImage'][0])
    {
        $request = $this->headArtistImageRequest($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation headArtistImageAsync
     *
     * Get artist image by name.
     *
     * @param  string $name Artist name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headArtistImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headArtistImageAsync($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headArtistImage'][0])
    {
        return $this->headArtistImageAsyncWithHttpInfo($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation headArtistImageAsyncWithHttpInfo
     *
     * Get artist image by name.
     *
     * @param  string $name Artist name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headArtistImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headArtistImageAsyncWithHttpInfo($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headArtistImage'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->headArtistImageRequest($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'headArtistImage'
     *
     * @param  string $name Artist name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headArtistImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function headArtistImageRequest($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headArtistImage'][0])
    {

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling headArtistImage'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling headArtistImage'
            );
        }

        // verify the required parameter 'image_index' is set
        if ($image_index === null || (is_array($image_index) && count($image_index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_index when calling headArtistImage'
            );
        }


















        $resourcePath = '/Artists/{name}/Images/{imageType}/{imageIndex}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ImageFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $percent_played,
            'percentPlayed', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unplayed_count,
            'unplayedCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }
        // path params
        if ($image_index !== null) {
            $resourcePath = str_replace(
                '{' . 'imageIndex' . '}',
                ObjectSerializer::toPathValue($image_index),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'HEAD',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation headGenreImage
     *
     * Get genre image by name.
     *
     * @param  string $name Genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headGenreImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function headGenreImage($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headGenreImage'][0])
    {
        list($response) = $this->headGenreImageWithHttpInfo($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);
        return $response;
    }

    /**
     * Operation headGenreImageWithHttpInfo
     *
     * Get genre image by name.
     *
     * @param  string $name Genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headGenreImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function headGenreImageWithHttpInfo($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headGenreImage'][0])
    {
        $request = $this->headGenreImageRequest($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation headGenreImageAsync
     *
     * Get genre image by name.
     *
     * @param  string $name Genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headGenreImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headGenreImageAsync($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headGenreImage'][0])
    {
        return $this->headGenreImageAsyncWithHttpInfo($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation headGenreImageAsyncWithHttpInfo
     *
     * Get genre image by name.
     *
     * @param  string $name Genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headGenreImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headGenreImageAsyncWithHttpInfo($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headGenreImage'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->headGenreImageRequest($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'headGenreImage'
     *
     * @param  string $name Genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headGenreImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function headGenreImageRequest($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headGenreImage'][0])
    {

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling headGenreImage'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling headGenreImage'
            );
        }



















        $resourcePath = '/Genres/{name}/Images/{imageType}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ImageFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $percent_played,
            'percentPlayed', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unplayed_count,
            'unplayedCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_index,
            'imageIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'HEAD',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation headGenreImageByIndex
     *
     * Get genre image by name.
     *
     * @param  string $name Genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headGenreImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function headGenreImageByIndex($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headGenreImageByIndex'][0])
    {
        list($response) = $this->headGenreImageByIndexWithHttpInfo($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);
        return $response;
    }

    /**
     * Operation headGenreImageByIndexWithHttpInfo
     *
     * Get genre image by name.
     *
     * @param  string $name Genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headGenreImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function headGenreImageByIndexWithHttpInfo($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headGenreImageByIndex'][0])
    {
        $request = $this->headGenreImageByIndexRequest($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation headGenreImageByIndexAsync
     *
     * Get genre image by name.
     *
     * @param  string $name Genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headGenreImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headGenreImageByIndexAsync($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headGenreImageByIndex'][0])
    {
        return $this->headGenreImageByIndexAsyncWithHttpInfo($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation headGenreImageByIndexAsyncWithHttpInfo
     *
     * Get genre image by name.
     *
     * @param  string $name Genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headGenreImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headGenreImageByIndexAsyncWithHttpInfo($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headGenreImageByIndex'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->headGenreImageByIndexRequest($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'headGenreImageByIndex'
     *
     * @param  string $name Genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headGenreImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function headGenreImageByIndexRequest($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headGenreImageByIndex'][0])
    {

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling headGenreImageByIndex'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling headGenreImageByIndex'
            );
        }

        // verify the required parameter 'image_index' is set
        if ($image_index === null || (is_array($image_index) && count($image_index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_index when calling headGenreImageByIndex'
            );
        }


















        $resourcePath = '/Genres/{name}/Images/{imageType}/{imageIndex}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ImageFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $percent_played,
            'percentPlayed', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unplayed_count,
            'unplayedCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }
        // path params
        if ($image_index !== null) {
            $resourcePath = str_replace(
                '{' . 'imageIndex' . '}',
                ObjectSerializer::toPathValue($image_index),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'HEAD',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation headItemImage
     *
     * Gets the item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image. (optional)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headItemImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function headItemImage($item_id, $image_type, $max_width = null, $max_height = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $tag = null, $crop_whitespace = null, $format = null, $add_played_indicator = null, $percent_played = null, $unplayed_count = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headItemImage'][0])
    {
        list($response) = $this->headItemImageWithHttpInfo($item_id, $image_type, $max_width, $max_height, $width, $height, $quality, $fill_width, $fill_height, $tag, $crop_whitespace, $format, $add_played_indicator, $percent_played, $unplayed_count, $blur, $background_color, $foreground_layer, $image_index, $contentType);
        return $response;
    }

    /**
     * Operation headItemImageWithHttpInfo
     *
     * Gets the item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image. (optional)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headItemImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function headItemImageWithHttpInfo($item_id, $image_type, $max_width = null, $max_height = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $tag = null, $crop_whitespace = null, $format = null, $add_played_indicator = null, $percent_played = null, $unplayed_count = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headItemImage'][0])
    {
        $request = $this->headItemImageRequest($item_id, $image_type, $max_width, $max_height, $width, $height, $quality, $fill_width, $fill_height, $tag, $crop_whitespace, $format, $add_played_indicator, $percent_played, $unplayed_count, $blur, $background_color, $foreground_layer, $image_index, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation headItemImageAsync
     *
     * Gets the item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image. (optional)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headItemImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headItemImageAsync($item_id, $image_type, $max_width = null, $max_height = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $tag = null, $crop_whitespace = null, $format = null, $add_played_indicator = null, $percent_played = null, $unplayed_count = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headItemImage'][0])
    {
        return $this->headItemImageAsyncWithHttpInfo($item_id, $image_type, $max_width, $max_height, $width, $height, $quality, $fill_width, $fill_height, $tag, $crop_whitespace, $format, $add_played_indicator, $percent_played, $unplayed_count, $blur, $background_color, $foreground_layer, $image_index, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation headItemImageAsyncWithHttpInfo
     *
     * Gets the item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image. (optional)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headItemImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headItemImageAsyncWithHttpInfo($item_id, $image_type, $max_width = null, $max_height = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $tag = null, $crop_whitespace = null, $format = null, $add_played_indicator = null, $percent_played = null, $unplayed_count = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headItemImage'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->headItemImageRequest($item_id, $image_type, $max_width, $max_height, $width, $height, $quality, $fill_width, $fill_height, $tag, $crop_whitespace, $format, $add_played_indicator, $percent_played, $unplayed_count, $blur, $background_color, $foreground_layer, $image_index, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'headItemImage'
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image. (optional)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headItemImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function headItemImageRequest($item_id, $image_type, $max_width = null, $max_height = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $tag = null, $crop_whitespace = null, $format = null, $add_played_indicator = null, $percent_played = null, $unplayed_count = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headItemImage'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling headItemImage'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling headItemImage'
            );
        }



















        $resourcePath = '/Items/{itemId}/Images/{imageType}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ImageFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $percent_played,
            'percentPlayed', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unplayed_count,
            'unplayedCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_index,
            'imageIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'HEAD',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation headItemImage2
     *
     * Gets the item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $max_width The maximum image width to return. (required)
     * @param  int $max_height The maximum image height to return. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (required)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (required)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (required)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (required)
     * @param  int $image_index Image index. (required)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headItemImage2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function headItemImage2($item_id, $image_type, $max_width, $max_height, $tag, $format, $percent_played, $unplayed_count, $image_index, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headItemImage2'][0])
    {
        list($response) = $this->headItemImage2WithHttpInfo($item_id, $image_type, $max_width, $max_height, $tag, $format, $percent_played, $unplayed_count, $image_index, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);
        return $response;
    }

    /**
     * Operation headItemImage2WithHttpInfo
     *
     * Gets the item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $max_width The maximum image width to return. (required)
     * @param  int $max_height The maximum image height to return. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (required)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (required)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (required)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (required)
     * @param  int $image_index Image index. (required)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headItemImage2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function headItemImage2WithHttpInfo($item_id, $image_type, $max_width, $max_height, $tag, $format, $percent_played, $unplayed_count, $image_index, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headItemImage2'][0])
    {
        $request = $this->headItemImage2Request($item_id, $image_type, $max_width, $max_height, $tag, $format, $percent_played, $unplayed_count, $image_index, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation headItemImage2Async
     *
     * Gets the item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $max_width The maximum image width to return. (required)
     * @param  int $max_height The maximum image height to return. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (required)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (required)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (required)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (required)
     * @param  int $image_index Image index. (required)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headItemImage2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headItemImage2Async($item_id, $image_type, $max_width, $max_height, $tag, $format, $percent_played, $unplayed_count, $image_index, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headItemImage2'][0])
    {
        return $this->headItemImage2AsyncWithHttpInfo($item_id, $image_type, $max_width, $max_height, $tag, $format, $percent_played, $unplayed_count, $image_index, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation headItemImage2AsyncWithHttpInfo
     *
     * Gets the item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $max_width The maximum image width to return. (required)
     * @param  int $max_height The maximum image height to return. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (required)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (required)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (required)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (required)
     * @param  int $image_index Image index. (required)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headItemImage2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headItemImage2AsyncWithHttpInfo($item_id, $image_type, $max_width, $max_height, $tag, $format, $percent_played, $unplayed_count, $image_index, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headItemImage2'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->headItemImage2Request($item_id, $image_type, $max_width, $max_height, $tag, $format, $percent_played, $unplayed_count, $image_index, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'headItemImage2'
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $max_width The maximum image width to return. (required)
     * @param  int $max_height The maximum image height to return. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (required)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (required)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (required)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (required)
     * @param  int $image_index Image index. (required)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headItemImage2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function headItemImage2Request($item_id, $image_type, $max_width, $max_height, $tag, $format, $percent_played, $unplayed_count, $image_index, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headItemImage2'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling headItemImage2'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling headItemImage2'
            );
        }

        // verify the required parameter 'max_width' is set
        if ($max_width === null || (is_array($max_width) && count($max_width) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $max_width when calling headItemImage2'
            );
        }

        // verify the required parameter 'max_height' is set
        if ($max_height === null || (is_array($max_height) && count($max_height) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $max_height when calling headItemImage2'
            );
        }

        // verify the required parameter 'tag' is set
        if ($tag === null || (is_array($tag) && count($tag) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tag when calling headItemImage2'
            );
        }

        // verify the required parameter 'format' is set
        if ($format === null || (is_array($format) && count($format) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $format when calling headItemImage2'
            );
        }

        // verify the required parameter 'percent_played' is set
        if ($percent_played === null || (is_array($percent_played) && count($percent_played) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $percent_played when calling headItemImage2'
            );
        }

        // verify the required parameter 'unplayed_count' is set
        if ($unplayed_count === null || (is_array($unplayed_count) && count($unplayed_count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $unplayed_count when calling headItemImage2'
            );
        }

        // verify the required parameter 'image_index' is set
        if ($image_index === null || (is_array($image_index) && count($image_index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_index when calling headItemImage2'
            );
        }












        $resourcePath = '/Items/{itemId}/Images/{imageType}/{imageIndex}/{tag}/{format}/{maxWidth}/{maxHeight}/{percentPlayed}/{unplayedCount}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }
        // path params
        if ($max_width !== null) {
            $resourcePath = str_replace(
                '{' . 'maxWidth' . '}',
                ObjectSerializer::toPathValue($max_width),
                $resourcePath
            );
        }
        // path params
        if ($max_height !== null) {
            $resourcePath = str_replace(
                '{' . 'maxHeight' . '}',
                ObjectSerializer::toPathValue($max_height),
                $resourcePath
            );
        }
        // path params
        if ($tag !== null) {
            $resourcePath = str_replace(
                '{' . 'tag' . '}',
                ObjectSerializer::toPathValue($tag),
                $resourcePath
            );
        }
        // path params
        if ($format !== null) {
            $resourcePath = str_replace(
                '{' . 'format' . '}',
                ObjectSerializer::toPathValue($format),
                $resourcePath
            );
        }
        // path params
        if ($percent_played !== null) {
            $resourcePath = str_replace(
                '{' . 'percentPlayed' . '}',
                ObjectSerializer::toPathValue($percent_played),
                $resourcePath
            );
        }
        // path params
        if ($unplayed_count !== null) {
            $resourcePath = str_replace(
                '{' . 'unplayedCount' . '}',
                ObjectSerializer::toPathValue($unplayed_count),
                $resourcePath
            );
        }
        // path params
        if ($image_index !== null) {
            $resourcePath = str_replace(
                '{' . 'imageIndex' . '}',
                ObjectSerializer::toPathValue($image_index),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'HEAD',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation headItemImageByIndex
     *
     * Gets the item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image. (optional)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headItemImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function headItemImageByIndex($item_id, $image_type, $image_index, $max_width = null, $max_height = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $tag = null, $crop_whitespace = null, $format = null, $add_played_indicator = null, $percent_played = null, $unplayed_count = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headItemImageByIndex'][0])
    {
        list($response) = $this->headItemImageByIndexWithHttpInfo($item_id, $image_type, $image_index, $max_width, $max_height, $width, $height, $quality, $fill_width, $fill_height, $tag, $crop_whitespace, $format, $add_played_indicator, $percent_played, $unplayed_count, $blur, $background_color, $foreground_layer, $contentType);
        return $response;
    }

    /**
     * Operation headItemImageByIndexWithHttpInfo
     *
     * Gets the item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image. (optional)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headItemImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function headItemImageByIndexWithHttpInfo($item_id, $image_type, $image_index, $max_width = null, $max_height = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $tag = null, $crop_whitespace = null, $format = null, $add_played_indicator = null, $percent_played = null, $unplayed_count = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headItemImageByIndex'][0])
    {
        $request = $this->headItemImageByIndexRequest($item_id, $image_type, $image_index, $max_width, $max_height, $width, $height, $quality, $fill_width, $fill_height, $tag, $crop_whitespace, $format, $add_played_indicator, $percent_played, $unplayed_count, $blur, $background_color, $foreground_layer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation headItemImageByIndexAsync
     *
     * Gets the item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image. (optional)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headItemImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headItemImageByIndexAsync($item_id, $image_type, $image_index, $max_width = null, $max_height = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $tag = null, $crop_whitespace = null, $format = null, $add_played_indicator = null, $percent_played = null, $unplayed_count = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headItemImageByIndex'][0])
    {
        return $this->headItemImageByIndexAsyncWithHttpInfo($item_id, $image_type, $image_index, $max_width, $max_height, $width, $height, $quality, $fill_width, $fill_height, $tag, $crop_whitespace, $format, $add_played_indicator, $percent_played, $unplayed_count, $blur, $background_color, $foreground_layer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation headItemImageByIndexAsyncWithHttpInfo
     *
     * Gets the item&#39;s image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image. (optional)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headItemImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headItemImageByIndexAsyncWithHttpInfo($item_id, $image_type, $image_index, $max_width = null, $max_height = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $tag = null, $crop_whitespace = null, $format = null, $add_played_indicator = null, $percent_played = null, $unplayed_count = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headItemImageByIndex'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->headItemImageByIndexRequest($item_id, $image_type, $image_index, $max_width, $max_height, $width, $height, $quality, $fill_width, $fill_height, $tag, $crop_whitespace, $format, $add_played_indicator, $percent_played, $unplayed_count, $blur, $background_color, $foreground_layer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'headItemImageByIndex'
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image. (optional)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headItemImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function headItemImageByIndexRequest($item_id, $image_type, $image_index, $max_width = null, $max_height = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $tag = null, $crop_whitespace = null, $format = null, $add_played_indicator = null, $percent_played = null, $unplayed_count = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headItemImageByIndex'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling headItemImageByIndex'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling headItemImageByIndex'
            );
        }

        // verify the required parameter 'image_index' is set
        if ($image_index === null || (is_array($image_index) && count($image_index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_index when calling headItemImageByIndex'
            );
        }


















        $resourcePath = '/Items/{itemId}/Images/{imageType}/{imageIndex}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ImageFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $percent_played,
            'percentPlayed', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unplayed_count,
            'unplayedCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }
        // path params
        if ($image_index !== null) {
            $resourcePath = str_replace(
                '{' . 'imageIndex' . '}',
                ObjectSerializer::toPathValue($image_index),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'HEAD',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation headMusicGenreImage
     *
     * Get music genre image by name.
     *
     * @param  string $name Music genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headMusicGenreImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function headMusicGenreImage($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headMusicGenreImage'][0])
    {
        list($response) = $this->headMusicGenreImageWithHttpInfo($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);
        return $response;
    }

    /**
     * Operation headMusicGenreImageWithHttpInfo
     *
     * Get music genre image by name.
     *
     * @param  string $name Music genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headMusicGenreImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function headMusicGenreImageWithHttpInfo($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headMusicGenreImage'][0])
    {
        $request = $this->headMusicGenreImageRequest($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation headMusicGenreImageAsync
     *
     * Get music genre image by name.
     *
     * @param  string $name Music genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headMusicGenreImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headMusicGenreImageAsync($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headMusicGenreImage'][0])
    {
        return $this->headMusicGenreImageAsyncWithHttpInfo($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation headMusicGenreImageAsyncWithHttpInfo
     *
     * Get music genre image by name.
     *
     * @param  string $name Music genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headMusicGenreImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headMusicGenreImageAsyncWithHttpInfo($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headMusicGenreImage'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->headMusicGenreImageRequest($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'headMusicGenreImage'
     *
     * @param  string $name Music genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headMusicGenreImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function headMusicGenreImageRequest($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headMusicGenreImage'][0])
    {

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling headMusicGenreImage'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling headMusicGenreImage'
            );
        }



















        $resourcePath = '/MusicGenres/{name}/Images/{imageType}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ImageFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $percent_played,
            'percentPlayed', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unplayed_count,
            'unplayedCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_index,
            'imageIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'HEAD',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation headMusicGenreImageByIndex
     *
     * Get music genre image by name.
     *
     * @param  string $name Music genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headMusicGenreImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function headMusicGenreImageByIndex($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headMusicGenreImageByIndex'][0])
    {
        list($response) = $this->headMusicGenreImageByIndexWithHttpInfo($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);
        return $response;
    }

    /**
     * Operation headMusicGenreImageByIndexWithHttpInfo
     *
     * Get music genre image by name.
     *
     * @param  string $name Music genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headMusicGenreImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function headMusicGenreImageByIndexWithHttpInfo($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headMusicGenreImageByIndex'][0])
    {
        $request = $this->headMusicGenreImageByIndexRequest($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation headMusicGenreImageByIndexAsync
     *
     * Get music genre image by name.
     *
     * @param  string $name Music genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headMusicGenreImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headMusicGenreImageByIndexAsync($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headMusicGenreImageByIndex'][0])
    {
        return $this->headMusicGenreImageByIndexAsyncWithHttpInfo($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation headMusicGenreImageByIndexAsyncWithHttpInfo
     *
     * Get music genre image by name.
     *
     * @param  string $name Music genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headMusicGenreImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headMusicGenreImageByIndexAsyncWithHttpInfo($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headMusicGenreImageByIndex'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->headMusicGenreImageByIndexRequest($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'headMusicGenreImageByIndex'
     *
     * @param  string $name Music genre name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headMusicGenreImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function headMusicGenreImageByIndexRequest($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headMusicGenreImageByIndex'][0])
    {

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling headMusicGenreImageByIndex'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling headMusicGenreImageByIndex'
            );
        }

        // verify the required parameter 'image_index' is set
        if ($image_index === null || (is_array($image_index) && count($image_index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_index when calling headMusicGenreImageByIndex'
            );
        }


















        $resourcePath = '/MusicGenres/{name}/Images/{imageType}/{imageIndex}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ImageFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $percent_played,
            'percentPlayed', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unplayed_count,
            'unplayedCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }
        // path params
        if ($image_index !== null) {
            $resourcePath = str_replace(
                '{' . 'imageIndex' . '}',
                ObjectSerializer::toPathValue($image_index),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'HEAD',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation headPersonImage
     *
     * Get person image by name.
     *
     * @param  string $name Person name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headPersonImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function headPersonImage($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headPersonImage'][0])
    {
        list($response) = $this->headPersonImageWithHttpInfo($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);
        return $response;
    }

    /**
     * Operation headPersonImageWithHttpInfo
     *
     * Get person image by name.
     *
     * @param  string $name Person name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headPersonImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function headPersonImageWithHttpInfo($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headPersonImage'][0])
    {
        $request = $this->headPersonImageRequest($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation headPersonImageAsync
     *
     * Get person image by name.
     *
     * @param  string $name Person name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headPersonImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headPersonImageAsync($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headPersonImage'][0])
    {
        return $this->headPersonImageAsyncWithHttpInfo($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation headPersonImageAsyncWithHttpInfo
     *
     * Get person image by name.
     *
     * @param  string $name Person name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headPersonImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headPersonImageAsyncWithHttpInfo($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headPersonImage'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->headPersonImageRequest($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'headPersonImage'
     *
     * @param  string $name Person name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headPersonImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function headPersonImageRequest($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headPersonImage'][0])
    {

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling headPersonImage'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling headPersonImage'
            );
        }



















        $resourcePath = '/Persons/{name}/Images/{imageType}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ImageFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $percent_played,
            'percentPlayed', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unplayed_count,
            'unplayedCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_index,
            'imageIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'HEAD',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation headPersonImageByIndex
     *
     * Get person image by name.
     *
     * @param  string $name Person name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headPersonImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function headPersonImageByIndex($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headPersonImageByIndex'][0])
    {
        list($response) = $this->headPersonImageByIndexWithHttpInfo($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);
        return $response;
    }

    /**
     * Operation headPersonImageByIndexWithHttpInfo
     *
     * Get person image by name.
     *
     * @param  string $name Person name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headPersonImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function headPersonImageByIndexWithHttpInfo($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headPersonImageByIndex'][0])
    {
        $request = $this->headPersonImageByIndexRequest($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation headPersonImageByIndexAsync
     *
     * Get person image by name.
     *
     * @param  string $name Person name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headPersonImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headPersonImageByIndexAsync($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headPersonImageByIndex'][0])
    {
        return $this->headPersonImageByIndexAsyncWithHttpInfo($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation headPersonImageByIndexAsyncWithHttpInfo
     *
     * Get person image by name.
     *
     * @param  string $name Person name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headPersonImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headPersonImageByIndexAsyncWithHttpInfo($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headPersonImageByIndex'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->headPersonImageByIndexRequest($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'headPersonImageByIndex'
     *
     * @param  string $name Person name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headPersonImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function headPersonImageByIndexRequest($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headPersonImageByIndex'][0])
    {

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling headPersonImageByIndex'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling headPersonImageByIndex'
            );
        }

        // verify the required parameter 'image_index' is set
        if ($image_index === null || (is_array($image_index) && count($image_index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_index when calling headPersonImageByIndex'
            );
        }


















        $resourcePath = '/Persons/{name}/Images/{imageType}/{imageIndex}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ImageFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $percent_played,
            'percentPlayed', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unplayed_count,
            'unplayedCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }
        // path params
        if ($image_index !== null) {
            $resourcePath = str_replace(
                '{' . 'imageIndex' . '}',
                ObjectSerializer::toPathValue($image_index),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'HEAD',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation headStudioImage
     *
     * Get studio image by name.
     *
     * @param  string $name Studio name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headStudioImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function headStudioImage($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headStudioImage'][0])
    {
        list($response) = $this->headStudioImageWithHttpInfo($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);
        return $response;
    }

    /**
     * Operation headStudioImageWithHttpInfo
     *
     * Get studio image by name.
     *
     * @param  string $name Studio name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headStudioImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function headStudioImageWithHttpInfo($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headStudioImage'][0])
    {
        $request = $this->headStudioImageRequest($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation headStudioImageAsync
     *
     * Get studio image by name.
     *
     * @param  string $name Studio name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headStudioImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headStudioImageAsync($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headStudioImage'][0])
    {
        return $this->headStudioImageAsyncWithHttpInfo($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation headStudioImageAsyncWithHttpInfo
     *
     * Get studio image by name.
     *
     * @param  string $name Studio name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headStudioImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headStudioImageAsyncWithHttpInfo($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headStudioImage'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->headStudioImageRequest($name, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'headStudioImage'
     *
     * @param  string $name Studio name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headStudioImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function headStudioImageRequest($name, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headStudioImage'][0])
    {

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling headStudioImage'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling headStudioImage'
            );
        }



















        $resourcePath = '/Studios/{name}/Images/{imageType}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ImageFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $percent_played,
            'percentPlayed', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unplayed_count,
            'unplayedCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_index,
            'imageIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'HEAD',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation headStudioImageByIndex
     *
     * Get studio image by name.
     *
     * @param  string $name Studio name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headStudioImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function headStudioImageByIndex($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headStudioImageByIndex'][0])
    {
        list($response) = $this->headStudioImageByIndexWithHttpInfo($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);
        return $response;
    }

    /**
     * Operation headStudioImageByIndexWithHttpInfo
     *
     * Get studio image by name.
     *
     * @param  string $name Studio name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headStudioImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function headStudioImageByIndexWithHttpInfo($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headStudioImageByIndex'][0])
    {
        $request = $this->headStudioImageByIndexRequest($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation headStudioImageByIndexAsync
     *
     * Get studio image by name.
     *
     * @param  string $name Studio name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headStudioImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headStudioImageByIndexAsync($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headStudioImageByIndex'][0])
    {
        return $this->headStudioImageByIndexAsyncWithHttpInfo($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation headStudioImageByIndexAsyncWithHttpInfo
     *
     * Get studio image by name.
     *
     * @param  string $name Studio name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headStudioImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headStudioImageByIndexAsyncWithHttpInfo($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headStudioImageByIndex'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->headStudioImageByIndexRequest($name, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'headStudioImageByIndex'
     *
     * @param  string $name Studio name. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headStudioImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function headStudioImageByIndexRequest($name, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headStudioImageByIndex'][0])
    {

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling headStudioImageByIndex'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling headStudioImageByIndex'
            );
        }

        // verify the required parameter 'image_index' is set
        if ($image_index === null || (is_array($image_index) && count($image_index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_index when calling headStudioImageByIndex'
            );
        }


















        $resourcePath = '/Studios/{name}/Images/{imageType}/{imageIndex}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ImageFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $percent_played,
            'percentPlayed', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unplayed_count,
            'unplayedCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }
        // path params
        if ($image_index !== null) {
            $resourcePath = str_replace(
                '{' . 'imageIndex' . '}',
                ObjectSerializer::toPathValue($image_index),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'HEAD',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation headUserImage
     *
     * Get user profile image.
     *
     * @param  string $user_id User id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headUserImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function headUserImage($user_id, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headUserImage'][0])
    {
        list($response) = $this->headUserImageWithHttpInfo($user_id, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);
        return $response;
    }

    /**
     * Operation headUserImageWithHttpInfo
     *
     * Get user profile image.
     *
     * @param  string $user_id User id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headUserImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function headUserImageWithHttpInfo($user_id, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headUserImage'][0])
    {
        $request = $this->headUserImageRequest($user_id, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation headUserImageAsync
     *
     * Get user profile image.
     *
     * @param  string $user_id User id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headUserImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headUserImageAsync($user_id, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headUserImage'][0])
    {
        return $this->headUserImageAsyncWithHttpInfo($user_id, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation headUserImageAsyncWithHttpInfo
     *
     * Get user profile image.
     *
     * @param  string $user_id User id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headUserImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headUserImageAsyncWithHttpInfo($user_id, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headUserImage'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->headUserImageRequest($user_id, $image_type, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $image_index, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'headUserImage'
     *
     * @param  string $user_id User id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  int $image_index Image index. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headUserImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function headUserImageRequest($user_id, $image_type, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, $image_index = null, string $contentType = self::contentTypes['headUserImage'][0])
    {

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling headUserImage'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling headUserImage'
            );
        }



















        $resourcePath = '/Users/{userId}/Images/{imageType}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ImageFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $percent_played,
            'percentPlayed', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unplayed_count,
            'unplayedCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_index,
            'imageIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'HEAD',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation headUserImageByIndex
     *
     * Get user profile image.
     *
     * @param  string $user_id User id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headUserImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function headUserImageByIndex($user_id, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headUserImageByIndex'][0])
    {
        list($response) = $this->headUserImageByIndexWithHttpInfo($user_id, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);
        return $response;
    }

    /**
     * Operation headUserImageByIndexWithHttpInfo
     *
     * Get user profile image.
     *
     * @param  string $user_id User id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headUserImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function headUserImageByIndexWithHttpInfo($user_id, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headUserImageByIndex'][0])
    {
        $request = $this->headUserImageByIndexRequest($user_id, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation headUserImageByIndexAsync
     *
     * Get user profile image.
     *
     * @param  string $user_id User id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headUserImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headUserImageByIndexAsync($user_id, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headUserImageByIndex'][0])
    {
        return $this->headUserImageByIndexAsyncWithHttpInfo($user_id, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation headUserImageByIndexAsyncWithHttpInfo
     *
     * Get user profile image.
     *
     * @param  string $user_id User id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headUserImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headUserImageByIndexAsyncWithHttpInfo($user_id, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headUserImageByIndex'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->headUserImageByIndexRequest($user_id, $image_type, $image_index, $tag, $format, $max_width, $max_height, $percent_played, $unplayed_count, $width, $height, $quality, $fill_width, $fill_height, $crop_whitespace, $add_played_indicator, $blur, $background_color, $foreground_layer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'headUserImageByIndex'
     *
     * @param  string $user_id User id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Image index. (required)
     * @param  string $tag Optional. Supply the cache tag from the item object to receive strong caching headers. (optional)
     * @param  \OpenAPI\Client\Model\ImageFormat $format Determines the output format of the image - original,gif,jpg,png. (optional)
     * @param  int $max_width The maximum image width to return. (optional)
     * @param  int $max_height The maximum image height to return. (optional)
     * @param  float $percent_played Optional. Percent to render for the percent played overlay. (optional)
     * @param  int $unplayed_count Optional. Unplayed count overlay to render. (optional)
     * @param  int $width The fixed image width to return. (optional)
     * @param  int $height The fixed image height to return. (optional)
     * @param  int $quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. (optional)
     * @param  int $fill_width Width of box to fill. (optional)
     * @param  int $fill_height Height of box to fill. (optional)
     * @param  bool $crop_whitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art. (optional) (deprecated)
     * @param  bool $add_played_indicator Optional. Add a played indicator. (optional)
     * @param  int $blur Optional. Blur image. (optional)
     * @param  string $background_color Optional. Apply a background color for transparent images. (optional)
     * @param  string $foreground_layer Optional. Apply a foreground layer on top of the image. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headUserImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function headUserImageByIndexRequest($user_id, $image_type, $image_index, $tag = null, $format = null, $max_width = null, $max_height = null, $percent_played = null, $unplayed_count = null, $width = null, $height = null, $quality = null, $fill_width = null, $fill_height = null, $crop_whitespace = null, $add_played_indicator = null, $blur = null, $background_color = null, $foreground_layer = null, string $contentType = self::contentTypes['headUserImageByIndex'][0])
    {

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling headUserImageByIndex'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling headUserImageByIndex'
            );
        }

        // verify the required parameter 'image_index' is set
        if ($image_index === null || (is_array($image_index) && count($image_index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_index when calling headUserImageByIndex'
            );
        }


















        $resourcePath = '/Users/{userId}/Images/{imageType}/{imageIndex}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'ImageFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $percent_played,
            'percentPlayed', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unplayed_count,
            'unplayedCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quality,
            'quality', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_width,
            'fillWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_height,
            'fillHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $crop_whitespace,
            'cropWhitespace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_played_indicator,
            'addPlayedIndicator', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $blur,
            'blur', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_color,
            'backgroundColor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $foreground_layer,
            'foregroundLayer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }
        // path params
        if ($image_index !== null) {
            $resourcePath = str_replace(
                '{' . 'imageIndex' . '}',
                ObjectSerializer::toPathValue($image_index),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'HEAD',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postUserImage
     *
     * Sets the user image.
     *
     * @param  string $user_id User Id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type (Unused) Image type. (required)
     * @param  int $index (Unused) Image index. (optional)
     * @param  \SplFileObject $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postUserImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postUserImage($user_id, $image_type, $index = null, $body = null, string $contentType = self::contentTypes['postUserImage'][0])
    {
        $this->postUserImageWithHttpInfo($user_id, $image_type, $index, $body, $contentType);
    }

    /**
     * Operation postUserImageWithHttpInfo
     *
     * Sets the user image.
     *
     * @param  string $user_id User Id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type (Unused) Image type. (required)
     * @param  int $index (Unused) Image index. (optional)
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postUserImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postUserImageWithHttpInfo($user_id, $image_type, $index = null, $body = null, string $contentType = self::contentTypes['postUserImage'][0])
    {
        $request = $this->postUserImageRequest($user_id, $image_type, $index, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postUserImageAsync
     *
     * Sets the user image.
     *
     * @param  string $user_id User Id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type (Unused) Image type. (required)
     * @param  int $index (Unused) Image index. (optional)
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postUserImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postUserImageAsync($user_id, $image_type, $index = null, $body = null, string $contentType = self::contentTypes['postUserImage'][0])
    {
        return $this->postUserImageAsyncWithHttpInfo($user_id, $image_type, $index, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postUserImageAsyncWithHttpInfo
     *
     * Sets the user image.
     *
     * @param  string $user_id User Id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type (Unused) Image type. (required)
     * @param  int $index (Unused) Image index. (optional)
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postUserImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postUserImageAsyncWithHttpInfo($user_id, $image_type, $index = null, $body = null, string $contentType = self::contentTypes['postUserImage'][0])
    {
        $returnType = '';
        $request = $this->postUserImageRequest($user_id, $image_type, $index, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postUserImage'
     *
     * @param  string $user_id User Id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type (Unused) Image type. (required)
     * @param  int $index (Unused) Image index. (optional)
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postUserImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postUserImageRequest($user_id, $image_type, $index = null, $body = null, string $contentType = self::contentTypes['postUserImage'][0])
    {

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling postUserImage'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling postUserImage'
            );
        }




        $resourcePath = '/Users/{userId}/Images/{imageType}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $index,
            'index', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postUserImageByIndex
     *
     * Sets the user image.
     *
     * @param  string $user_id User Id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type (Unused) Image type. (required)
     * @param  int $index (Unused) Image index. (required)
     * @param  \SplFileObject $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postUserImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postUserImageByIndex($user_id, $image_type, $index, $body = null, string $contentType = self::contentTypes['postUserImageByIndex'][0])
    {
        $this->postUserImageByIndexWithHttpInfo($user_id, $image_type, $index, $body, $contentType);
    }

    /**
     * Operation postUserImageByIndexWithHttpInfo
     *
     * Sets the user image.
     *
     * @param  string $user_id User Id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type (Unused) Image type. (required)
     * @param  int $index (Unused) Image index. (required)
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postUserImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postUserImageByIndexWithHttpInfo($user_id, $image_type, $index, $body = null, string $contentType = self::contentTypes['postUserImageByIndex'][0])
    {
        $request = $this->postUserImageByIndexRequest($user_id, $image_type, $index, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postUserImageByIndexAsync
     *
     * Sets the user image.
     *
     * @param  string $user_id User Id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type (Unused) Image type. (required)
     * @param  int $index (Unused) Image index. (required)
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postUserImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postUserImageByIndexAsync($user_id, $image_type, $index, $body = null, string $contentType = self::contentTypes['postUserImageByIndex'][0])
    {
        return $this->postUserImageByIndexAsyncWithHttpInfo($user_id, $image_type, $index, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postUserImageByIndexAsyncWithHttpInfo
     *
     * Sets the user image.
     *
     * @param  string $user_id User Id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type (Unused) Image type. (required)
     * @param  int $index (Unused) Image index. (required)
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postUserImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postUserImageByIndexAsyncWithHttpInfo($user_id, $image_type, $index, $body = null, string $contentType = self::contentTypes['postUserImageByIndex'][0])
    {
        $returnType = '';
        $request = $this->postUserImageByIndexRequest($user_id, $image_type, $index, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postUserImageByIndex'
     *
     * @param  string $user_id User Id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type (Unused) Image type. (required)
     * @param  int $index (Unused) Image index. (required)
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postUserImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postUserImageByIndexRequest($user_id, $image_type, $index, $body = null, string $contentType = self::contentTypes['postUserImageByIndex'][0])
    {

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling postUserImageByIndex'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling postUserImageByIndex'
            );
        }

        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling postUserImageByIndex'
            );
        }



        $resourcePath = '/Users/{userId}/Images/{imageType}/{index}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setItemImage
     *
     * Set item image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  \SplFileObject $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setItemImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setItemImage($item_id, $image_type, $body = null, string $contentType = self::contentTypes['setItemImage'][0])
    {
        $this->setItemImageWithHttpInfo($item_id, $image_type, $body, $contentType);
    }

    /**
     * Operation setItemImageWithHttpInfo
     *
     * Set item image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setItemImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setItemImageWithHttpInfo($item_id, $image_type, $body = null, string $contentType = self::contentTypes['setItemImage'][0])
    {
        $request = $this->setItemImageRequest($item_id, $image_type, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setItemImageAsync
     *
     * Set item image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setItemImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setItemImageAsync($item_id, $image_type, $body = null, string $contentType = self::contentTypes['setItemImage'][0])
    {
        return $this->setItemImageAsyncWithHttpInfo($item_id, $image_type, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setItemImageAsyncWithHttpInfo
     *
     * Set item image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setItemImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setItemImageAsyncWithHttpInfo($item_id, $image_type, $body = null, string $contentType = self::contentTypes['setItemImage'][0])
    {
        $returnType = '';
        $request = $this->setItemImageRequest($item_id, $image_type, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setItemImage'
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setItemImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setItemImageRequest($item_id, $image_type, $body = null, string $contentType = self::contentTypes['setItemImage'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling setItemImage'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling setItemImage'
            );
        }



        $resourcePath = '/Items/{itemId}/Images/{imageType}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setItemImageByIndex
     *
     * Set item image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index (Unused) Image index. (required)
     * @param  \SplFileObject $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setItemImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setItemImageByIndex($item_id, $image_type, $image_index, $body = null, string $contentType = self::contentTypes['setItemImageByIndex'][0])
    {
        $this->setItemImageByIndexWithHttpInfo($item_id, $image_type, $image_index, $body, $contentType);
    }

    /**
     * Operation setItemImageByIndexWithHttpInfo
     *
     * Set item image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index (Unused) Image index. (required)
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setItemImageByIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setItemImageByIndexWithHttpInfo($item_id, $image_type, $image_index, $body = null, string $contentType = self::contentTypes['setItemImageByIndex'][0])
    {
        $request = $this->setItemImageByIndexRequest($item_id, $image_type, $image_index, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setItemImageByIndexAsync
     *
     * Set item image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index (Unused) Image index. (required)
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setItemImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setItemImageByIndexAsync($item_id, $image_type, $image_index, $body = null, string $contentType = self::contentTypes['setItemImageByIndex'][0])
    {
        return $this->setItemImageByIndexAsyncWithHttpInfo($item_id, $image_type, $image_index, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setItemImageByIndexAsyncWithHttpInfo
     *
     * Set item image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index (Unused) Image index. (required)
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setItemImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setItemImageByIndexAsyncWithHttpInfo($item_id, $image_type, $image_index, $body = null, string $contentType = self::contentTypes['setItemImageByIndex'][0])
    {
        $returnType = '';
        $request = $this->setItemImageByIndexRequest($item_id, $image_type, $image_index, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setItemImageByIndex'
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index (Unused) Image index. (required)
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setItemImageByIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setItemImageByIndexRequest($item_id, $image_type, $image_index, $body = null, string $contentType = self::contentTypes['setItemImageByIndex'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling setItemImageByIndex'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling setItemImageByIndex'
            );
        }

        // verify the required parameter 'image_index' is set
        if ($image_index === null || (is_array($image_index) && count($image_index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_index when calling setItemImageByIndex'
            );
        }



        $resourcePath = '/Items/{itemId}/Images/{imageType}/{imageIndex}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }
        // path params
        if ($image_index !== null) {
            $resourcePath = str_replace(
                '{' . 'imageIndex' . '}',
                ObjectSerializer::toPathValue($image_index),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateItemImageIndex
     *
     * Updates the index for an item image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Old image index. (required)
     * @param  int $new_index New image index. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateItemImageIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateItemImageIndex($item_id, $image_type, $image_index, $new_index, string $contentType = self::contentTypes['updateItemImageIndex'][0])
    {
        $this->updateItemImageIndexWithHttpInfo($item_id, $image_type, $image_index, $new_index, $contentType);
    }

    /**
     * Operation updateItemImageIndexWithHttpInfo
     *
     * Updates the index for an item image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Old image index. (required)
     * @param  int $new_index New image index. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateItemImageIndex'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateItemImageIndexWithHttpInfo($item_id, $image_type, $image_index, $new_index, string $contentType = self::contentTypes['updateItemImageIndex'][0])
    {
        $request = $this->updateItemImageIndexRequest($item_id, $image_type, $image_index, $new_index, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateItemImageIndexAsync
     *
     * Updates the index for an item image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Old image index. (required)
     * @param  int $new_index New image index. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateItemImageIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateItemImageIndexAsync($item_id, $image_type, $image_index, $new_index, string $contentType = self::contentTypes['updateItemImageIndex'][0])
    {
        return $this->updateItemImageIndexAsyncWithHttpInfo($item_id, $image_type, $image_index, $new_index, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateItemImageIndexAsyncWithHttpInfo
     *
     * Updates the index for an item image.
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Old image index. (required)
     * @param  int $new_index New image index. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateItemImageIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateItemImageIndexAsyncWithHttpInfo($item_id, $image_type, $image_index, $new_index, string $contentType = self::contentTypes['updateItemImageIndex'][0])
    {
        $returnType = '';
        $request = $this->updateItemImageIndexRequest($item_id, $image_type, $image_index, $new_index, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateItemImageIndex'
     *
     * @param  string $item_id Item id. (required)
     * @param  \OpenAPI\Client\Model\ImageType $image_type Image type. (required)
     * @param  int $image_index Old image index. (required)
     * @param  int $new_index New image index. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateItemImageIndex'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateItemImageIndexRequest($item_id, $image_type, $image_index, $new_index, string $contentType = self::contentTypes['updateItemImageIndex'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling updateItemImageIndex'
            );
        }

        // verify the required parameter 'image_type' is set
        if ($image_type === null || (is_array($image_type) && count($image_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_type when calling updateItemImageIndex'
            );
        }

        // verify the required parameter 'image_index' is set
        if ($image_index === null || (is_array($image_index) && count($image_index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_index when calling updateItemImageIndex'
            );
        }

        // verify the required parameter 'new_index' is set
        if ($new_index === null || (is_array($new_index) && count($new_index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_index when calling updateItemImageIndex'
            );
        }


        $resourcePath = '/Items/{itemId}/Images/{imageType}/{imageIndex}/Index';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $new_index,
            'newIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                '{' . 'imageType' . '}',
                ObjectSerializer::toPathValue($image_type),
                $resourcePath
            );
        }
        // path params
        if ($image_index !== null) {
            $resourcePath = str_replace(
                '{' . 'imageIndex' . '}',
                ObjectSerializer::toPathValue($image_index),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadCustomSplashscreen
     *
     * Uploads a custom splashscreen.  The body is expected to the image contents base64 encoded.
     *
     * @param  \SplFileObject $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadCustomSplashscreen'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function uploadCustomSplashscreen($body = null, string $contentType = self::contentTypes['uploadCustomSplashscreen'][0])
    {
        $this->uploadCustomSplashscreenWithHttpInfo($body, $contentType);
    }

    /**
     * Operation uploadCustomSplashscreenWithHttpInfo
     *
     * Uploads a custom splashscreen.  The body is expected to the image contents base64 encoded.
     *
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadCustomSplashscreen'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadCustomSplashscreenWithHttpInfo($body = null, string $contentType = self::contentTypes['uploadCustomSplashscreen'][0])
    {
        $request = $this->uploadCustomSplashscreenRequest($body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadCustomSplashscreenAsync
     *
     * Uploads a custom splashscreen.  The body is expected to the image contents base64 encoded.
     *
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadCustomSplashscreen'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadCustomSplashscreenAsync($body = null, string $contentType = self::contentTypes['uploadCustomSplashscreen'][0])
    {
        return $this->uploadCustomSplashscreenAsyncWithHttpInfo($body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadCustomSplashscreenAsyncWithHttpInfo
     *
     * Uploads a custom splashscreen.  The body is expected to the image contents base64 encoded.
     *
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadCustomSplashscreen'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadCustomSplashscreenAsyncWithHttpInfo($body = null, string $contentType = self::contentTypes['uploadCustomSplashscreen'][0])
    {
        $returnType = '';
        $request = $this->uploadCustomSplashscreenRequest($body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadCustomSplashscreen'
     *
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadCustomSplashscreen'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function uploadCustomSplashscreenRequest($body = null, string $contentType = self::contentTypes['uploadCustomSplashscreen'][0])
    {



        $resourcePath = '/Branding/Splashscreen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
