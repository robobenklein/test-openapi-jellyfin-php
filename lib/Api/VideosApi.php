<?php
/**
 * VideosApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Jellyfin API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 10.8.10
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.0.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * VideosApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class VideosApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'deleteAlternateSources' => [
            'application/json',
        ],
        'getAdditionalPart' => [
            'application/json',
        ],
        'getVideoStream' => [
            'application/json',
        ],
        'getVideoStreamByContainer' => [
            'application/json',
        ],
        'headVideoStream' => [
            'application/json',
        ],
        'headVideoStreamByContainer' => [
            'application/json',
        ],
        'mergeVersions' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation deleteAlternateSources
     *
     * Removes alternate video sources.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAlternateSources'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteAlternateSources($item_id, string $contentType = self::contentTypes['deleteAlternateSources'][0])
    {
        $this->deleteAlternateSourcesWithHttpInfo($item_id, $contentType);
    }

    /**
     * Operation deleteAlternateSourcesWithHttpInfo
     *
     * Removes alternate video sources.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAlternateSources'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAlternateSourcesWithHttpInfo($item_id, string $contentType = self::contentTypes['deleteAlternateSources'][0])
    {
        $request = $this->deleteAlternateSourcesRequest($item_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAlternateSourcesAsync
     *
     * Removes alternate video sources.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAlternateSources'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAlternateSourcesAsync($item_id, string $contentType = self::contentTypes['deleteAlternateSources'][0])
    {
        return $this->deleteAlternateSourcesAsyncWithHttpInfo($item_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAlternateSourcesAsyncWithHttpInfo
     *
     * Removes alternate video sources.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAlternateSources'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAlternateSourcesAsyncWithHttpInfo($item_id, string $contentType = self::contentTypes['deleteAlternateSources'][0])
    {
        $returnType = '';
        $request = $this->deleteAlternateSourcesRequest($item_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAlternateSources'
     *
     * @param  string $item_id The item id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAlternateSources'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAlternateSourcesRequest($item_id, string $contentType = self::contentTypes['deleteAlternateSources'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling deleteAlternateSources'
            );
        }


        $resourcePath = '/Videos/{itemId}/AlternateSources';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAdditionalPart
     *
     * Gets additional parts for a video.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $user_id Optional. Filter by user id, and attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAdditionalPart'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BaseItemDtoQueryResult
     */
    public function getAdditionalPart($item_id, $user_id = null, string $contentType = self::contentTypes['getAdditionalPart'][0])
    {
        list($response) = $this->getAdditionalPartWithHttpInfo($item_id, $user_id, $contentType);
        return $response;
    }

    /**
     * Operation getAdditionalPartWithHttpInfo
     *
     * Gets additional parts for a video.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $user_id Optional. Filter by user id, and attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAdditionalPart'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BaseItemDtoQueryResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAdditionalPartWithHttpInfo($item_id, $user_id = null, string $contentType = self::contentTypes['getAdditionalPart'][0])
    {
        $request = $this->getAdditionalPartRequest($item_id, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\BaseItemDtoQueryResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BaseItemDtoQueryResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BaseItemDtoQueryResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\BaseItemDtoQueryResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BaseItemDtoQueryResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAdditionalPartAsync
     *
     * Gets additional parts for a video.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $user_id Optional. Filter by user id, and attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAdditionalPart'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdditionalPartAsync($item_id, $user_id = null, string $contentType = self::contentTypes['getAdditionalPart'][0])
    {
        return $this->getAdditionalPartAsyncWithHttpInfo($item_id, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAdditionalPartAsyncWithHttpInfo
     *
     * Gets additional parts for a video.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $user_id Optional. Filter by user id, and attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAdditionalPart'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAdditionalPartAsyncWithHttpInfo($item_id, $user_id = null, string $contentType = self::contentTypes['getAdditionalPart'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BaseItemDtoQueryResult';
        $request = $this->getAdditionalPartRequest($item_id, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAdditionalPart'
     *
     * @param  string $item_id The item id. (required)
     * @param  string $user_id Optional. Filter by user id, and attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAdditionalPart'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAdditionalPartRequest($item_id, $user_id = null, string $contentType = self::contentTypes['getAdditionalPart'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling getAdditionalPart'
            );
        }



        $resourcePath = '/Videos/{itemId}/AdditionalParts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'userId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVideoStream
     *
     * Gets a video stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (optional)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVideoStream'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getVideoStream($item_id, $container = null, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getVideoStream'][0])
    {
        list($response) = $this->getVideoStreamWithHttpInfo($item_id, $container, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType);
        return $response;
    }

    /**
     * Operation getVideoStreamWithHttpInfo
     *
     * Gets a video stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (optional)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVideoStream'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVideoStreamWithHttpInfo($item_id, $container = null, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getVideoStream'][0])
    {
        $request = $this->getVideoStreamRequest($item_id, $container, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVideoStreamAsync
     *
     * Gets a video stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (optional)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVideoStream'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVideoStreamAsync($item_id, $container = null, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getVideoStream'][0])
    {
        return $this->getVideoStreamAsyncWithHttpInfo($item_id, $container, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVideoStreamAsyncWithHttpInfo
     *
     * Gets a video stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (optional)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVideoStream'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVideoStreamAsyncWithHttpInfo($item_id, $container = null, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getVideoStream'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getVideoStreamRequest($item_id, $container, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVideoStream'
     *
     * @param  string $item_id The item id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (optional)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVideoStream'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getVideoStreamRequest($item_id, $container = null, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getVideoStream'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling getVideoStream'
            );
        }




















































        $resourcePath = '/Videos/{itemId}/stream';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $container,
            'container', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $static,
            'static', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $params,
            'params', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_profile_id,
            'deviceProfileId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $play_session_id,
            'playSessionId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $segment_container,
            'segmentContainer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $segment_length,
            'segmentLength', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_segments,
            'minSegments', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_source_id,
            'mediaSourceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_codec,
            'audioCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_auto_stream_copy,
            'enableAutoStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_video_stream_copy,
            'allowVideoStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_audio_stream_copy,
            'allowAudioStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $break_on_non_key_frames,
            'breakOnNonKeyFrames', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_sample_rate,
            'audioSampleRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_audio_bit_depth,
            'maxAudioBitDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_bit_rate,
            'audioBitRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_channels,
            'audioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_audio_channels,
            'maxAudioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $profile,
            'profile', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $framerate,
            'framerate', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_framerate,
            'maxFramerate', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $copy_timestamps,
            'copyTimestamps', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_time_ticks,
            'startTimeTicks', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_bit_rate,
            'videoBitRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_stream_index,
            'subtitleStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_method,
            'subtitleMethod', // param base name
            'SubtitleDeliveryMethod', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_ref_frames,
            'maxRefFrames', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_video_bit_depth,
            'maxVideoBitDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $require_avc,
            'requireAvc', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $de_interlace,
            'deInterlace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $require_non_anamorphic,
            'requireNonAnamorphic', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcoding_max_audio_channels,
            'transcodingMaxAudioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cpu_core_limit,
            'cpuCoreLimit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $live_stream_id,
            'liveStreamId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_mpegts_m2_ts_mode,
            'enableMpegtsM2TsMode', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_codec,
            'videoCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_codec,
            'subtitleCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcode_reasons,
            'transcodeReasons', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_stream_index,
            'audioStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_stream_index,
            'videoStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'EncodingContext', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stream_options,
            'streamOptions', // param base name
            'object', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['video/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVideoStreamByContainer
     *
     * Gets a video stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVideoStreamByContainer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getVideoStreamByContainer($item_id, $container, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getVideoStreamByContainer'][0])
    {
        list($response) = $this->getVideoStreamByContainerWithHttpInfo($item_id, $container, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType);
        return $response;
    }

    /**
     * Operation getVideoStreamByContainerWithHttpInfo
     *
     * Gets a video stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVideoStreamByContainer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVideoStreamByContainerWithHttpInfo($item_id, $container, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getVideoStreamByContainer'][0])
    {
        $request = $this->getVideoStreamByContainerRequest($item_id, $container, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVideoStreamByContainerAsync
     *
     * Gets a video stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVideoStreamByContainer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVideoStreamByContainerAsync($item_id, $container, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getVideoStreamByContainer'][0])
    {
        return $this->getVideoStreamByContainerAsyncWithHttpInfo($item_id, $container, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVideoStreamByContainerAsyncWithHttpInfo
     *
     * Gets a video stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVideoStreamByContainer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVideoStreamByContainerAsyncWithHttpInfo($item_id, $container, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getVideoStreamByContainer'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getVideoStreamByContainerRequest($item_id, $container, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVideoStreamByContainer'
     *
     * @param  string $item_id The item id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVideoStreamByContainer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getVideoStreamByContainerRequest($item_id, $container, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getVideoStreamByContainer'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling getVideoStreamByContainer'
            );
        }

        // verify the required parameter 'container' is set
        if ($container === null || (is_array($container) && count($container) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $container when calling getVideoStreamByContainer'
            );
        }



















































        $resourcePath = '/Videos/{itemId}/stream.{container}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $static,
            'static', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $params,
            'params', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_profile_id,
            'deviceProfileId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $play_session_id,
            'playSessionId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $segment_container,
            'segmentContainer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $segment_length,
            'segmentLength', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_segments,
            'minSegments', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_source_id,
            'mediaSourceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_codec,
            'audioCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_auto_stream_copy,
            'enableAutoStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_video_stream_copy,
            'allowVideoStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_audio_stream_copy,
            'allowAudioStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $break_on_non_key_frames,
            'breakOnNonKeyFrames', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_sample_rate,
            'audioSampleRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_audio_bit_depth,
            'maxAudioBitDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_bit_rate,
            'audioBitRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_channels,
            'audioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_audio_channels,
            'maxAudioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $profile,
            'profile', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $framerate,
            'framerate', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_framerate,
            'maxFramerate', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $copy_timestamps,
            'copyTimestamps', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_time_ticks,
            'startTimeTicks', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_bit_rate,
            'videoBitRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_stream_index,
            'subtitleStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_method,
            'subtitleMethod', // param base name
            'SubtitleDeliveryMethod', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_ref_frames,
            'maxRefFrames', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_video_bit_depth,
            'maxVideoBitDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $require_avc,
            'requireAvc', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $de_interlace,
            'deInterlace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $require_non_anamorphic,
            'requireNonAnamorphic', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcoding_max_audio_channels,
            'transcodingMaxAudioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cpu_core_limit,
            'cpuCoreLimit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $live_stream_id,
            'liveStreamId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_mpegts_m2_ts_mode,
            'enableMpegtsM2TsMode', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_codec,
            'videoCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_codec,
            'subtitleCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcode_reasons,
            'transcodeReasons', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_stream_index,
            'audioStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_stream_index,
            'videoStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'EncodingContext', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stream_options,
            'streamOptions', // param base name
            'object', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($container !== null) {
            $resourcePath = str_replace(
                '{' . 'container' . '}',
                ObjectSerializer::toPathValue($container),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['video/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation headVideoStream
     *
     * Gets a video stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (optional)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headVideoStream'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function headVideoStream($item_id, $container = null, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['headVideoStream'][0])
    {
        list($response) = $this->headVideoStreamWithHttpInfo($item_id, $container, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType);
        return $response;
    }

    /**
     * Operation headVideoStreamWithHttpInfo
     *
     * Gets a video stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (optional)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headVideoStream'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function headVideoStreamWithHttpInfo($item_id, $container = null, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['headVideoStream'][0])
    {
        $request = $this->headVideoStreamRequest($item_id, $container, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation headVideoStreamAsync
     *
     * Gets a video stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (optional)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headVideoStream'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headVideoStreamAsync($item_id, $container = null, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['headVideoStream'][0])
    {
        return $this->headVideoStreamAsyncWithHttpInfo($item_id, $container, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation headVideoStreamAsyncWithHttpInfo
     *
     * Gets a video stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (optional)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headVideoStream'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headVideoStreamAsyncWithHttpInfo($item_id, $container = null, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['headVideoStream'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->headVideoStreamRequest($item_id, $container, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'headVideoStream'
     *
     * @param  string $item_id The item id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (optional)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headVideoStream'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function headVideoStreamRequest($item_id, $container = null, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['headVideoStream'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling headVideoStream'
            );
        }




















































        $resourcePath = '/Videos/{itemId}/stream';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $container,
            'container', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $static,
            'static', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $params,
            'params', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_profile_id,
            'deviceProfileId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $play_session_id,
            'playSessionId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $segment_container,
            'segmentContainer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $segment_length,
            'segmentLength', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_segments,
            'minSegments', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_source_id,
            'mediaSourceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_codec,
            'audioCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_auto_stream_copy,
            'enableAutoStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_video_stream_copy,
            'allowVideoStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_audio_stream_copy,
            'allowAudioStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $break_on_non_key_frames,
            'breakOnNonKeyFrames', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_sample_rate,
            'audioSampleRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_audio_bit_depth,
            'maxAudioBitDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_bit_rate,
            'audioBitRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_channels,
            'audioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_audio_channels,
            'maxAudioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $profile,
            'profile', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $framerate,
            'framerate', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_framerate,
            'maxFramerate', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $copy_timestamps,
            'copyTimestamps', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_time_ticks,
            'startTimeTicks', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_bit_rate,
            'videoBitRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_stream_index,
            'subtitleStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_method,
            'subtitleMethod', // param base name
            'SubtitleDeliveryMethod', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_ref_frames,
            'maxRefFrames', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_video_bit_depth,
            'maxVideoBitDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $require_avc,
            'requireAvc', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $de_interlace,
            'deInterlace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $require_non_anamorphic,
            'requireNonAnamorphic', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcoding_max_audio_channels,
            'transcodingMaxAudioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cpu_core_limit,
            'cpuCoreLimit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $live_stream_id,
            'liveStreamId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_mpegts_m2_ts_mode,
            'enableMpegtsM2TsMode', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_codec,
            'videoCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_codec,
            'subtitleCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcode_reasons,
            'transcodeReasons', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_stream_index,
            'audioStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_stream_index,
            'videoStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'EncodingContext', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stream_options,
            'streamOptions', // param base name
            'object', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['video/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'HEAD',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation headVideoStreamByContainer
     *
     * Gets a video stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headVideoStreamByContainer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function headVideoStreamByContainer($item_id, $container, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['headVideoStreamByContainer'][0])
    {
        list($response) = $this->headVideoStreamByContainerWithHttpInfo($item_id, $container, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType);
        return $response;
    }

    /**
     * Operation headVideoStreamByContainerWithHttpInfo
     *
     * Gets a video stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headVideoStreamByContainer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function headVideoStreamByContainerWithHttpInfo($item_id, $container, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['headVideoStreamByContainer'][0])
    {
        $request = $this->headVideoStreamByContainerRequest($item_id, $container, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation headVideoStreamByContainerAsync
     *
     * Gets a video stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headVideoStreamByContainer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headVideoStreamByContainerAsync($item_id, $container, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['headVideoStreamByContainer'][0])
    {
        return $this->headVideoStreamByContainerAsyncWithHttpInfo($item_id, $container, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation headVideoStreamByContainerAsyncWithHttpInfo
     *
     * Gets a video stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headVideoStreamByContainer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headVideoStreamByContainerAsyncWithHttpInfo($item_id, $container, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['headVideoStreamByContainer'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->headVideoStreamByContainerRequest($item_id, $container, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'headVideoStreamByContainer'
     *
     * @param  string $item_id The item id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headVideoStreamByContainer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function headVideoStreamByContainerRequest($item_id, $container, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['headVideoStreamByContainer'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling headVideoStreamByContainer'
            );
        }

        // verify the required parameter 'container' is set
        if ($container === null || (is_array($container) && count($container) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $container when calling headVideoStreamByContainer'
            );
        }



















































        $resourcePath = '/Videos/{itemId}/stream.{container}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $static,
            'static', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $params,
            'params', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_profile_id,
            'deviceProfileId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $play_session_id,
            'playSessionId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $segment_container,
            'segmentContainer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $segment_length,
            'segmentLength', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_segments,
            'minSegments', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_source_id,
            'mediaSourceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_codec,
            'audioCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_auto_stream_copy,
            'enableAutoStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_video_stream_copy,
            'allowVideoStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_audio_stream_copy,
            'allowAudioStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $break_on_non_key_frames,
            'breakOnNonKeyFrames', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_sample_rate,
            'audioSampleRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_audio_bit_depth,
            'maxAudioBitDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_bit_rate,
            'audioBitRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_channels,
            'audioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_audio_channels,
            'maxAudioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $profile,
            'profile', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $framerate,
            'framerate', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_framerate,
            'maxFramerate', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $copy_timestamps,
            'copyTimestamps', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_time_ticks,
            'startTimeTicks', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_bit_rate,
            'videoBitRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_stream_index,
            'subtitleStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_method,
            'subtitleMethod', // param base name
            'SubtitleDeliveryMethod', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_ref_frames,
            'maxRefFrames', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_video_bit_depth,
            'maxVideoBitDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $require_avc,
            'requireAvc', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $de_interlace,
            'deInterlace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $require_non_anamorphic,
            'requireNonAnamorphic', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcoding_max_audio_channels,
            'transcodingMaxAudioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cpu_core_limit,
            'cpuCoreLimit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $live_stream_id,
            'liveStreamId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_mpegts_m2_ts_mode,
            'enableMpegtsM2TsMode', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_codec,
            'videoCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_codec,
            'subtitleCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcode_reasons,
            'transcodeReasons', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_stream_index,
            'audioStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_stream_index,
            'videoStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'EncodingContext', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stream_options,
            'streamOptions', // param base name
            'object', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($container !== null) {
            $resourcePath = str_replace(
                '{' . 'container' . '}',
                ObjectSerializer::toPathValue($container),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['video/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'HEAD',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation mergeVersions
     *
     * Merges videos into a single record.
     *
     * @param  string[] $ids Item id list. This allows multiple, comma delimited. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mergeVersions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function mergeVersions($ids, string $contentType = self::contentTypes['mergeVersions'][0])
    {
        $this->mergeVersionsWithHttpInfo($ids, $contentType);
    }

    /**
     * Operation mergeVersionsWithHttpInfo
     *
     * Merges videos into a single record.
     *
     * @param  string[] $ids Item id list. This allows multiple, comma delimited. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mergeVersions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function mergeVersionsWithHttpInfo($ids, string $contentType = self::contentTypes['mergeVersions'][0])
    {
        $request = $this->mergeVersionsRequest($ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation mergeVersionsAsync
     *
     * Merges videos into a single record.
     *
     * @param  string[] $ids Item id list. This allows multiple, comma delimited. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mergeVersions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mergeVersionsAsync($ids, string $contentType = self::contentTypes['mergeVersions'][0])
    {
        return $this->mergeVersionsAsyncWithHttpInfo($ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation mergeVersionsAsyncWithHttpInfo
     *
     * Merges videos into a single record.
     *
     * @param  string[] $ids Item id list. This allows multiple, comma delimited. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mergeVersions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mergeVersionsAsyncWithHttpInfo($ids, string $contentType = self::contentTypes['mergeVersions'][0])
    {
        $returnType = '';
        $request = $this->mergeVersionsRequest($ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'mergeVersions'
     *
     * @param  string[] $ids Item id list. This allows multiple, comma delimited. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mergeVersions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function mergeVersionsRequest($ids, string $contentType = self::contentTypes['mergeVersions'][0])
    {

        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling mergeVersions'
            );
        }


        $resourcePath = '/Videos/MergeVersions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
