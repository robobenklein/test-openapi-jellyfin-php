<?php
/**
 * SyncPlayApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Jellyfin API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 10.8.10
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.0.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * SyncPlayApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class SyncPlayApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'syncPlayBuffering' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'syncPlayCreateGroup' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'syncPlayGetGroups' => [
            'application/json',
        ],
        'syncPlayJoinGroup' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'syncPlayLeaveGroup' => [
            'application/json',
        ],
        'syncPlayMovePlaylistItem' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'syncPlayNextItem' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'syncPlayPause' => [
            'application/json',
        ],
        'syncPlayPing' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'syncPlayPreviousItem' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'syncPlayQueue' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'syncPlayReady' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'syncPlayRemoveFromPlaylist' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'syncPlaySeek' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'syncPlaySetIgnoreWait' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'syncPlaySetNewQueue' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'syncPlaySetPlaylistItem' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'syncPlaySetRepeatMode' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'syncPlaySetShuffleMode' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'syncPlayStop' => [
            'application/json',
        ],
        'syncPlayUnpause' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation syncPlayBuffering
     *
     * Notify SyncPlay group that member is buffering.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayBufferingRequest $sync_play_buffering_request The player status. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayBuffering'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function syncPlayBuffering($sync_play_buffering_request, string $contentType = self::contentTypes['syncPlayBuffering'][0])
    {
        $this->syncPlayBufferingWithHttpInfo($sync_play_buffering_request, $contentType);
    }

    /**
     * Operation syncPlayBufferingWithHttpInfo
     *
     * Notify SyncPlay group that member is buffering.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayBufferingRequest $sync_play_buffering_request The player status. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayBuffering'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function syncPlayBufferingWithHttpInfo($sync_play_buffering_request, string $contentType = self::contentTypes['syncPlayBuffering'][0])
    {
        $request = $this->syncPlayBufferingRequest($sync_play_buffering_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation syncPlayBufferingAsync
     *
     * Notify SyncPlay group that member is buffering.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayBufferingRequest $sync_play_buffering_request The player status. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayBuffering'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayBufferingAsync($sync_play_buffering_request, string $contentType = self::contentTypes['syncPlayBuffering'][0])
    {
        return $this->syncPlayBufferingAsyncWithHttpInfo($sync_play_buffering_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation syncPlayBufferingAsyncWithHttpInfo
     *
     * Notify SyncPlay group that member is buffering.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayBufferingRequest $sync_play_buffering_request The player status. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayBuffering'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayBufferingAsyncWithHttpInfo($sync_play_buffering_request, string $contentType = self::contentTypes['syncPlayBuffering'][0])
    {
        $returnType = '';
        $request = $this->syncPlayBufferingRequest($sync_play_buffering_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'syncPlayBuffering'
     *
     * @param  \OpenAPI\Client\Model\SyncPlayBufferingRequest $sync_play_buffering_request The player status. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayBuffering'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function syncPlayBufferingRequest($sync_play_buffering_request, string $contentType = self::contentTypes['syncPlayBuffering'][0])
    {

        // verify the required parameter 'sync_play_buffering_request' is set
        if ($sync_play_buffering_request === null || (is_array($sync_play_buffering_request) && count($sync_play_buffering_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sync_play_buffering_request when calling syncPlayBuffering'
            );
        }


        $resourcePath = '/SyncPlay/Buffering';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($sync_play_buffering_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($sync_play_buffering_request));
            } else {
                $httpBody = $sync_play_buffering_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation syncPlayCreateGroup
     *
     * Create a new SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayCreateGroupRequest $sync_play_create_group_request The settings of the new group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayCreateGroup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function syncPlayCreateGroup($sync_play_create_group_request, string $contentType = self::contentTypes['syncPlayCreateGroup'][0])
    {
        $this->syncPlayCreateGroupWithHttpInfo($sync_play_create_group_request, $contentType);
    }

    /**
     * Operation syncPlayCreateGroupWithHttpInfo
     *
     * Create a new SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayCreateGroupRequest $sync_play_create_group_request The settings of the new group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayCreateGroup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function syncPlayCreateGroupWithHttpInfo($sync_play_create_group_request, string $contentType = self::contentTypes['syncPlayCreateGroup'][0])
    {
        $request = $this->syncPlayCreateGroupRequest($sync_play_create_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation syncPlayCreateGroupAsync
     *
     * Create a new SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayCreateGroupRequest $sync_play_create_group_request The settings of the new group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayCreateGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayCreateGroupAsync($sync_play_create_group_request, string $contentType = self::contentTypes['syncPlayCreateGroup'][0])
    {
        return $this->syncPlayCreateGroupAsyncWithHttpInfo($sync_play_create_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation syncPlayCreateGroupAsyncWithHttpInfo
     *
     * Create a new SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayCreateGroupRequest $sync_play_create_group_request The settings of the new group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayCreateGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayCreateGroupAsyncWithHttpInfo($sync_play_create_group_request, string $contentType = self::contentTypes['syncPlayCreateGroup'][0])
    {
        $returnType = '';
        $request = $this->syncPlayCreateGroupRequest($sync_play_create_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'syncPlayCreateGroup'
     *
     * @param  \OpenAPI\Client\Model\SyncPlayCreateGroupRequest $sync_play_create_group_request The settings of the new group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayCreateGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function syncPlayCreateGroupRequest($sync_play_create_group_request, string $contentType = self::contentTypes['syncPlayCreateGroup'][0])
    {

        // verify the required parameter 'sync_play_create_group_request' is set
        if ($sync_play_create_group_request === null || (is_array($sync_play_create_group_request) && count($sync_play_create_group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sync_play_create_group_request when calling syncPlayCreateGroup'
            );
        }


        $resourcePath = '/SyncPlay/New';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($sync_play_create_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($sync_play_create_group_request));
            } else {
                $httpBody = $sync_play_create_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation syncPlayGetGroups
     *
     * Gets all SyncPlay groups.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayGetGroups'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GroupInfoDto[]
     */
    public function syncPlayGetGroups(string $contentType = self::contentTypes['syncPlayGetGroups'][0])
    {
        list($response) = $this->syncPlayGetGroupsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation syncPlayGetGroupsWithHttpInfo
     *
     * Gets all SyncPlay groups.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayGetGroups'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GroupInfoDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function syncPlayGetGroupsWithHttpInfo(string $contentType = self::contentTypes['syncPlayGetGroups'][0])
    {
        $request = $this->syncPlayGetGroupsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GroupInfoDto[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GroupInfoDto[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GroupInfoDto[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\GroupInfoDto[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GroupInfoDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation syncPlayGetGroupsAsync
     *
     * Gets all SyncPlay groups.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayGetGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayGetGroupsAsync(string $contentType = self::contentTypes['syncPlayGetGroups'][0])
    {
        return $this->syncPlayGetGroupsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation syncPlayGetGroupsAsyncWithHttpInfo
     *
     * Gets all SyncPlay groups.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayGetGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayGetGroupsAsyncWithHttpInfo(string $contentType = self::contentTypes['syncPlayGetGroups'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GroupInfoDto[]';
        $request = $this->syncPlayGetGroupsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'syncPlayGetGroups'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayGetGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function syncPlayGetGroupsRequest(string $contentType = self::contentTypes['syncPlayGetGroups'][0])
    {


        $resourcePath = '/SyncPlay/List';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation syncPlayJoinGroup
     *
     * Join an existing SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayJoinGroupRequest $sync_play_join_group_request The group to join. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayJoinGroup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function syncPlayJoinGroup($sync_play_join_group_request, string $contentType = self::contentTypes['syncPlayJoinGroup'][0])
    {
        $this->syncPlayJoinGroupWithHttpInfo($sync_play_join_group_request, $contentType);
    }

    /**
     * Operation syncPlayJoinGroupWithHttpInfo
     *
     * Join an existing SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayJoinGroupRequest $sync_play_join_group_request The group to join. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayJoinGroup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function syncPlayJoinGroupWithHttpInfo($sync_play_join_group_request, string $contentType = self::contentTypes['syncPlayJoinGroup'][0])
    {
        $request = $this->syncPlayJoinGroupRequest($sync_play_join_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation syncPlayJoinGroupAsync
     *
     * Join an existing SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayJoinGroupRequest $sync_play_join_group_request The group to join. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayJoinGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayJoinGroupAsync($sync_play_join_group_request, string $contentType = self::contentTypes['syncPlayJoinGroup'][0])
    {
        return $this->syncPlayJoinGroupAsyncWithHttpInfo($sync_play_join_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation syncPlayJoinGroupAsyncWithHttpInfo
     *
     * Join an existing SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayJoinGroupRequest $sync_play_join_group_request The group to join. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayJoinGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayJoinGroupAsyncWithHttpInfo($sync_play_join_group_request, string $contentType = self::contentTypes['syncPlayJoinGroup'][0])
    {
        $returnType = '';
        $request = $this->syncPlayJoinGroupRequest($sync_play_join_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'syncPlayJoinGroup'
     *
     * @param  \OpenAPI\Client\Model\SyncPlayJoinGroupRequest $sync_play_join_group_request The group to join. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayJoinGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function syncPlayJoinGroupRequest($sync_play_join_group_request, string $contentType = self::contentTypes['syncPlayJoinGroup'][0])
    {

        // verify the required parameter 'sync_play_join_group_request' is set
        if ($sync_play_join_group_request === null || (is_array($sync_play_join_group_request) && count($sync_play_join_group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sync_play_join_group_request when calling syncPlayJoinGroup'
            );
        }


        $resourcePath = '/SyncPlay/Join';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($sync_play_join_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($sync_play_join_group_request));
            } else {
                $httpBody = $sync_play_join_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation syncPlayLeaveGroup
     *
     * Leave the joined SyncPlay group.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayLeaveGroup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function syncPlayLeaveGroup(string $contentType = self::contentTypes['syncPlayLeaveGroup'][0])
    {
        $this->syncPlayLeaveGroupWithHttpInfo($contentType);
    }

    /**
     * Operation syncPlayLeaveGroupWithHttpInfo
     *
     * Leave the joined SyncPlay group.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayLeaveGroup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function syncPlayLeaveGroupWithHttpInfo(string $contentType = self::contentTypes['syncPlayLeaveGroup'][0])
    {
        $request = $this->syncPlayLeaveGroupRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation syncPlayLeaveGroupAsync
     *
     * Leave the joined SyncPlay group.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayLeaveGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayLeaveGroupAsync(string $contentType = self::contentTypes['syncPlayLeaveGroup'][0])
    {
        return $this->syncPlayLeaveGroupAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation syncPlayLeaveGroupAsyncWithHttpInfo
     *
     * Leave the joined SyncPlay group.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayLeaveGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayLeaveGroupAsyncWithHttpInfo(string $contentType = self::contentTypes['syncPlayLeaveGroup'][0])
    {
        $returnType = '';
        $request = $this->syncPlayLeaveGroupRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'syncPlayLeaveGroup'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayLeaveGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function syncPlayLeaveGroupRequest(string $contentType = self::contentTypes['syncPlayLeaveGroup'][0])
    {


        $resourcePath = '/SyncPlay/Leave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation syncPlayMovePlaylistItem
     *
     * Request to move an item in the playlist in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayMovePlaylistItemRequest $sync_play_move_playlist_item_request The new position for the item. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayMovePlaylistItem'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function syncPlayMovePlaylistItem($sync_play_move_playlist_item_request, string $contentType = self::contentTypes['syncPlayMovePlaylistItem'][0])
    {
        $this->syncPlayMovePlaylistItemWithHttpInfo($sync_play_move_playlist_item_request, $contentType);
    }

    /**
     * Operation syncPlayMovePlaylistItemWithHttpInfo
     *
     * Request to move an item in the playlist in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayMovePlaylistItemRequest $sync_play_move_playlist_item_request The new position for the item. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayMovePlaylistItem'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function syncPlayMovePlaylistItemWithHttpInfo($sync_play_move_playlist_item_request, string $contentType = self::contentTypes['syncPlayMovePlaylistItem'][0])
    {
        $request = $this->syncPlayMovePlaylistItemRequest($sync_play_move_playlist_item_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation syncPlayMovePlaylistItemAsync
     *
     * Request to move an item in the playlist in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayMovePlaylistItemRequest $sync_play_move_playlist_item_request The new position for the item. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayMovePlaylistItem'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayMovePlaylistItemAsync($sync_play_move_playlist_item_request, string $contentType = self::contentTypes['syncPlayMovePlaylistItem'][0])
    {
        return $this->syncPlayMovePlaylistItemAsyncWithHttpInfo($sync_play_move_playlist_item_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation syncPlayMovePlaylistItemAsyncWithHttpInfo
     *
     * Request to move an item in the playlist in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayMovePlaylistItemRequest $sync_play_move_playlist_item_request The new position for the item. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayMovePlaylistItem'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayMovePlaylistItemAsyncWithHttpInfo($sync_play_move_playlist_item_request, string $contentType = self::contentTypes['syncPlayMovePlaylistItem'][0])
    {
        $returnType = '';
        $request = $this->syncPlayMovePlaylistItemRequest($sync_play_move_playlist_item_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'syncPlayMovePlaylistItem'
     *
     * @param  \OpenAPI\Client\Model\SyncPlayMovePlaylistItemRequest $sync_play_move_playlist_item_request The new position for the item. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayMovePlaylistItem'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function syncPlayMovePlaylistItemRequest($sync_play_move_playlist_item_request, string $contentType = self::contentTypes['syncPlayMovePlaylistItem'][0])
    {

        // verify the required parameter 'sync_play_move_playlist_item_request' is set
        if ($sync_play_move_playlist_item_request === null || (is_array($sync_play_move_playlist_item_request) && count($sync_play_move_playlist_item_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sync_play_move_playlist_item_request when calling syncPlayMovePlaylistItem'
            );
        }


        $resourcePath = '/SyncPlay/MovePlaylistItem';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($sync_play_move_playlist_item_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($sync_play_move_playlist_item_request));
            } else {
                $httpBody = $sync_play_move_playlist_item_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation syncPlayNextItem
     *
     * Request next item in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayNextItemRequest $sync_play_next_item_request The current item information. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayNextItem'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function syncPlayNextItem($sync_play_next_item_request, string $contentType = self::contentTypes['syncPlayNextItem'][0])
    {
        $this->syncPlayNextItemWithHttpInfo($sync_play_next_item_request, $contentType);
    }

    /**
     * Operation syncPlayNextItemWithHttpInfo
     *
     * Request next item in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayNextItemRequest $sync_play_next_item_request The current item information. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayNextItem'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function syncPlayNextItemWithHttpInfo($sync_play_next_item_request, string $contentType = self::contentTypes['syncPlayNextItem'][0])
    {
        $request = $this->syncPlayNextItemRequest($sync_play_next_item_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation syncPlayNextItemAsync
     *
     * Request next item in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayNextItemRequest $sync_play_next_item_request The current item information. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayNextItem'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayNextItemAsync($sync_play_next_item_request, string $contentType = self::contentTypes['syncPlayNextItem'][0])
    {
        return $this->syncPlayNextItemAsyncWithHttpInfo($sync_play_next_item_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation syncPlayNextItemAsyncWithHttpInfo
     *
     * Request next item in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayNextItemRequest $sync_play_next_item_request The current item information. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayNextItem'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayNextItemAsyncWithHttpInfo($sync_play_next_item_request, string $contentType = self::contentTypes['syncPlayNextItem'][0])
    {
        $returnType = '';
        $request = $this->syncPlayNextItemRequest($sync_play_next_item_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'syncPlayNextItem'
     *
     * @param  \OpenAPI\Client\Model\SyncPlayNextItemRequest $sync_play_next_item_request The current item information. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayNextItem'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function syncPlayNextItemRequest($sync_play_next_item_request, string $contentType = self::contentTypes['syncPlayNextItem'][0])
    {

        // verify the required parameter 'sync_play_next_item_request' is set
        if ($sync_play_next_item_request === null || (is_array($sync_play_next_item_request) && count($sync_play_next_item_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sync_play_next_item_request when calling syncPlayNextItem'
            );
        }


        $resourcePath = '/SyncPlay/NextItem';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($sync_play_next_item_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($sync_play_next_item_request));
            } else {
                $httpBody = $sync_play_next_item_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation syncPlayPause
     *
     * Request pause in SyncPlay group.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayPause'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function syncPlayPause(string $contentType = self::contentTypes['syncPlayPause'][0])
    {
        $this->syncPlayPauseWithHttpInfo($contentType);
    }

    /**
     * Operation syncPlayPauseWithHttpInfo
     *
     * Request pause in SyncPlay group.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayPause'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function syncPlayPauseWithHttpInfo(string $contentType = self::contentTypes['syncPlayPause'][0])
    {
        $request = $this->syncPlayPauseRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation syncPlayPauseAsync
     *
     * Request pause in SyncPlay group.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayPause'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayPauseAsync(string $contentType = self::contentTypes['syncPlayPause'][0])
    {
        return $this->syncPlayPauseAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation syncPlayPauseAsyncWithHttpInfo
     *
     * Request pause in SyncPlay group.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayPause'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayPauseAsyncWithHttpInfo(string $contentType = self::contentTypes['syncPlayPause'][0])
    {
        $returnType = '';
        $request = $this->syncPlayPauseRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'syncPlayPause'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayPause'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function syncPlayPauseRequest(string $contentType = self::contentTypes['syncPlayPause'][0])
    {


        $resourcePath = '/SyncPlay/Pause';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation syncPlayPing
     *
     * Update session ping.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayPingRequest $sync_play_ping_request The new ping. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayPing'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function syncPlayPing($sync_play_ping_request, string $contentType = self::contentTypes['syncPlayPing'][0])
    {
        $this->syncPlayPingWithHttpInfo($sync_play_ping_request, $contentType);
    }

    /**
     * Operation syncPlayPingWithHttpInfo
     *
     * Update session ping.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayPingRequest $sync_play_ping_request The new ping. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayPing'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function syncPlayPingWithHttpInfo($sync_play_ping_request, string $contentType = self::contentTypes['syncPlayPing'][0])
    {
        $request = $this->syncPlayPingRequest($sync_play_ping_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation syncPlayPingAsync
     *
     * Update session ping.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayPingRequest $sync_play_ping_request The new ping. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayPing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayPingAsync($sync_play_ping_request, string $contentType = self::contentTypes['syncPlayPing'][0])
    {
        return $this->syncPlayPingAsyncWithHttpInfo($sync_play_ping_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation syncPlayPingAsyncWithHttpInfo
     *
     * Update session ping.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayPingRequest $sync_play_ping_request The new ping. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayPing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayPingAsyncWithHttpInfo($sync_play_ping_request, string $contentType = self::contentTypes['syncPlayPing'][0])
    {
        $returnType = '';
        $request = $this->syncPlayPingRequest($sync_play_ping_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'syncPlayPing'
     *
     * @param  \OpenAPI\Client\Model\SyncPlayPingRequest $sync_play_ping_request The new ping. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayPing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function syncPlayPingRequest($sync_play_ping_request, string $contentType = self::contentTypes['syncPlayPing'][0])
    {

        // verify the required parameter 'sync_play_ping_request' is set
        if ($sync_play_ping_request === null || (is_array($sync_play_ping_request) && count($sync_play_ping_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sync_play_ping_request when calling syncPlayPing'
            );
        }


        $resourcePath = '/SyncPlay/Ping';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($sync_play_ping_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($sync_play_ping_request));
            } else {
                $httpBody = $sync_play_ping_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation syncPlayPreviousItem
     *
     * Request previous item in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayPreviousItemRequest $sync_play_previous_item_request The current item information. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayPreviousItem'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function syncPlayPreviousItem($sync_play_previous_item_request, string $contentType = self::contentTypes['syncPlayPreviousItem'][0])
    {
        $this->syncPlayPreviousItemWithHttpInfo($sync_play_previous_item_request, $contentType);
    }

    /**
     * Operation syncPlayPreviousItemWithHttpInfo
     *
     * Request previous item in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayPreviousItemRequest $sync_play_previous_item_request The current item information. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayPreviousItem'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function syncPlayPreviousItemWithHttpInfo($sync_play_previous_item_request, string $contentType = self::contentTypes['syncPlayPreviousItem'][0])
    {
        $request = $this->syncPlayPreviousItemRequest($sync_play_previous_item_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation syncPlayPreviousItemAsync
     *
     * Request previous item in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayPreviousItemRequest $sync_play_previous_item_request The current item information. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayPreviousItem'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayPreviousItemAsync($sync_play_previous_item_request, string $contentType = self::contentTypes['syncPlayPreviousItem'][0])
    {
        return $this->syncPlayPreviousItemAsyncWithHttpInfo($sync_play_previous_item_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation syncPlayPreviousItemAsyncWithHttpInfo
     *
     * Request previous item in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayPreviousItemRequest $sync_play_previous_item_request The current item information. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayPreviousItem'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayPreviousItemAsyncWithHttpInfo($sync_play_previous_item_request, string $contentType = self::contentTypes['syncPlayPreviousItem'][0])
    {
        $returnType = '';
        $request = $this->syncPlayPreviousItemRequest($sync_play_previous_item_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'syncPlayPreviousItem'
     *
     * @param  \OpenAPI\Client\Model\SyncPlayPreviousItemRequest $sync_play_previous_item_request The current item information. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayPreviousItem'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function syncPlayPreviousItemRequest($sync_play_previous_item_request, string $contentType = self::contentTypes['syncPlayPreviousItem'][0])
    {

        // verify the required parameter 'sync_play_previous_item_request' is set
        if ($sync_play_previous_item_request === null || (is_array($sync_play_previous_item_request) && count($sync_play_previous_item_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sync_play_previous_item_request when calling syncPlayPreviousItem'
            );
        }


        $resourcePath = '/SyncPlay/PreviousItem';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($sync_play_previous_item_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($sync_play_previous_item_request));
            } else {
                $httpBody = $sync_play_previous_item_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation syncPlayQueue
     *
     * Request to queue items to the playlist of a SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayQueueRequest $sync_play_queue_request The items to add. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayQueue'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function syncPlayQueue($sync_play_queue_request, string $contentType = self::contentTypes['syncPlayQueue'][0])
    {
        $this->syncPlayQueueWithHttpInfo($sync_play_queue_request, $contentType);
    }

    /**
     * Operation syncPlayQueueWithHttpInfo
     *
     * Request to queue items to the playlist of a SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayQueueRequest $sync_play_queue_request The items to add. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayQueue'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function syncPlayQueueWithHttpInfo($sync_play_queue_request, string $contentType = self::contentTypes['syncPlayQueue'][0])
    {
        $request = $this->syncPlayQueueRequest($sync_play_queue_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation syncPlayQueueAsync
     *
     * Request to queue items to the playlist of a SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayQueueRequest $sync_play_queue_request The items to add. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayQueue'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayQueueAsync($sync_play_queue_request, string $contentType = self::contentTypes['syncPlayQueue'][0])
    {
        return $this->syncPlayQueueAsyncWithHttpInfo($sync_play_queue_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation syncPlayQueueAsyncWithHttpInfo
     *
     * Request to queue items to the playlist of a SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayQueueRequest $sync_play_queue_request The items to add. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayQueue'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayQueueAsyncWithHttpInfo($sync_play_queue_request, string $contentType = self::contentTypes['syncPlayQueue'][0])
    {
        $returnType = '';
        $request = $this->syncPlayQueueRequest($sync_play_queue_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'syncPlayQueue'
     *
     * @param  \OpenAPI\Client\Model\SyncPlayQueueRequest $sync_play_queue_request The items to add. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayQueue'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function syncPlayQueueRequest($sync_play_queue_request, string $contentType = self::contentTypes['syncPlayQueue'][0])
    {

        // verify the required parameter 'sync_play_queue_request' is set
        if ($sync_play_queue_request === null || (is_array($sync_play_queue_request) && count($sync_play_queue_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sync_play_queue_request when calling syncPlayQueue'
            );
        }


        $resourcePath = '/SyncPlay/Queue';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($sync_play_queue_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($sync_play_queue_request));
            } else {
                $httpBody = $sync_play_queue_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation syncPlayReady
     *
     * Notify SyncPlay group that member is ready for playback.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayReadyRequest $sync_play_ready_request The player status. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayReady'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function syncPlayReady($sync_play_ready_request, string $contentType = self::contentTypes['syncPlayReady'][0])
    {
        $this->syncPlayReadyWithHttpInfo($sync_play_ready_request, $contentType);
    }

    /**
     * Operation syncPlayReadyWithHttpInfo
     *
     * Notify SyncPlay group that member is ready for playback.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayReadyRequest $sync_play_ready_request The player status. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayReady'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function syncPlayReadyWithHttpInfo($sync_play_ready_request, string $contentType = self::contentTypes['syncPlayReady'][0])
    {
        $request = $this->syncPlayReadyRequest($sync_play_ready_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation syncPlayReadyAsync
     *
     * Notify SyncPlay group that member is ready for playback.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayReadyRequest $sync_play_ready_request The player status. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayReady'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayReadyAsync($sync_play_ready_request, string $contentType = self::contentTypes['syncPlayReady'][0])
    {
        return $this->syncPlayReadyAsyncWithHttpInfo($sync_play_ready_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation syncPlayReadyAsyncWithHttpInfo
     *
     * Notify SyncPlay group that member is ready for playback.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayReadyRequest $sync_play_ready_request The player status. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayReady'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayReadyAsyncWithHttpInfo($sync_play_ready_request, string $contentType = self::contentTypes['syncPlayReady'][0])
    {
        $returnType = '';
        $request = $this->syncPlayReadyRequest($sync_play_ready_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'syncPlayReady'
     *
     * @param  \OpenAPI\Client\Model\SyncPlayReadyRequest $sync_play_ready_request The player status. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayReady'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function syncPlayReadyRequest($sync_play_ready_request, string $contentType = self::contentTypes['syncPlayReady'][0])
    {

        // verify the required parameter 'sync_play_ready_request' is set
        if ($sync_play_ready_request === null || (is_array($sync_play_ready_request) && count($sync_play_ready_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sync_play_ready_request when calling syncPlayReady'
            );
        }


        $resourcePath = '/SyncPlay/Ready';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($sync_play_ready_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($sync_play_ready_request));
            } else {
                $httpBody = $sync_play_ready_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation syncPlayRemoveFromPlaylist
     *
     * Request to remove items from the playlist in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayRemoveFromPlaylistRequest $sync_play_remove_from_playlist_request The items to remove. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayRemoveFromPlaylist'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function syncPlayRemoveFromPlaylist($sync_play_remove_from_playlist_request, string $contentType = self::contentTypes['syncPlayRemoveFromPlaylist'][0])
    {
        $this->syncPlayRemoveFromPlaylistWithHttpInfo($sync_play_remove_from_playlist_request, $contentType);
    }

    /**
     * Operation syncPlayRemoveFromPlaylistWithHttpInfo
     *
     * Request to remove items from the playlist in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayRemoveFromPlaylistRequest $sync_play_remove_from_playlist_request The items to remove. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayRemoveFromPlaylist'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function syncPlayRemoveFromPlaylistWithHttpInfo($sync_play_remove_from_playlist_request, string $contentType = self::contentTypes['syncPlayRemoveFromPlaylist'][0])
    {
        $request = $this->syncPlayRemoveFromPlaylistRequest($sync_play_remove_from_playlist_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation syncPlayRemoveFromPlaylistAsync
     *
     * Request to remove items from the playlist in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayRemoveFromPlaylistRequest $sync_play_remove_from_playlist_request The items to remove. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayRemoveFromPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayRemoveFromPlaylistAsync($sync_play_remove_from_playlist_request, string $contentType = self::contentTypes['syncPlayRemoveFromPlaylist'][0])
    {
        return $this->syncPlayRemoveFromPlaylistAsyncWithHttpInfo($sync_play_remove_from_playlist_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation syncPlayRemoveFromPlaylistAsyncWithHttpInfo
     *
     * Request to remove items from the playlist in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlayRemoveFromPlaylistRequest $sync_play_remove_from_playlist_request The items to remove. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayRemoveFromPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayRemoveFromPlaylistAsyncWithHttpInfo($sync_play_remove_from_playlist_request, string $contentType = self::contentTypes['syncPlayRemoveFromPlaylist'][0])
    {
        $returnType = '';
        $request = $this->syncPlayRemoveFromPlaylistRequest($sync_play_remove_from_playlist_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'syncPlayRemoveFromPlaylist'
     *
     * @param  \OpenAPI\Client\Model\SyncPlayRemoveFromPlaylistRequest $sync_play_remove_from_playlist_request The items to remove. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayRemoveFromPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function syncPlayRemoveFromPlaylistRequest($sync_play_remove_from_playlist_request, string $contentType = self::contentTypes['syncPlayRemoveFromPlaylist'][0])
    {

        // verify the required parameter 'sync_play_remove_from_playlist_request' is set
        if ($sync_play_remove_from_playlist_request === null || (is_array($sync_play_remove_from_playlist_request) && count($sync_play_remove_from_playlist_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sync_play_remove_from_playlist_request when calling syncPlayRemoveFromPlaylist'
            );
        }


        $resourcePath = '/SyncPlay/RemoveFromPlaylist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($sync_play_remove_from_playlist_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($sync_play_remove_from_playlist_request));
            } else {
                $httpBody = $sync_play_remove_from_playlist_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation syncPlaySeek
     *
     * Request seek in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySeekRequest $sync_play_seek_request The new playback position. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySeek'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function syncPlaySeek($sync_play_seek_request, string $contentType = self::contentTypes['syncPlaySeek'][0])
    {
        $this->syncPlaySeekWithHttpInfo($sync_play_seek_request, $contentType);
    }

    /**
     * Operation syncPlaySeekWithHttpInfo
     *
     * Request seek in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySeekRequest $sync_play_seek_request The new playback position. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySeek'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function syncPlaySeekWithHttpInfo($sync_play_seek_request, string $contentType = self::contentTypes['syncPlaySeek'][0])
    {
        $request = $this->syncPlaySeekRequest($sync_play_seek_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation syncPlaySeekAsync
     *
     * Request seek in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySeekRequest $sync_play_seek_request The new playback position. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySeek'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlaySeekAsync($sync_play_seek_request, string $contentType = self::contentTypes['syncPlaySeek'][0])
    {
        return $this->syncPlaySeekAsyncWithHttpInfo($sync_play_seek_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation syncPlaySeekAsyncWithHttpInfo
     *
     * Request seek in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySeekRequest $sync_play_seek_request The new playback position. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySeek'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlaySeekAsyncWithHttpInfo($sync_play_seek_request, string $contentType = self::contentTypes['syncPlaySeek'][0])
    {
        $returnType = '';
        $request = $this->syncPlaySeekRequest($sync_play_seek_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'syncPlaySeek'
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySeekRequest $sync_play_seek_request The new playback position. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySeek'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function syncPlaySeekRequest($sync_play_seek_request, string $contentType = self::contentTypes['syncPlaySeek'][0])
    {

        // verify the required parameter 'sync_play_seek_request' is set
        if ($sync_play_seek_request === null || (is_array($sync_play_seek_request) && count($sync_play_seek_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sync_play_seek_request when calling syncPlaySeek'
            );
        }


        $resourcePath = '/SyncPlay/Seek';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($sync_play_seek_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($sync_play_seek_request));
            } else {
                $httpBody = $sync_play_seek_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation syncPlaySetIgnoreWait
     *
     * Request SyncPlay group to ignore member during group-wait.
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySetIgnoreWaitRequest $sync_play_set_ignore_wait_request The settings to set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySetIgnoreWait'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function syncPlaySetIgnoreWait($sync_play_set_ignore_wait_request, string $contentType = self::contentTypes['syncPlaySetIgnoreWait'][0])
    {
        $this->syncPlaySetIgnoreWaitWithHttpInfo($sync_play_set_ignore_wait_request, $contentType);
    }

    /**
     * Operation syncPlaySetIgnoreWaitWithHttpInfo
     *
     * Request SyncPlay group to ignore member during group-wait.
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySetIgnoreWaitRequest $sync_play_set_ignore_wait_request The settings to set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySetIgnoreWait'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function syncPlaySetIgnoreWaitWithHttpInfo($sync_play_set_ignore_wait_request, string $contentType = self::contentTypes['syncPlaySetIgnoreWait'][0])
    {
        $request = $this->syncPlaySetIgnoreWaitRequest($sync_play_set_ignore_wait_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation syncPlaySetIgnoreWaitAsync
     *
     * Request SyncPlay group to ignore member during group-wait.
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySetIgnoreWaitRequest $sync_play_set_ignore_wait_request The settings to set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySetIgnoreWait'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlaySetIgnoreWaitAsync($sync_play_set_ignore_wait_request, string $contentType = self::contentTypes['syncPlaySetIgnoreWait'][0])
    {
        return $this->syncPlaySetIgnoreWaitAsyncWithHttpInfo($sync_play_set_ignore_wait_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation syncPlaySetIgnoreWaitAsyncWithHttpInfo
     *
     * Request SyncPlay group to ignore member during group-wait.
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySetIgnoreWaitRequest $sync_play_set_ignore_wait_request The settings to set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySetIgnoreWait'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlaySetIgnoreWaitAsyncWithHttpInfo($sync_play_set_ignore_wait_request, string $contentType = self::contentTypes['syncPlaySetIgnoreWait'][0])
    {
        $returnType = '';
        $request = $this->syncPlaySetIgnoreWaitRequest($sync_play_set_ignore_wait_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'syncPlaySetIgnoreWait'
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySetIgnoreWaitRequest $sync_play_set_ignore_wait_request The settings to set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySetIgnoreWait'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function syncPlaySetIgnoreWaitRequest($sync_play_set_ignore_wait_request, string $contentType = self::contentTypes['syncPlaySetIgnoreWait'][0])
    {

        // verify the required parameter 'sync_play_set_ignore_wait_request' is set
        if ($sync_play_set_ignore_wait_request === null || (is_array($sync_play_set_ignore_wait_request) && count($sync_play_set_ignore_wait_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sync_play_set_ignore_wait_request when calling syncPlaySetIgnoreWait'
            );
        }


        $resourcePath = '/SyncPlay/SetIgnoreWait';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($sync_play_set_ignore_wait_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($sync_play_set_ignore_wait_request));
            } else {
                $httpBody = $sync_play_set_ignore_wait_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation syncPlaySetNewQueue
     *
     * Request to set new playlist in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySetNewQueueRequest $sync_play_set_new_queue_request The new playlist to play in the group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySetNewQueue'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function syncPlaySetNewQueue($sync_play_set_new_queue_request, string $contentType = self::contentTypes['syncPlaySetNewQueue'][0])
    {
        $this->syncPlaySetNewQueueWithHttpInfo($sync_play_set_new_queue_request, $contentType);
    }

    /**
     * Operation syncPlaySetNewQueueWithHttpInfo
     *
     * Request to set new playlist in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySetNewQueueRequest $sync_play_set_new_queue_request The new playlist to play in the group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySetNewQueue'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function syncPlaySetNewQueueWithHttpInfo($sync_play_set_new_queue_request, string $contentType = self::contentTypes['syncPlaySetNewQueue'][0])
    {
        $request = $this->syncPlaySetNewQueueRequest($sync_play_set_new_queue_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation syncPlaySetNewQueueAsync
     *
     * Request to set new playlist in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySetNewQueueRequest $sync_play_set_new_queue_request The new playlist to play in the group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySetNewQueue'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlaySetNewQueueAsync($sync_play_set_new_queue_request, string $contentType = self::contentTypes['syncPlaySetNewQueue'][0])
    {
        return $this->syncPlaySetNewQueueAsyncWithHttpInfo($sync_play_set_new_queue_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation syncPlaySetNewQueueAsyncWithHttpInfo
     *
     * Request to set new playlist in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySetNewQueueRequest $sync_play_set_new_queue_request The new playlist to play in the group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySetNewQueue'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlaySetNewQueueAsyncWithHttpInfo($sync_play_set_new_queue_request, string $contentType = self::contentTypes['syncPlaySetNewQueue'][0])
    {
        $returnType = '';
        $request = $this->syncPlaySetNewQueueRequest($sync_play_set_new_queue_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'syncPlaySetNewQueue'
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySetNewQueueRequest $sync_play_set_new_queue_request The new playlist to play in the group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySetNewQueue'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function syncPlaySetNewQueueRequest($sync_play_set_new_queue_request, string $contentType = self::contentTypes['syncPlaySetNewQueue'][0])
    {

        // verify the required parameter 'sync_play_set_new_queue_request' is set
        if ($sync_play_set_new_queue_request === null || (is_array($sync_play_set_new_queue_request) && count($sync_play_set_new_queue_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sync_play_set_new_queue_request when calling syncPlaySetNewQueue'
            );
        }


        $resourcePath = '/SyncPlay/SetNewQueue';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($sync_play_set_new_queue_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($sync_play_set_new_queue_request));
            } else {
                $httpBody = $sync_play_set_new_queue_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation syncPlaySetPlaylistItem
     *
     * Request to change playlist item in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySetPlaylistItemRequest $sync_play_set_playlist_item_request The new item to play. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySetPlaylistItem'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function syncPlaySetPlaylistItem($sync_play_set_playlist_item_request, string $contentType = self::contentTypes['syncPlaySetPlaylistItem'][0])
    {
        $this->syncPlaySetPlaylistItemWithHttpInfo($sync_play_set_playlist_item_request, $contentType);
    }

    /**
     * Operation syncPlaySetPlaylistItemWithHttpInfo
     *
     * Request to change playlist item in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySetPlaylistItemRequest $sync_play_set_playlist_item_request The new item to play. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySetPlaylistItem'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function syncPlaySetPlaylistItemWithHttpInfo($sync_play_set_playlist_item_request, string $contentType = self::contentTypes['syncPlaySetPlaylistItem'][0])
    {
        $request = $this->syncPlaySetPlaylistItemRequest($sync_play_set_playlist_item_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation syncPlaySetPlaylistItemAsync
     *
     * Request to change playlist item in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySetPlaylistItemRequest $sync_play_set_playlist_item_request The new item to play. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySetPlaylistItem'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlaySetPlaylistItemAsync($sync_play_set_playlist_item_request, string $contentType = self::contentTypes['syncPlaySetPlaylistItem'][0])
    {
        return $this->syncPlaySetPlaylistItemAsyncWithHttpInfo($sync_play_set_playlist_item_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation syncPlaySetPlaylistItemAsyncWithHttpInfo
     *
     * Request to change playlist item in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySetPlaylistItemRequest $sync_play_set_playlist_item_request The new item to play. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySetPlaylistItem'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlaySetPlaylistItemAsyncWithHttpInfo($sync_play_set_playlist_item_request, string $contentType = self::contentTypes['syncPlaySetPlaylistItem'][0])
    {
        $returnType = '';
        $request = $this->syncPlaySetPlaylistItemRequest($sync_play_set_playlist_item_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'syncPlaySetPlaylistItem'
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySetPlaylistItemRequest $sync_play_set_playlist_item_request The new item to play. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySetPlaylistItem'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function syncPlaySetPlaylistItemRequest($sync_play_set_playlist_item_request, string $contentType = self::contentTypes['syncPlaySetPlaylistItem'][0])
    {

        // verify the required parameter 'sync_play_set_playlist_item_request' is set
        if ($sync_play_set_playlist_item_request === null || (is_array($sync_play_set_playlist_item_request) && count($sync_play_set_playlist_item_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sync_play_set_playlist_item_request when calling syncPlaySetPlaylistItem'
            );
        }


        $resourcePath = '/SyncPlay/SetPlaylistItem';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($sync_play_set_playlist_item_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($sync_play_set_playlist_item_request));
            } else {
                $httpBody = $sync_play_set_playlist_item_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation syncPlaySetRepeatMode
     *
     * Request to set repeat mode in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySetRepeatModeRequest $sync_play_set_repeat_mode_request The new repeat mode. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySetRepeatMode'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function syncPlaySetRepeatMode($sync_play_set_repeat_mode_request, string $contentType = self::contentTypes['syncPlaySetRepeatMode'][0])
    {
        $this->syncPlaySetRepeatModeWithHttpInfo($sync_play_set_repeat_mode_request, $contentType);
    }

    /**
     * Operation syncPlaySetRepeatModeWithHttpInfo
     *
     * Request to set repeat mode in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySetRepeatModeRequest $sync_play_set_repeat_mode_request The new repeat mode. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySetRepeatMode'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function syncPlaySetRepeatModeWithHttpInfo($sync_play_set_repeat_mode_request, string $contentType = self::contentTypes['syncPlaySetRepeatMode'][0])
    {
        $request = $this->syncPlaySetRepeatModeRequest($sync_play_set_repeat_mode_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation syncPlaySetRepeatModeAsync
     *
     * Request to set repeat mode in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySetRepeatModeRequest $sync_play_set_repeat_mode_request The new repeat mode. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySetRepeatMode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlaySetRepeatModeAsync($sync_play_set_repeat_mode_request, string $contentType = self::contentTypes['syncPlaySetRepeatMode'][0])
    {
        return $this->syncPlaySetRepeatModeAsyncWithHttpInfo($sync_play_set_repeat_mode_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation syncPlaySetRepeatModeAsyncWithHttpInfo
     *
     * Request to set repeat mode in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySetRepeatModeRequest $sync_play_set_repeat_mode_request The new repeat mode. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySetRepeatMode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlaySetRepeatModeAsyncWithHttpInfo($sync_play_set_repeat_mode_request, string $contentType = self::contentTypes['syncPlaySetRepeatMode'][0])
    {
        $returnType = '';
        $request = $this->syncPlaySetRepeatModeRequest($sync_play_set_repeat_mode_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'syncPlaySetRepeatMode'
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySetRepeatModeRequest $sync_play_set_repeat_mode_request The new repeat mode. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySetRepeatMode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function syncPlaySetRepeatModeRequest($sync_play_set_repeat_mode_request, string $contentType = self::contentTypes['syncPlaySetRepeatMode'][0])
    {

        // verify the required parameter 'sync_play_set_repeat_mode_request' is set
        if ($sync_play_set_repeat_mode_request === null || (is_array($sync_play_set_repeat_mode_request) && count($sync_play_set_repeat_mode_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sync_play_set_repeat_mode_request when calling syncPlaySetRepeatMode'
            );
        }


        $resourcePath = '/SyncPlay/SetRepeatMode';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($sync_play_set_repeat_mode_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($sync_play_set_repeat_mode_request));
            } else {
                $httpBody = $sync_play_set_repeat_mode_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation syncPlaySetShuffleMode
     *
     * Request to set shuffle mode in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySetShuffleModeRequest $sync_play_set_shuffle_mode_request The new shuffle mode. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySetShuffleMode'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function syncPlaySetShuffleMode($sync_play_set_shuffle_mode_request, string $contentType = self::contentTypes['syncPlaySetShuffleMode'][0])
    {
        $this->syncPlaySetShuffleModeWithHttpInfo($sync_play_set_shuffle_mode_request, $contentType);
    }

    /**
     * Operation syncPlaySetShuffleModeWithHttpInfo
     *
     * Request to set shuffle mode in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySetShuffleModeRequest $sync_play_set_shuffle_mode_request The new shuffle mode. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySetShuffleMode'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function syncPlaySetShuffleModeWithHttpInfo($sync_play_set_shuffle_mode_request, string $contentType = self::contentTypes['syncPlaySetShuffleMode'][0])
    {
        $request = $this->syncPlaySetShuffleModeRequest($sync_play_set_shuffle_mode_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation syncPlaySetShuffleModeAsync
     *
     * Request to set shuffle mode in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySetShuffleModeRequest $sync_play_set_shuffle_mode_request The new shuffle mode. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySetShuffleMode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlaySetShuffleModeAsync($sync_play_set_shuffle_mode_request, string $contentType = self::contentTypes['syncPlaySetShuffleMode'][0])
    {
        return $this->syncPlaySetShuffleModeAsyncWithHttpInfo($sync_play_set_shuffle_mode_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation syncPlaySetShuffleModeAsyncWithHttpInfo
     *
     * Request to set shuffle mode in SyncPlay group.
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySetShuffleModeRequest $sync_play_set_shuffle_mode_request The new shuffle mode. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySetShuffleMode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlaySetShuffleModeAsyncWithHttpInfo($sync_play_set_shuffle_mode_request, string $contentType = self::contentTypes['syncPlaySetShuffleMode'][0])
    {
        $returnType = '';
        $request = $this->syncPlaySetShuffleModeRequest($sync_play_set_shuffle_mode_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'syncPlaySetShuffleMode'
     *
     * @param  \OpenAPI\Client\Model\SyncPlaySetShuffleModeRequest $sync_play_set_shuffle_mode_request The new shuffle mode. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlaySetShuffleMode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function syncPlaySetShuffleModeRequest($sync_play_set_shuffle_mode_request, string $contentType = self::contentTypes['syncPlaySetShuffleMode'][0])
    {

        // verify the required parameter 'sync_play_set_shuffle_mode_request' is set
        if ($sync_play_set_shuffle_mode_request === null || (is_array($sync_play_set_shuffle_mode_request) && count($sync_play_set_shuffle_mode_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sync_play_set_shuffle_mode_request when calling syncPlaySetShuffleMode'
            );
        }


        $resourcePath = '/SyncPlay/SetShuffleMode';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($sync_play_set_shuffle_mode_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($sync_play_set_shuffle_mode_request));
            } else {
                $httpBody = $sync_play_set_shuffle_mode_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation syncPlayStop
     *
     * Request stop in SyncPlay group.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayStop'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function syncPlayStop(string $contentType = self::contentTypes['syncPlayStop'][0])
    {
        $this->syncPlayStopWithHttpInfo($contentType);
    }

    /**
     * Operation syncPlayStopWithHttpInfo
     *
     * Request stop in SyncPlay group.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayStop'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function syncPlayStopWithHttpInfo(string $contentType = self::contentTypes['syncPlayStop'][0])
    {
        $request = $this->syncPlayStopRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation syncPlayStopAsync
     *
     * Request stop in SyncPlay group.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayStop'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayStopAsync(string $contentType = self::contentTypes['syncPlayStop'][0])
    {
        return $this->syncPlayStopAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation syncPlayStopAsyncWithHttpInfo
     *
     * Request stop in SyncPlay group.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayStop'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayStopAsyncWithHttpInfo(string $contentType = self::contentTypes['syncPlayStop'][0])
    {
        $returnType = '';
        $request = $this->syncPlayStopRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'syncPlayStop'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayStop'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function syncPlayStopRequest(string $contentType = self::contentTypes['syncPlayStop'][0])
    {


        $resourcePath = '/SyncPlay/Stop';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation syncPlayUnpause
     *
     * Request unpause in SyncPlay group.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayUnpause'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function syncPlayUnpause(string $contentType = self::contentTypes['syncPlayUnpause'][0])
    {
        $this->syncPlayUnpauseWithHttpInfo($contentType);
    }

    /**
     * Operation syncPlayUnpauseWithHttpInfo
     *
     * Request unpause in SyncPlay group.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayUnpause'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function syncPlayUnpauseWithHttpInfo(string $contentType = self::contentTypes['syncPlayUnpause'][0])
    {
        $request = $this->syncPlayUnpauseRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation syncPlayUnpauseAsync
     *
     * Request unpause in SyncPlay group.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayUnpause'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayUnpauseAsync(string $contentType = self::contentTypes['syncPlayUnpause'][0])
    {
        return $this->syncPlayUnpauseAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation syncPlayUnpauseAsyncWithHttpInfo
     *
     * Request unpause in SyncPlay group.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayUnpause'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncPlayUnpauseAsyncWithHttpInfo(string $contentType = self::contentTypes['syncPlayUnpause'][0])
    {
        $returnType = '';
        $request = $this->syncPlayUnpauseRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'syncPlayUnpause'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncPlayUnpause'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function syncPlayUnpauseRequest(string $contentType = self::contentTypes['syncPlayUnpause'][0])
    {


        $resourcePath = '/SyncPlay/Unpause';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
