<?php
/**
 * DynamicHlsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Jellyfin API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 10.8.10
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.0.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * DynamicHlsApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DynamicHlsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'getHlsAudioSegment' => [
            'application/json',
        ],
        'getHlsVideoSegment' => [
            'application/json',
        ],
        'getLiveHlsStream' => [
            'application/json',
        ],
        'getMasterHlsAudioPlaylist' => [
            'application/json',
        ],
        'getMasterHlsVideoPlaylist' => [
            'application/json',
        ],
        'getVariantHlsAudioPlaylist' => [
            'application/json',
        ],
        'getVariantHlsVideoPlaylist' => [
            'application/json',
        ],
        'headMasterHlsAudioPlaylist' => [
            'application/json',
        ],
        'headMasterHlsVideoPlaylist' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getHlsAudioSegment
     *
     * Gets a video stream using HTTP live streaming.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $playlist_id The playlist id. (required)
     * @param  int $segment_id The segment id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param  int $runtime_ticks The position of the requested segment in ticks. (required)
     * @param  int $actual_segment_length_ticks The length of the requested segment in ticks. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $max_streaming_bitrate Optional. The maximum streaming bitrate. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getHlsAudioSegment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getHlsAudioSegment($item_id, $playlist_id, $segment_id, $container, $runtime_ticks, $actual_segment_length_ticks, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $max_streaming_bitrate = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getHlsAudioSegment'][0])
    {
        list($response) = $this->getHlsAudioSegmentWithHttpInfo($item_id, $playlist_id, $segment_id, $container, $runtime_ticks, $actual_segment_length_ticks, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $max_streaming_bitrate, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType);
        return $response;
    }

    /**
     * Operation getHlsAudioSegmentWithHttpInfo
     *
     * Gets a video stream using HTTP live streaming.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $playlist_id The playlist id. (required)
     * @param  int $segment_id The segment id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param  int $runtime_ticks The position of the requested segment in ticks. (required)
     * @param  int $actual_segment_length_ticks The length of the requested segment in ticks. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $max_streaming_bitrate Optional. The maximum streaming bitrate. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getHlsAudioSegment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHlsAudioSegmentWithHttpInfo($item_id, $playlist_id, $segment_id, $container, $runtime_ticks, $actual_segment_length_ticks, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $max_streaming_bitrate = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getHlsAudioSegment'][0])
    {
        $request = $this->getHlsAudioSegmentRequest($item_id, $playlist_id, $segment_id, $container, $runtime_ticks, $actual_segment_length_ticks, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $max_streaming_bitrate, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHlsAudioSegmentAsync
     *
     * Gets a video stream using HTTP live streaming.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $playlist_id The playlist id. (required)
     * @param  int $segment_id The segment id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param  int $runtime_ticks The position of the requested segment in ticks. (required)
     * @param  int $actual_segment_length_ticks The length of the requested segment in ticks. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $max_streaming_bitrate Optional. The maximum streaming bitrate. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getHlsAudioSegment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHlsAudioSegmentAsync($item_id, $playlist_id, $segment_id, $container, $runtime_ticks, $actual_segment_length_ticks, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $max_streaming_bitrate = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getHlsAudioSegment'][0])
    {
        return $this->getHlsAudioSegmentAsyncWithHttpInfo($item_id, $playlist_id, $segment_id, $container, $runtime_ticks, $actual_segment_length_ticks, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $max_streaming_bitrate, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHlsAudioSegmentAsyncWithHttpInfo
     *
     * Gets a video stream using HTTP live streaming.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $playlist_id The playlist id. (required)
     * @param  int $segment_id The segment id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param  int $runtime_ticks The position of the requested segment in ticks. (required)
     * @param  int $actual_segment_length_ticks The length of the requested segment in ticks. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $max_streaming_bitrate Optional. The maximum streaming bitrate. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getHlsAudioSegment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHlsAudioSegmentAsyncWithHttpInfo($item_id, $playlist_id, $segment_id, $container, $runtime_ticks, $actual_segment_length_ticks, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $max_streaming_bitrate = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getHlsAudioSegment'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getHlsAudioSegmentRequest($item_id, $playlist_id, $segment_id, $container, $runtime_ticks, $actual_segment_length_ticks, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $max_streaming_bitrate, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHlsAudioSegment'
     *
     * @param  string $item_id The item id. (required)
     * @param  string $playlist_id The playlist id. (required)
     * @param  int $segment_id The segment id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param  int $runtime_ticks The position of the requested segment in ticks. (required)
     * @param  int $actual_segment_length_ticks The length of the requested segment in ticks. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $max_streaming_bitrate Optional. The maximum streaming bitrate. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getHlsAudioSegment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getHlsAudioSegmentRequest($item_id, $playlist_id, $segment_id, $container, $runtime_ticks, $actual_segment_length_ticks, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $max_streaming_bitrate = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getHlsAudioSegment'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling getHlsAudioSegment'
            );
        }

        // verify the required parameter 'playlist_id' is set
        if ($playlist_id === null || (is_array($playlist_id) && count($playlist_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $playlist_id when calling getHlsAudioSegment'
            );
        }

        // verify the required parameter 'segment_id' is set
        if ($segment_id === null || (is_array($segment_id) && count($segment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $segment_id when calling getHlsAudioSegment'
            );
        }

        // verify the required parameter 'container' is set
        if ($container === null || (is_array($container) && count($container) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $container when calling getHlsAudioSegment'
            );
        }

        // verify the required parameter 'runtime_ticks' is set
        if ($runtime_ticks === null || (is_array($runtime_ticks) && count($runtime_ticks) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runtime_ticks when calling getHlsAudioSegment'
            );
        }

        // verify the required parameter 'actual_segment_length_ticks' is set
        if ($actual_segment_length_ticks === null || (is_array($actual_segment_length_ticks) && count($actual_segment_length_ticks) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actual_segment_length_ticks when calling getHlsAudioSegment'
            );
        }


















































        $resourcePath = '/Audio/{itemId}/hls1/{playlistId}/{segmentId}.{container}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $runtime_ticks,
            'runtimeTicks', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $actual_segment_length_ticks,
            'actualSegmentLengthTicks', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $static,
            'static', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $params,
            'params', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_profile_id,
            'deviceProfileId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $play_session_id,
            'playSessionId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $segment_container,
            'segmentContainer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $segment_length,
            'segmentLength', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_segments,
            'minSegments', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_source_id,
            'mediaSourceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_codec,
            'audioCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_auto_stream_copy,
            'enableAutoStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_video_stream_copy,
            'allowVideoStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_audio_stream_copy,
            'allowAudioStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $break_on_non_key_frames,
            'breakOnNonKeyFrames', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_sample_rate,
            'audioSampleRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_audio_bit_depth,
            'maxAudioBitDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_streaming_bitrate,
            'maxStreamingBitrate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_bit_rate,
            'audioBitRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_channels,
            'audioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_audio_channels,
            'maxAudioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $profile,
            'profile', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $framerate,
            'framerate', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_framerate,
            'maxFramerate', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $copy_timestamps,
            'copyTimestamps', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_time_ticks,
            'startTimeTicks', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_bit_rate,
            'videoBitRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_stream_index,
            'subtitleStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_method,
            'subtitleMethod', // param base name
            'SubtitleDeliveryMethod', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_ref_frames,
            'maxRefFrames', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_video_bit_depth,
            'maxVideoBitDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $require_avc,
            'requireAvc', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $de_interlace,
            'deInterlace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $require_non_anamorphic,
            'requireNonAnamorphic', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcoding_max_audio_channels,
            'transcodingMaxAudioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cpu_core_limit,
            'cpuCoreLimit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $live_stream_id,
            'liveStreamId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_mpegts_m2_ts_mode,
            'enableMpegtsM2TsMode', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_codec,
            'videoCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_codec,
            'subtitleCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcode_reasons,
            'transcodeReasons', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_stream_index,
            'audioStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_stream_index,
            'videoStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'EncodingContext', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stream_options,
            'streamOptions', // param base name
            'object', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($playlist_id !== null) {
            $resourcePath = str_replace(
                '{' . 'playlistId' . '}',
                ObjectSerializer::toPathValue($playlist_id),
                $resourcePath
            );
        }
        // path params
        if ($segment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'segmentId' . '}',
                ObjectSerializer::toPathValue($segment_id),
                $resourcePath
            );
        }
        // path params
        if ($container !== null) {
            $resourcePath = str_replace(
                '{' . 'container' . '}',
                ObjectSerializer::toPathValue($container),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['audio/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Emby-Token');
        if ($apiKey !== null) {
            $headers['X-Emby-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHlsVideoSegment
     *
     * Gets a video stream using HTTP live streaming.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $playlist_id The playlist id. (required)
     * @param  int $segment_id The segment id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param  int $runtime_ticks The position of the requested segment in ticks. (required)
     * @param  int $actual_segment_length_ticks The length of the requested segment in ticks. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The desired segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getHlsVideoSegment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getHlsVideoSegment($item_id, $playlist_id, $segment_id, $container, $runtime_ticks, $actual_segment_length_ticks, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getHlsVideoSegment'][0])
    {
        list($response) = $this->getHlsVideoSegmentWithHttpInfo($item_id, $playlist_id, $segment_id, $container, $runtime_ticks, $actual_segment_length_ticks, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType);
        return $response;
    }

    /**
     * Operation getHlsVideoSegmentWithHttpInfo
     *
     * Gets a video stream using HTTP live streaming.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $playlist_id The playlist id. (required)
     * @param  int $segment_id The segment id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param  int $runtime_ticks The position of the requested segment in ticks. (required)
     * @param  int $actual_segment_length_ticks The length of the requested segment in ticks. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The desired segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getHlsVideoSegment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHlsVideoSegmentWithHttpInfo($item_id, $playlist_id, $segment_id, $container, $runtime_ticks, $actual_segment_length_ticks, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getHlsVideoSegment'][0])
    {
        $request = $this->getHlsVideoSegmentRequest($item_id, $playlist_id, $segment_id, $container, $runtime_ticks, $actual_segment_length_ticks, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHlsVideoSegmentAsync
     *
     * Gets a video stream using HTTP live streaming.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $playlist_id The playlist id. (required)
     * @param  int $segment_id The segment id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param  int $runtime_ticks The position of the requested segment in ticks. (required)
     * @param  int $actual_segment_length_ticks The length of the requested segment in ticks. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The desired segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getHlsVideoSegment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHlsVideoSegmentAsync($item_id, $playlist_id, $segment_id, $container, $runtime_ticks, $actual_segment_length_ticks, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getHlsVideoSegment'][0])
    {
        return $this->getHlsVideoSegmentAsyncWithHttpInfo($item_id, $playlist_id, $segment_id, $container, $runtime_ticks, $actual_segment_length_ticks, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHlsVideoSegmentAsyncWithHttpInfo
     *
     * Gets a video stream using HTTP live streaming.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $playlist_id The playlist id. (required)
     * @param  int $segment_id The segment id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param  int $runtime_ticks The position of the requested segment in ticks. (required)
     * @param  int $actual_segment_length_ticks The length of the requested segment in ticks. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The desired segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getHlsVideoSegment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHlsVideoSegmentAsyncWithHttpInfo($item_id, $playlist_id, $segment_id, $container, $runtime_ticks, $actual_segment_length_ticks, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getHlsVideoSegment'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getHlsVideoSegmentRequest($item_id, $playlist_id, $segment_id, $container, $runtime_ticks, $actual_segment_length_ticks, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHlsVideoSegment'
     *
     * @param  string $item_id The item id. (required)
     * @param  string $playlist_id The playlist id. (required)
     * @param  int $segment_id The segment id. (required)
     * @param  string $container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param  int $runtime_ticks The position of the requested segment in ticks. (required)
     * @param  int $actual_segment_length_ticks The length of the requested segment in ticks. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The desired segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getHlsVideoSegment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getHlsVideoSegmentRequest($item_id, $playlist_id, $segment_id, $container, $runtime_ticks, $actual_segment_length_ticks, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getHlsVideoSegment'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling getHlsVideoSegment'
            );
        }

        // verify the required parameter 'playlist_id' is set
        if ($playlist_id === null || (is_array($playlist_id) && count($playlist_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $playlist_id when calling getHlsVideoSegment'
            );
        }

        // verify the required parameter 'segment_id' is set
        if ($segment_id === null || (is_array($segment_id) && count($segment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $segment_id when calling getHlsVideoSegment'
            );
        }

        // verify the required parameter 'container' is set
        if ($container === null || (is_array($container) && count($container) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $container when calling getHlsVideoSegment'
            );
        }

        // verify the required parameter 'runtime_ticks' is set
        if ($runtime_ticks === null || (is_array($runtime_ticks) && count($runtime_ticks) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runtime_ticks when calling getHlsVideoSegment'
            );
        }

        // verify the required parameter 'actual_segment_length_ticks' is set
        if ($actual_segment_length_ticks === null || (is_array($actual_segment_length_ticks) && count($actual_segment_length_ticks) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actual_segment_length_ticks when calling getHlsVideoSegment'
            );
        }



















































        $resourcePath = '/Videos/{itemId}/hls1/{playlistId}/{segmentId}.{container}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $runtime_ticks,
            'runtimeTicks', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $actual_segment_length_ticks,
            'actualSegmentLengthTicks', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $static,
            'static', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $params,
            'params', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_profile_id,
            'deviceProfileId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $play_session_id,
            'playSessionId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $segment_container,
            'segmentContainer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $segment_length,
            'segmentLength', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_segments,
            'minSegments', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_source_id,
            'mediaSourceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_codec,
            'audioCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_auto_stream_copy,
            'enableAutoStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_video_stream_copy,
            'allowVideoStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_audio_stream_copy,
            'allowAudioStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $break_on_non_key_frames,
            'breakOnNonKeyFrames', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_sample_rate,
            'audioSampleRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_audio_bit_depth,
            'maxAudioBitDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_bit_rate,
            'audioBitRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_channels,
            'audioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_audio_channels,
            'maxAudioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $profile,
            'profile', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $framerate,
            'framerate', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_framerate,
            'maxFramerate', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $copy_timestamps,
            'copyTimestamps', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_time_ticks,
            'startTimeTicks', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_bit_rate,
            'videoBitRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_stream_index,
            'subtitleStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_method,
            'subtitleMethod', // param base name
            'SubtitleDeliveryMethod', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_ref_frames,
            'maxRefFrames', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_video_bit_depth,
            'maxVideoBitDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $require_avc,
            'requireAvc', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $de_interlace,
            'deInterlace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $require_non_anamorphic,
            'requireNonAnamorphic', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcoding_max_audio_channels,
            'transcodingMaxAudioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cpu_core_limit,
            'cpuCoreLimit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $live_stream_id,
            'liveStreamId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_mpegts_m2_ts_mode,
            'enableMpegtsM2TsMode', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_codec,
            'videoCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_codec,
            'subtitleCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcode_reasons,
            'transcodeReasons', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_stream_index,
            'audioStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_stream_index,
            'videoStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'EncodingContext', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stream_options,
            'streamOptions', // param base name
            'object', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }
        // path params
        if ($playlist_id !== null) {
            $resourcePath = str_replace(
                '{' . 'playlistId' . '}',
                ObjectSerializer::toPathValue($playlist_id),
                $resourcePath
            );
        }
        // path params
        if ($segment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'segmentId' . '}',
                ObjectSerializer::toPathValue($segment_id),
                $resourcePath
            );
        }
        // path params
        if ($container !== null) {
            $resourcePath = str_replace(
                '{' . 'container' . '}',
                ObjectSerializer::toPathValue($container),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['video/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Emby-Token');
        if ($apiKey !== null) {
            $headers['X-Emby-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLiveHlsStream
     *
     * Gets a hls live stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $container The audio container. (optional)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment lenght. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  int $max_width Optional. The max width. (optional)
     * @param  int $max_height Optional. The max height. (optional)
     * @param  bool $enable_subtitles_in_manifest Optional. Whether to enable subtitles in the manifest. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveHlsStream'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getLiveHlsStream($item_id, $container = null, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, $max_width = null, $max_height = null, $enable_subtitles_in_manifest = null, string $contentType = self::contentTypes['getLiveHlsStream'][0])
    {
        list($response) = $this->getLiveHlsStreamWithHttpInfo($item_id, $container, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $max_width, $max_height, $enable_subtitles_in_manifest, $contentType);
        return $response;
    }

    /**
     * Operation getLiveHlsStreamWithHttpInfo
     *
     * Gets a hls live stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $container The audio container. (optional)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment lenght. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  int $max_width Optional. The max width. (optional)
     * @param  int $max_height Optional. The max height. (optional)
     * @param  bool $enable_subtitles_in_manifest Optional. Whether to enable subtitles in the manifest. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveHlsStream'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLiveHlsStreamWithHttpInfo($item_id, $container = null, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, $max_width = null, $max_height = null, $enable_subtitles_in_manifest = null, string $contentType = self::contentTypes['getLiveHlsStream'][0])
    {
        $request = $this->getLiveHlsStreamRequest($item_id, $container, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $max_width, $max_height, $enable_subtitles_in_manifest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLiveHlsStreamAsync
     *
     * Gets a hls live stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $container The audio container. (optional)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment lenght. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  int $max_width Optional. The max width. (optional)
     * @param  int $max_height Optional. The max height. (optional)
     * @param  bool $enable_subtitles_in_manifest Optional. Whether to enable subtitles in the manifest. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveHlsStream'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLiveHlsStreamAsync($item_id, $container = null, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, $max_width = null, $max_height = null, $enable_subtitles_in_manifest = null, string $contentType = self::contentTypes['getLiveHlsStream'][0])
    {
        return $this->getLiveHlsStreamAsyncWithHttpInfo($item_id, $container, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $max_width, $max_height, $enable_subtitles_in_manifest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLiveHlsStreamAsyncWithHttpInfo
     *
     * Gets a hls live stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $container The audio container. (optional)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment lenght. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  int $max_width Optional. The max width. (optional)
     * @param  int $max_height Optional. The max height. (optional)
     * @param  bool $enable_subtitles_in_manifest Optional. Whether to enable subtitles in the manifest. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveHlsStream'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLiveHlsStreamAsyncWithHttpInfo($item_id, $container = null, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, $max_width = null, $max_height = null, $enable_subtitles_in_manifest = null, string $contentType = self::contentTypes['getLiveHlsStream'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getLiveHlsStreamRequest($item_id, $container, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $max_width, $max_height, $enable_subtitles_in_manifest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLiveHlsStream'
     *
     * @param  string $item_id The item id. (required)
     * @param  string $container The audio container. (optional)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment lenght. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  int $max_width Optional. The max width. (optional)
     * @param  int $max_height Optional. The max height. (optional)
     * @param  bool $enable_subtitles_in_manifest Optional. Whether to enable subtitles in the manifest. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveHlsStream'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getLiveHlsStreamRequest($item_id, $container = null, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, $max_width = null, $max_height = null, $enable_subtitles_in_manifest = null, string $contentType = self::contentTypes['getLiveHlsStream'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling getLiveHlsStream'
            );
        }





















































        $resourcePath = '/Videos/{itemId}/live.m3u8';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $container,
            'container', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $static,
            'static', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $params,
            'params', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_profile_id,
            'deviceProfileId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $play_session_id,
            'playSessionId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $segment_container,
            'segmentContainer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $segment_length,
            'segmentLength', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_segments,
            'minSegments', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_source_id,
            'mediaSourceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_codec,
            'audioCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_auto_stream_copy,
            'enableAutoStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_video_stream_copy,
            'allowVideoStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_audio_stream_copy,
            'allowAudioStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $break_on_non_key_frames,
            'breakOnNonKeyFrames', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_sample_rate,
            'audioSampleRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_audio_bit_depth,
            'maxAudioBitDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_bit_rate,
            'audioBitRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_channels,
            'audioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_audio_channels,
            'maxAudioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $profile,
            'profile', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $framerate,
            'framerate', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_framerate,
            'maxFramerate', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $copy_timestamps,
            'copyTimestamps', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_time_ticks,
            'startTimeTicks', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_bit_rate,
            'videoBitRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_stream_index,
            'subtitleStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_method,
            'subtitleMethod', // param base name
            'SubtitleDeliveryMethod', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_ref_frames,
            'maxRefFrames', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_video_bit_depth,
            'maxVideoBitDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $require_avc,
            'requireAvc', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $de_interlace,
            'deInterlace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $require_non_anamorphic,
            'requireNonAnamorphic', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcoding_max_audio_channels,
            'transcodingMaxAudioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cpu_core_limit,
            'cpuCoreLimit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $live_stream_id,
            'liveStreamId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_mpegts_m2_ts_mode,
            'enableMpegtsM2TsMode', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_codec,
            'videoCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_codec,
            'subtitleCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcode_reasons,
            'transcodeReasons', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_stream_index,
            'audioStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_stream_index,
            'videoStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'EncodingContext', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stream_options,
            'streamOptions', // param base name
            'object', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_subtitles_in_manifest,
            'enableSubtitlesInManifest', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/x-mpegURL', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Emby-Token');
        if ($apiKey !== null) {
            $headers['X-Emby-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMasterHlsAudioPlaylist
     *
     * Gets an audio hls playlist stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $media_source_id The media version id, if playing an alternate version. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $max_streaming_bitrate Optional. The maximum streaming bitrate. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  bool $enable_adaptive_bitrate_streaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMasterHlsAudioPlaylist'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getMasterHlsAudioPlaylist($item_id, $media_source_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $max_streaming_bitrate = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, $enable_adaptive_bitrate_streaming = true, string $contentType = self::contentTypes['getMasterHlsAudioPlaylist'][0])
    {
        list($response) = $this->getMasterHlsAudioPlaylistWithHttpInfo($item_id, $media_source_id, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $max_streaming_bitrate, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $enable_adaptive_bitrate_streaming, $contentType);
        return $response;
    }

    /**
     * Operation getMasterHlsAudioPlaylistWithHttpInfo
     *
     * Gets an audio hls playlist stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $media_source_id The media version id, if playing an alternate version. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $max_streaming_bitrate Optional. The maximum streaming bitrate. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  bool $enable_adaptive_bitrate_streaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMasterHlsAudioPlaylist'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMasterHlsAudioPlaylistWithHttpInfo($item_id, $media_source_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $max_streaming_bitrate = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, $enable_adaptive_bitrate_streaming = true, string $contentType = self::contentTypes['getMasterHlsAudioPlaylist'][0])
    {
        $request = $this->getMasterHlsAudioPlaylistRequest($item_id, $media_source_id, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $max_streaming_bitrate, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $enable_adaptive_bitrate_streaming, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMasterHlsAudioPlaylistAsync
     *
     * Gets an audio hls playlist stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $media_source_id The media version id, if playing an alternate version. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $max_streaming_bitrate Optional. The maximum streaming bitrate. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  bool $enable_adaptive_bitrate_streaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMasterHlsAudioPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMasterHlsAudioPlaylistAsync($item_id, $media_source_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $max_streaming_bitrate = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, $enable_adaptive_bitrate_streaming = true, string $contentType = self::contentTypes['getMasterHlsAudioPlaylist'][0])
    {
        return $this->getMasterHlsAudioPlaylistAsyncWithHttpInfo($item_id, $media_source_id, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $max_streaming_bitrate, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $enable_adaptive_bitrate_streaming, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMasterHlsAudioPlaylistAsyncWithHttpInfo
     *
     * Gets an audio hls playlist stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $media_source_id The media version id, if playing an alternate version. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $max_streaming_bitrate Optional. The maximum streaming bitrate. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  bool $enable_adaptive_bitrate_streaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMasterHlsAudioPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMasterHlsAudioPlaylistAsyncWithHttpInfo($item_id, $media_source_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $max_streaming_bitrate = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, $enable_adaptive_bitrate_streaming = true, string $contentType = self::contentTypes['getMasterHlsAudioPlaylist'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getMasterHlsAudioPlaylistRequest($item_id, $media_source_id, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $max_streaming_bitrate, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $enable_adaptive_bitrate_streaming, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMasterHlsAudioPlaylist'
     *
     * @param  string $item_id The item id. (required)
     * @param  string $media_source_id The media version id, if playing an alternate version. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $max_streaming_bitrate Optional. The maximum streaming bitrate. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  bool $enable_adaptive_bitrate_streaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMasterHlsAudioPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMasterHlsAudioPlaylistRequest($item_id, $media_source_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $max_streaming_bitrate = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, $enable_adaptive_bitrate_streaming = true, string $contentType = self::contentTypes['getMasterHlsAudioPlaylist'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling getMasterHlsAudioPlaylist'
            );
        }

        // verify the required parameter 'media_source_id' is set
        if ($media_source_id === null || (is_array($media_source_id) && count($media_source_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $media_source_id when calling getMasterHlsAudioPlaylist'
            );
        }


















































        $resourcePath = '/Audio/{itemId}/master.m3u8';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $static,
            'static', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $params,
            'params', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_profile_id,
            'deviceProfileId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $play_session_id,
            'playSessionId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $segment_container,
            'segmentContainer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $segment_length,
            'segmentLength', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_segments,
            'minSegments', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_source_id,
            'mediaSourceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_codec,
            'audioCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_auto_stream_copy,
            'enableAutoStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_video_stream_copy,
            'allowVideoStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_audio_stream_copy,
            'allowAudioStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $break_on_non_key_frames,
            'breakOnNonKeyFrames', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_sample_rate,
            'audioSampleRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_audio_bit_depth,
            'maxAudioBitDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_streaming_bitrate,
            'maxStreamingBitrate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_bit_rate,
            'audioBitRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_channels,
            'audioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_audio_channels,
            'maxAudioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $profile,
            'profile', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $framerate,
            'framerate', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_framerate,
            'maxFramerate', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $copy_timestamps,
            'copyTimestamps', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_time_ticks,
            'startTimeTicks', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_bit_rate,
            'videoBitRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_stream_index,
            'subtitleStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_method,
            'subtitleMethod', // param base name
            'SubtitleDeliveryMethod', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_ref_frames,
            'maxRefFrames', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_video_bit_depth,
            'maxVideoBitDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $require_avc,
            'requireAvc', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $de_interlace,
            'deInterlace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $require_non_anamorphic,
            'requireNonAnamorphic', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcoding_max_audio_channels,
            'transcodingMaxAudioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cpu_core_limit,
            'cpuCoreLimit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $live_stream_id,
            'liveStreamId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_mpegts_m2_ts_mode,
            'enableMpegtsM2TsMode', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_codec,
            'videoCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_codec,
            'subtitleCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcode_reasons,
            'transcodeReasons', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_stream_index,
            'audioStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_stream_index,
            'videoStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'EncodingContext', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stream_options,
            'streamOptions', // param base name
            'object', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_adaptive_bitrate_streaming,
            'enableAdaptiveBitrateStreaming', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/x-mpegURL', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Emby-Token');
        if ($apiKey !== null) {
            $headers['X-Emby-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMasterHlsVideoPlaylist
     *
     * Gets a video hls playlist stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $media_source_id The media version id, if playing an alternate version. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  bool $enable_adaptive_bitrate_streaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMasterHlsVideoPlaylist'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getMasterHlsVideoPlaylist($item_id, $media_source_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, $enable_adaptive_bitrate_streaming = true, string $contentType = self::contentTypes['getMasterHlsVideoPlaylist'][0])
    {
        list($response) = $this->getMasterHlsVideoPlaylistWithHttpInfo($item_id, $media_source_id, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $enable_adaptive_bitrate_streaming, $contentType);
        return $response;
    }

    /**
     * Operation getMasterHlsVideoPlaylistWithHttpInfo
     *
     * Gets a video hls playlist stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $media_source_id The media version id, if playing an alternate version. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  bool $enable_adaptive_bitrate_streaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMasterHlsVideoPlaylist'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMasterHlsVideoPlaylistWithHttpInfo($item_id, $media_source_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, $enable_adaptive_bitrate_streaming = true, string $contentType = self::contentTypes['getMasterHlsVideoPlaylist'][0])
    {
        $request = $this->getMasterHlsVideoPlaylistRequest($item_id, $media_source_id, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $enable_adaptive_bitrate_streaming, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMasterHlsVideoPlaylistAsync
     *
     * Gets a video hls playlist stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $media_source_id The media version id, if playing an alternate version. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  bool $enable_adaptive_bitrate_streaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMasterHlsVideoPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMasterHlsVideoPlaylistAsync($item_id, $media_source_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, $enable_adaptive_bitrate_streaming = true, string $contentType = self::contentTypes['getMasterHlsVideoPlaylist'][0])
    {
        return $this->getMasterHlsVideoPlaylistAsyncWithHttpInfo($item_id, $media_source_id, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $enable_adaptive_bitrate_streaming, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMasterHlsVideoPlaylistAsyncWithHttpInfo
     *
     * Gets a video hls playlist stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $media_source_id The media version id, if playing an alternate version. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  bool $enable_adaptive_bitrate_streaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMasterHlsVideoPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMasterHlsVideoPlaylistAsyncWithHttpInfo($item_id, $media_source_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, $enable_adaptive_bitrate_streaming = true, string $contentType = self::contentTypes['getMasterHlsVideoPlaylist'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getMasterHlsVideoPlaylistRequest($item_id, $media_source_id, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $enable_adaptive_bitrate_streaming, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMasterHlsVideoPlaylist'
     *
     * @param  string $item_id The item id. (required)
     * @param  string $media_source_id The media version id, if playing an alternate version. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  bool $enable_adaptive_bitrate_streaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMasterHlsVideoPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMasterHlsVideoPlaylistRequest($item_id, $media_source_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, $enable_adaptive_bitrate_streaming = true, string $contentType = self::contentTypes['getMasterHlsVideoPlaylist'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling getMasterHlsVideoPlaylist'
            );
        }

        // verify the required parameter 'media_source_id' is set
        if ($media_source_id === null || (is_array($media_source_id) && count($media_source_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $media_source_id when calling getMasterHlsVideoPlaylist'
            );
        }



















































        $resourcePath = '/Videos/{itemId}/master.m3u8';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $static,
            'static', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $params,
            'params', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_profile_id,
            'deviceProfileId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $play_session_id,
            'playSessionId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $segment_container,
            'segmentContainer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $segment_length,
            'segmentLength', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_segments,
            'minSegments', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_source_id,
            'mediaSourceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_codec,
            'audioCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_auto_stream_copy,
            'enableAutoStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_video_stream_copy,
            'allowVideoStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_audio_stream_copy,
            'allowAudioStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $break_on_non_key_frames,
            'breakOnNonKeyFrames', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_sample_rate,
            'audioSampleRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_audio_bit_depth,
            'maxAudioBitDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_bit_rate,
            'audioBitRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_channels,
            'audioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_audio_channels,
            'maxAudioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $profile,
            'profile', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $framerate,
            'framerate', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_framerate,
            'maxFramerate', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $copy_timestamps,
            'copyTimestamps', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_time_ticks,
            'startTimeTicks', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_bit_rate,
            'videoBitRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_stream_index,
            'subtitleStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_method,
            'subtitleMethod', // param base name
            'SubtitleDeliveryMethod', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_ref_frames,
            'maxRefFrames', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_video_bit_depth,
            'maxVideoBitDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $require_avc,
            'requireAvc', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $de_interlace,
            'deInterlace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $require_non_anamorphic,
            'requireNonAnamorphic', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcoding_max_audio_channels,
            'transcodingMaxAudioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cpu_core_limit,
            'cpuCoreLimit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $live_stream_id,
            'liveStreamId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_mpegts_m2_ts_mode,
            'enableMpegtsM2TsMode', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_codec,
            'videoCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_codec,
            'subtitleCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcode_reasons,
            'transcodeReasons', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_stream_index,
            'audioStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_stream_index,
            'videoStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'EncodingContext', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stream_options,
            'streamOptions', // param base name
            'object', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_adaptive_bitrate_streaming,
            'enableAdaptiveBitrateStreaming', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/x-mpegURL', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Emby-Token');
        if ($apiKey !== null) {
            $headers['X-Emby-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVariantHlsAudioPlaylist
     *
     * Gets an audio stream using HTTP live streaming.
     *
     * @param  string $item_id The item id. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $max_streaming_bitrate Optional. The maximum streaming bitrate. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVariantHlsAudioPlaylist'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getVariantHlsAudioPlaylist($item_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $max_streaming_bitrate = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getVariantHlsAudioPlaylist'][0])
    {
        list($response) = $this->getVariantHlsAudioPlaylistWithHttpInfo($item_id, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $max_streaming_bitrate, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType);
        return $response;
    }

    /**
     * Operation getVariantHlsAudioPlaylistWithHttpInfo
     *
     * Gets an audio stream using HTTP live streaming.
     *
     * @param  string $item_id The item id. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $max_streaming_bitrate Optional. The maximum streaming bitrate. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVariantHlsAudioPlaylist'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVariantHlsAudioPlaylistWithHttpInfo($item_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $max_streaming_bitrate = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getVariantHlsAudioPlaylist'][0])
    {
        $request = $this->getVariantHlsAudioPlaylistRequest($item_id, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $max_streaming_bitrate, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVariantHlsAudioPlaylistAsync
     *
     * Gets an audio stream using HTTP live streaming.
     *
     * @param  string $item_id The item id. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $max_streaming_bitrate Optional. The maximum streaming bitrate. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVariantHlsAudioPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVariantHlsAudioPlaylistAsync($item_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $max_streaming_bitrate = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getVariantHlsAudioPlaylist'][0])
    {
        return $this->getVariantHlsAudioPlaylistAsyncWithHttpInfo($item_id, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $max_streaming_bitrate, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVariantHlsAudioPlaylistAsyncWithHttpInfo
     *
     * Gets an audio stream using HTTP live streaming.
     *
     * @param  string $item_id The item id. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $max_streaming_bitrate Optional. The maximum streaming bitrate. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVariantHlsAudioPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVariantHlsAudioPlaylistAsyncWithHttpInfo($item_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $max_streaming_bitrate = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getVariantHlsAudioPlaylist'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getVariantHlsAudioPlaylistRequest($item_id, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $max_streaming_bitrate, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVariantHlsAudioPlaylist'
     *
     * @param  string $item_id The item id. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $max_streaming_bitrate Optional. The maximum streaming bitrate. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVariantHlsAudioPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getVariantHlsAudioPlaylistRequest($item_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $max_streaming_bitrate = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getVariantHlsAudioPlaylist'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling getVariantHlsAudioPlaylist'
            );
        }


















































        $resourcePath = '/Audio/{itemId}/main.m3u8';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $static,
            'static', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $params,
            'params', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_profile_id,
            'deviceProfileId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $play_session_id,
            'playSessionId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $segment_container,
            'segmentContainer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $segment_length,
            'segmentLength', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_segments,
            'minSegments', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_source_id,
            'mediaSourceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_codec,
            'audioCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_auto_stream_copy,
            'enableAutoStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_video_stream_copy,
            'allowVideoStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_audio_stream_copy,
            'allowAudioStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $break_on_non_key_frames,
            'breakOnNonKeyFrames', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_sample_rate,
            'audioSampleRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_audio_bit_depth,
            'maxAudioBitDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_streaming_bitrate,
            'maxStreamingBitrate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_bit_rate,
            'audioBitRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_channels,
            'audioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_audio_channels,
            'maxAudioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $profile,
            'profile', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $framerate,
            'framerate', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_framerate,
            'maxFramerate', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $copy_timestamps,
            'copyTimestamps', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_time_ticks,
            'startTimeTicks', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_bit_rate,
            'videoBitRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_stream_index,
            'subtitleStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_method,
            'subtitleMethod', // param base name
            'SubtitleDeliveryMethod', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_ref_frames,
            'maxRefFrames', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_video_bit_depth,
            'maxVideoBitDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $require_avc,
            'requireAvc', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $de_interlace,
            'deInterlace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $require_non_anamorphic,
            'requireNonAnamorphic', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcoding_max_audio_channels,
            'transcodingMaxAudioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cpu_core_limit,
            'cpuCoreLimit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $live_stream_id,
            'liveStreamId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_mpegts_m2_ts_mode,
            'enableMpegtsM2TsMode', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_codec,
            'videoCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_codec,
            'subtitleCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcode_reasons,
            'transcodeReasons', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_stream_index,
            'audioStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_stream_index,
            'videoStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'EncodingContext', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stream_options,
            'streamOptions', // param base name
            'object', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/x-mpegURL', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Emby-Token');
        if ($apiKey !== null) {
            $headers['X-Emby-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVariantHlsVideoPlaylist
     *
     * Gets a video stream using HTTP live streaming.
     *
     * @param  string $item_id The item id. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVariantHlsVideoPlaylist'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getVariantHlsVideoPlaylist($item_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getVariantHlsVideoPlaylist'][0])
    {
        list($response) = $this->getVariantHlsVideoPlaylistWithHttpInfo($item_id, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType);
        return $response;
    }

    /**
     * Operation getVariantHlsVideoPlaylistWithHttpInfo
     *
     * Gets a video stream using HTTP live streaming.
     *
     * @param  string $item_id The item id. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVariantHlsVideoPlaylist'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVariantHlsVideoPlaylistWithHttpInfo($item_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getVariantHlsVideoPlaylist'][0])
    {
        $request = $this->getVariantHlsVideoPlaylistRequest($item_id, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVariantHlsVideoPlaylistAsync
     *
     * Gets a video stream using HTTP live streaming.
     *
     * @param  string $item_id The item id. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVariantHlsVideoPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVariantHlsVideoPlaylistAsync($item_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getVariantHlsVideoPlaylist'][0])
    {
        return $this->getVariantHlsVideoPlaylistAsyncWithHttpInfo($item_id, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVariantHlsVideoPlaylistAsyncWithHttpInfo
     *
     * Gets a video stream using HTTP live streaming.
     *
     * @param  string $item_id The item id. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVariantHlsVideoPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVariantHlsVideoPlaylistAsyncWithHttpInfo($item_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getVariantHlsVideoPlaylist'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getVariantHlsVideoPlaylistRequest($item_id, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $media_source_id, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVariantHlsVideoPlaylist'
     *
     * @param  string $item_id The item id. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $media_source_id The media version id, if playing an alternate version. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVariantHlsVideoPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getVariantHlsVideoPlaylistRequest($item_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $media_source_id = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, string $contentType = self::contentTypes['getVariantHlsVideoPlaylist'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling getVariantHlsVideoPlaylist'
            );
        }



















































        $resourcePath = '/Videos/{itemId}/main.m3u8';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $static,
            'static', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $params,
            'params', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_profile_id,
            'deviceProfileId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $play_session_id,
            'playSessionId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $segment_container,
            'segmentContainer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $segment_length,
            'segmentLength', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_segments,
            'minSegments', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_source_id,
            'mediaSourceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_codec,
            'audioCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_auto_stream_copy,
            'enableAutoStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_video_stream_copy,
            'allowVideoStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_audio_stream_copy,
            'allowAudioStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $break_on_non_key_frames,
            'breakOnNonKeyFrames', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_sample_rate,
            'audioSampleRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_audio_bit_depth,
            'maxAudioBitDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_bit_rate,
            'audioBitRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_channels,
            'audioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_audio_channels,
            'maxAudioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $profile,
            'profile', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $framerate,
            'framerate', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_framerate,
            'maxFramerate', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $copy_timestamps,
            'copyTimestamps', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_time_ticks,
            'startTimeTicks', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_bit_rate,
            'videoBitRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_stream_index,
            'subtitleStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_method,
            'subtitleMethod', // param base name
            'SubtitleDeliveryMethod', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_ref_frames,
            'maxRefFrames', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_video_bit_depth,
            'maxVideoBitDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $require_avc,
            'requireAvc', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $de_interlace,
            'deInterlace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $require_non_anamorphic,
            'requireNonAnamorphic', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcoding_max_audio_channels,
            'transcodingMaxAudioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cpu_core_limit,
            'cpuCoreLimit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $live_stream_id,
            'liveStreamId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_mpegts_m2_ts_mode,
            'enableMpegtsM2TsMode', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_codec,
            'videoCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_codec,
            'subtitleCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcode_reasons,
            'transcodeReasons', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_stream_index,
            'audioStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_stream_index,
            'videoStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'EncodingContext', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stream_options,
            'streamOptions', // param base name
            'object', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/x-mpegURL', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Emby-Token');
        if ($apiKey !== null) {
            $headers['X-Emby-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation headMasterHlsAudioPlaylist
     *
     * Gets an audio hls playlist stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $media_source_id The media version id, if playing an alternate version. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $max_streaming_bitrate Optional. The maximum streaming bitrate. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  bool $enable_adaptive_bitrate_streaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headMasterHlsAudioPlaylist'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function headMasterHlsAudioPlaylist($item_id, $media_source_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $max_streaming_bitrate = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, $enable_adaptive_bitrate_streaming = true, string $contentType = self::contentTypes['headMasterHlsAudioPlaylist'][0])
    {
        list($response) = $this->headMasterHlsAudioPlaylistWithHttpInfo($item_id, $media_source_id, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $max_streaming_bitrate, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $enable_adaptive_bitrate_streaming, $contentType);
        return $response;
    }

    /**
     * Operation headMasterHlsAudioPlaylistWithHttpInfo
     *
     * Gets an audio hls playlist stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $media_source_id The media version id, if playing an alternate version. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $max_streaming_bitrate Optional. The maximum streaming bitrate. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  bool $enable_adaptive_bitrate_streaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headMasterHlsAudioPlaylist'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function headMasterHlsAudioPlaylistWithHttpInfo($item_id, $media_source_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $max_streaming_bitrate = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, $enable_adaptive_bitrate_streaming = true, string $contentType = self::contentTypes['headMasterHlsAudioPlaylist'][0])
    {
        $request = $this->headMasterHlsAudioPlaylistRequest($item_id, $media_source_id, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $max_streaming_bitrate, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $enable_adaptive_bitrate_streaming, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation headMasterHlsAudioPlaylistAsync
     *
     * Gets an audio hls playlist stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $media_source_id The media version id, if playing an alternate version. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $max_streaming_bitrate Optional. The maximum streaming bitrate. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  bool $enable_adaptive_bitrate_streaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headMasterHlsAudioPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headMasterHlsAudioPlaylistAsync($item_id, $media_source_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $max_streaming_bitrate = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, $enable_adaptive_bitrate_streaming = true, string $contentType = self::contentTypes['headMasterHlsAudioPlaylist'][0])
    {
        return $this->headMasterHlsAudioPlaylistAsyncWithHttpInfo($item_id, $media_source_id, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $max_streaming_bitrate, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $enable_adaptive_bitrate_streaming, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation headMasterHlsAudioPlaylistAsyncWithHttpInfo
     *
     * Gets an audio hls playlist stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $media_source_id The media version id, if playing an alternate version. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $max_streaming_bitrate Optional. The maximum streaming bitrate. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  bool $enable_adaptive_bitrate_streaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headMasterHlsAudioPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headMasterHlsAudioPlaylistAsyncWithHttpInfo($item_id, $media_source_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $max_streaming_bitrate = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, $enable_adaptive_bitrate_streaming = true, string $contentType = self::contentTypes['headMasterHlsAudioPlaylist'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->headMasterHlsAudioPlaylistRequest($item_id, $media_source_id, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $max_streaming_bitrate, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $enable_adaptive_bitrate_streaming, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'headMasterHlsAudioPlaylist'
     *
     * @param  string $item_id The item id. (required)
     * @param  string $media_source_id The media version id, if playing an alternate version. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $max_streaming_bitrate Optional. The maximum streaming bitrate. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  bool $enable_adaptive_bitrate_streaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headMasterHlsAudioPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function headMasterHlsAudioPlaylistRequest($item_id, $media_source_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $max_streaming_bitrate = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, $enable_adaptive_bitrate_streaming = true, string $contentType = self::contentTypes['headMasterHlsAudioPlaylist'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling headMasterHlsAudioPlaylist'
            );
        }

        // verify the required parameter 'media_source_id' is set
        if ($media_source_id === null || (is_array($media_source_id) && count($media_source_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $media_source_id when calling headMasterHlsAudioPlaylist'
            );
        }


















































        $resourcePath = '/Audio/{itemId}/master.m3u8';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $static,
            'static', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $params,
            'params', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_profile_id,
            'deviceProfileId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $play_session_id,
            'playSessionId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $segment_container,
            'segmentContainer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $segment_length,
            'segmentLength', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_segments,
            'minSegments', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_source_id,
            'mediaSourceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_codec,
            'audioCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_auto_stream_copy,
            'enableAutoStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_video_stream_copy,
            'allowVideoStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_audio_stream_copy,
            'allowAudioStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $break_on_non_key_frames,
            'breakOnNonKeyFrames', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_sample_rate,
            'audioSampleRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_audio_bit_depth,
            'maxAudioBitDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_streaming_bitrate,
            'maxStreamingBitrate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_bit_rate,
            'audioBitRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_channels,
            'audioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_audio_channels,
            'maxAudioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $profile,
            'profile', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $framerate,
            'framerate', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_framerate,
            'maxFramerate', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $copy_timestamps,
            'copyTimestamps', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_time_ticks,
            'startTimeTicks', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_bit_rate,
            'videoBitRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_stream_index,
            'subtitleStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_method,
            'subtitleMethod', // param base name
            'SubtitleDeliveryMethod', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_ref_frames,
            'maxRefFrames', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_video_bit_depth,
            'maxVideoBitDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $require_avc,
            'requireAvc', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $de_interlace,
            'deInterlace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $require_non_anamorphic,
            'requireNonAnamorphic', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcoding_max_audio_channels,
            'transcodingMaxAudioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cpu_core_limit,
            'cpuCoreLimit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $live_stream_id,
            'liveStreamId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_mpegts_m2_ts_mode,
            'enableMpegtsM2TsMode', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_codec,
            'videoCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_codec,
            'subtitleCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcode_reasons,
            'transcodeReasons', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_stream_index,
            'audioStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_stream_index,
            'videoStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'EncodingContext', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stream_options,
            'streamOptions', // param base name
            'object', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_adaptive_bitrate_streaming,
            'enableAdaptiveBitrateStreaming', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/x-mpegURL', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Emby-Token');
        if ($apiKey !== null) {
            $headers['X-Emby-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'HEAD',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation headMasterHlsVideoPlaylist
     *
     * Gets a video hls playlist stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $media_source_id The media version id, if playing an alternate version. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  bool $enable_adaptive_bitrate_streaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headMasterHlsVideoPlaylist'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function headMasterHlsVideoPlaylist($item_id, $media_source_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, $enable_adaptive_bitrate_streaming = true, string $contentType = self::contentTypes['headMasterHlsVideoPlaylist'][0])
    {
        list($response) = $this->headMasterHlsVideoPlaylistWithHttpInfo($item_id, $media_source_id, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $enable_adaptive_bitrate_streaming, $contentType);
        return $response;
    }

    /**
     * Operation headMasterHlsVideoPlaylistWithHttpInfo
     *
     * Gets a video hls playlist stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $media_source_id The media version id, if playing an alternate version. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  bool $enable_adaptive_bitrate_streaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headMasterHlsVideoPlaylist'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function headMasterHlsVideoPlaylistWithHttpInfo($item_id, $media_source_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, $enable_adaptive_bitrate_streaming = true, string $contentType = self::contentTypes['headMasterHlsVideoPlaylist'][0])
    {
        $request = $this->headMasterHlsVideoPlaylistRequest($item_id, $media_source_id, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $enable_adaptive_bitrate_streaming, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation headMasterHlsVideoPlaylistAsync
     *
     * Gets a video hls playlist stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $media_source_id The media version id, if playing an alternate version. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  bool $enable_adaptive_bitrate_streaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headMasterHlsVideoPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headMasterHlsVideoPlaylistAsync($item_id, $media_source_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, $enable_adaptive_bitrate_streaming = true, string $contentType = self::contentTypes['headMasterHlsVideoPlaylist'][0])
    {
        return $this->headMasterHlsVideoPlaylistAsyncWithHttpInfo($item_id, $media_source_id, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $enable_adaptive_bitrate_streaming, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation headMasterHlsVideoPlaylistAsyncWithHttpInfo
     *
     * Gets a video hls playlist stream.
     *
     * @param  string $item_id The item id. (required)
     * @param  string $media_source_id The media version id, if playing an alternate version. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  bool $enable_adaptive_bitrate_streaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headMasterHlsVideoPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function headMasterHlsVideoPlaylistAsyncWithHttpInfo($item_id, $media_source_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, $enable_adaptive_bitrate_streaming = true, string $contentType = self::contentTypes['headMasterHlsVideoPlaylist'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->headMasterHlsVideoPlaylistRequest($item_id, $media_source_id, $static, $params, $tag, $device_profile_id, $play_session_id, $segment_container, $segment_length, $min_segments, $device_id, $audio_codec, $enable_auto_stream_copy, $allow_video_stream_copy, $allow_audio_stream_copy, $break_on_non_key_frames, $audio_sample_rate, $max_audio_bit_depth, $audio_bit_rate, $audio_channels, $max_audio_channels, $profile, $level, $framerate, $max_framerate, $copy_timestamps, $start_time_ticks, $width, $height, $max_width, $max_height, $video_bit_rate, $subtitle_stream_index, $subtitle_method, $max_ref_frames, $max_video_bit_depth, $require_avc, $de_interlace, $require_non_anamorphic, $transcoding_max_audio_channels, $cpu_core_limit, $live_stream_id, $enable_mpegts_m2_ts_mode, $video_codec, $subtitle_codec, $transcode_reasons, $audio_stream_index, $video_stream_index, $context, $stream_options, $enable_adaptive_bitrate_streaming, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'headMasterHlsVideoPlaylist'
     *
     * @param  string $item_id The item id. (required)
     * @param  string $media_source_id The media version id, if playing an alternate version. (required)
     * @param  bool $static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param  string $params The streaming parameters. (optional)
     * @param  string $tag The tag. (optional)
     * @param  string $device_profile_id Optional. The dlna device profile id to utilize. (optional)
     * @param  string $play_session_id The play session id. (optional)
     * @param  string $segment_container The segment container. (optional)
     * @param  int $segment_length The segment length. (optional)
     * @param  int $min_segments The minimum number of segments. (optional)
     * @param  string $device_id The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param  string $audio_codec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url&#39;s extension. Options: aac, mp3, vorbis, wma. (optional)
     * @param  bool $enable_auto_stream_copy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param  bool $allow_video_stream_copy Whether or not to allow copying of the video stream url. (optional)
     * @param  bool $allow_audio_stream_copy Whether or not to allow copying of the audio stream url. (optional)
     * @param  bool $break_on_non_key_frames Optional. Whether to break on non key frames. (optional)
     * @param  int $audio_sample_rate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param  int $max_audio_bit_depth Optional. The maximum audio bit depth. (optional)
     * @param  int $audio_bit_rate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $audio_channels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param  int $max_audio_channels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param  string $profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param  string $level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param  float $framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  float $max_framerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param  bool $copy_timestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param  int $start_time_ticks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param  int $width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param  int $height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param  int $max_width Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param  int $max_height Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param  int $video_bit_rate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param  int $subtitle_stream_index Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param  \OpenAPI\Client\Model\SubtitleDeliveryMethod $subtitle_method Optional. Specify the subtitle delivery method. (optional)
     * @param  int $max_ref_frames Optional. (optional)
     * @param  int $max_video_bit_depth Optional. The maximum video bit depth. (optional)
     * @param  bool $require_avc Optional. Whether to require avc. (optional)
     * @param  bool $de_interlace Optional. Whether to deinterlace the video. (optional)
     * @param  bool $require_non_anamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param  int $transcoding_max_audio_channels Optional. The maximum number of audio channels to transcode. (optional)
     * @param  int $cpu_core_limit Optional. The limit of how many cpu cores to use. (optional)
     * @param  string $live_stream_id The live stream id. (optional)
     * @param  bool $enable_mpegts_m2_ts_mode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param  string $video_codec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url&#39;s extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. (optional)
     * @param  string $subtitle_codec Optional. Specify a subtitle codec to encode to. (optional)
     * @param  string $transcode_reasons Optional. The transcoding reason. (optional)
     * @param  int $audio_stream_index Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param  int $video_stream_index Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param  \OpenAPI\Client\Model\EncodingContext $context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param  array<string,string> $stream_options Optional. The streaming options. (optional)
     * @param  bool $enable_adaptive_bitrate_streaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['headMasterHlsVideoPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function headMasterHlsVideoPlaylistRequest($item_id, $media_source_id, $static = null, $params = null, $tag = null, $device_profile_id = null, $play_session_id = null, $segment_container = null, $segment_length = null, $min_segments = null, $device_id = null, $audio_codec = null, $enable_auto_stream_copy = null, $allow_video_stream_copy = null, $allow_audio_stream_copy = null, $break_on_non_key_frames = null, $audio_sample_rate = null, $max_audio_bit_depth = null, $audio_bit_rate = null, $audio_channels = null, $max_audio_channels = null, $profile = null, $level = null, $framerate = null, $max_framerate = null, $copy_timestamps = null, $start_time_ticks = null, $width = null, $height = null, $max_width = null, $max_height = null, $video_bit_rate = null, $subtitle_stream_index = null, $subtitle_method = null, $max_ref_frames = null, $max_video_bit_depth = null, $require_avc = null, $de_interlace = null, $require_non_anamorphic = null, $transcoding_max_audio_channels = null, $cpu_core_limit = null, $live_stream_id = null, $enable_mpegts_m2_ts_mode = null, $video_codec = null, $subtitle_codec = null, $transcode_reasons = null, $audio_stream_index = null, $video_stream_index = null, $context = null, $stream_options = null, $enable_adaptive_bitrate_streaming = true, string $contentType = self::contentTypes['headMasterHlsVideoPlaylist'][0])
    {

        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling headMasterHlsVideoPlaylist'
            );
        }

        // verify the required parameter 'media_source_id' is set
        if ($media_source_id === null || (is_array($media_source_id) && count($media_source_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $media_source_id when calling headMasterHlsVideoPlaylist'
            );
        }



















































        $resourcePath = '/Videos/{itemId}/master.m3u8';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $static,
            'static', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $params,
            'params', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_profile_id,
            'deviceProfileId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $play_session_id,
            'playSessionId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $segment_container,
            'segmentContainer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $segment_length,
            'segmentLength', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_segments,
            'minSegments', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_source_id,
            'mediaSourceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_codec,
            'audioCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_auto_stream_copy,
            'enableAutoStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_video_stream_copy,
            'allowVideoStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allow_audio_stream_copy,
            'allowAudioStreamCopy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $break_on_non_key_frames,
            'breakOnNonKeyFrames', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_sample_rate,
            'audioSampleRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_audio_bit_depth,
            'maxAudioBitDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_bit_rate,
            'audioBitRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_channels,
            'audioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_audio_channels,
            'maxAudioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $profile,
            'profile', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $framerate,
            'framerate', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_framerate,
            'maxFramerate', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $copy_timestamps,
            'copyTimestamps', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_time_ticks,
            'startTimeTicks', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $width,
            'width', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $height,
            'height', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_width,
            'maxWidth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_height,
            'maxHeight', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_bit_rate,
            'videoBitRate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_stream_index,
            'subtitleStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_method,
            'subtitleMethod', // param base name
            'SubtitleDeliveryMethod', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_ref_frames,
            'maxRefFrames', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_video_bit_depth,
            'maxVideoBitDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $require_avc,
            'requireAvc', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $de_interlace,
            'deInterlace', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $require_non_anamorphic,
            'requireNonAnamorphic', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcoding_max_audio_channels,
            'transcodingMaxAudioChannels', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cpu_core_limit,
            'cpuCoreLimit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $live_stream_id,
            'liveStreamId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_mpegts_m2_ts_mode,
            'enableMpegtsM2TsMode', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_codec,
            'videoCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subtitle_codec,
            'subtitleCodec', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transcode_reasons,
            'transcodeReasons', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audio_stream_index,
            'audioStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $video_stream_index,
            'videoStreamIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'EncodingContext', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stream_options,
            'streamOptions', // param base name
            'object', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_adaptive_bitrate_streaming,
            'enableAdaptiveBitrateStreaming', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/x-mpegURL', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Emby-Token');
        if ($apiKey !== null) {
            $headers['X-Emby-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'HEAD',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
