<?php
/**
 * LiveTvApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Jellyfin API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 10.8.10
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.0.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * LiveTvApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class LiveTvApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'addListingProvider' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'addTunerHost' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'cancelSeriesTimer' => [
            'application/json',
        ],
        'cancelTimer' => [
            'application/json',
        ],
        'createSeriesTimer' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'createTimer' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'deleteListingProvider' => [
            'application/json',
        ],
        'deleteRecording' => [
            'application/json',
        ],
        'deleteTunerHost' => [
            'application/json',
        ],
        'discoverTuners' => [
            'application/json',
        ],
        'discvoverTuners' => [
            'application/json',
        ],
        'getChannel' => [
            'application/json',
        ],
        'getChannelMappingOptions' => [
            'application/json',
        ],
        'getDefaultListingProvider' => [
            'application/json',
        ],
        'getDefaultTimer' => [
            'application/json',
        ],
        'getGuideInfo' => [
            'application/json',
        ],
        'getLineups' => [
            'application/json',
        ],
        'getLiveRecordingFile' => [
            'application/json',
        ],
        'getLiveStreamFile' => [
            'application/json',
        ],
        'getLiveTvChannels' => [
            'application/json',
        ],
        'getLiveTvInfo' => [
            'application/json',
        ],
        'getLiveTvPrograms' => [
            'application/json',
        ],
        'getProgram' => [
            'application/json',
        ],
        'getPrograms' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'getRecommendedPrograms' => [
            'application/json',
        ],
        'getRecording' => [
            'application/json',
        ],
        'getRecordingFolders' => [
            'application/json',
        ],
        'getRecordingGroup' => [
            'application/json',
        ],
        'getRecordingGroups' => [
            'application/json',
        ],
        'getRecordings' => [
            'application/json',
        ],
        'getRecordingsSeries' => [
            'application/json',
        ],
        'getSchedulesDirectCountries' => [
            'application/json',
        ],
        'getSeriesTimer' => [
            'application/json',
        ],
        'getSeriesTimers' => [
            'application/json',
        ],
        'getTimer' => [
            'application/json',
        ],
        'getTimers' => [
            'application/json',
        ],
        'getTunerHostTypes' => [
            'application/json',
        ],
        'resetTuner' => [
            'application/json',
        ],
        'setChannelMapping' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'updateSeriesTimer' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'updateTimer' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addListingProvider
     *
     * Adds a listings provider.
     *
     * @param  string $pw Password. (optional)
     * @param  bool $validate_listings Validate listings. (optional, default to false)
     * @param  bool $validate_login Validate login. (optional, default to false)
     * @param  \OpenAPI\Client\Model\AddListingProviderRequest $add_listing_provider_request New listings info. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addListingProvider'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListingsProviderInfo
     */
    public function addListingProvider($pw = null, $validate_listings = false, $validate_login = false, $add_listing_provider_request = null, string $contentType = self::contentTypes['addListingProvider'][0])
    {
        list($response) = $this->addListingProviderWithHttpInfo($pw, $validate_listings, $validate_login, $add_listing_provider_request, $contentType);
        return $response;
    }

    /**
     * Operation addListingProviderWithHttpInfo
     *
     * Adds a listings provider.
     *
     * @param  string $pw Password. (optional)
     * @param  bool $validate_listings Validate listings. (optional, default to false)
     * @param  bool $validate_login Validate login. (optional, default to false)
     * @param  \OpenAPI\Client\Model\AddListingProviderRequest $add_listing_provider_request New listings info. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addListingProvider'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListingsProviderInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function addListingProviderWithHttpInfo($pw = null, $validate_listings = false, $validate_login = false, $add_listing_provider_request = null, string $contentType = self::contentTypes['addListingProvider'][0])
    {
        $request = $this->addListingProviderRequest($pw, $validate_listings, $validate_login, $add_listing_provider_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListingsProviderInfo' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListingsProviderInfo' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListingsProviderInfo', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ListingsProviderInfo';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListingsProviderInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addListingProviderAsync
     *
     * Adds a listings provider.
     *
     * @param  string $pw Password. (optional)
     * @param  bool $validate_listings Validate listings. (optional, default to false)
     * @param  bool $validate_login Validate login. (optional, default to false)
     * @param  \OpenAPI\Client\Model\AddListingProviderRequest $add_listing_provider_request New listings info. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addListingProvider'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addListingProviderAsync($pw = null, $validate_listings = false, $validate_login = false, $add_listing_provider_request = null, string $contentType = self::contentTypes['addListingProvider'][0])
    {
        return $this->addListingProviderAsyncWithHttpInfo($pw, $validate_listings, $validate_login, $add_listing_provider_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addListingProviderAsyncWithHttpInfo
     *
     * Adds a listings provider.
     *
     * @param  string $pw Password. (optional)
     * @param  bool $validate_listings Validate listings. (optional, default to false)
     * @param  bool $validate_login Validate login. (optional, default to false)
     * @param  \OpenAPI\Client\Model\AddListingProviderRequest $add_listing_provider_request New listings info. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addListingProvider'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addListingProviderAsyncWithHttpInfo($pw = null, $validate_listings = false, $validate_login = false, $add_listing_provider_request = null, string $contentType = self::contentTypes['addListingProvider'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListingsProviderInfo';
        $request = $this->addListingProviderRequest($pw, $validate_listings, $validate_login, $add_listing_provider_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addListingProvider'
     *
     * @param  string $pw Password. (optional)
     * @param  bool $validate_listings Validate listings. (optional, default to false)
     * @param  bool $validate_login Validate login. (optional, default to false)
     * @param  \OpenAPI\Client\Model\AddListingProviderRequest $add_listing_provider_request New listings info. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addListingProvider'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addListingProviderRequest($pw = null, $validate_listings = false, $validate_login = false, $add_listing_provider_request = null, string $contentType = self::contentTypes['addListingProvider'][0])
    {






        $resourcePath = '/LiveTv/ListingProviders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pw,
            'pw', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validate_listings,
            'validateListings', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validate_login,
            'validateLogin', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($add_listing_provider_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($add_listing_provider_request));
            } else {
                $httpBody = $add_listing_provider_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addTunerHost
     *
     * Adds a tuner host.
     *
     * @param  \OpenAPI\Client\Model\AddTunerHostRequest $add_tuner_host_request New tuner host. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addTunerHost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TunerHostInfo
     */
    public function addTunerHost($add_tuner_host_request = null, string $contentType = self::contentTypes['addTunerHost'][0])
    {
        list($response) = $this->addTunerHostWithHttpInfo($add_tuner_host_request, $contentType);
        return $response;
    }

    /**
     * Operation addTunerHostWithHttpInfo
     *
     * Adds a tuner host.
     *
     * @param  \OpenAPI\Client\Model\AddTunerHostRequest $add_tuner_host_request New tuner host. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addTunerHost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TunerHostInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function addTunerHostWithHttpInfo($add_tuner_host_request = null, string $contentType = self::contentTypes['addTunerHost'][0])
    {
        $request = $this->addTunerHostRequest($add_tuner_host_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\TunerHostInfo' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\TunerHostInfo' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TunerHostInfo', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TunerHostInfo';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TunerHostInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addTunerHostAsync
     *
     * Adds a tuner host.
     *
     * @param  \OpenAPI\Client\Model\AddTunerHostRequest $add_tuner_host_request New tuner host. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addTunerHost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addTunerHostAsync($add_tuner_host_request = null, string $contentType = self::contentTypes['addTunerHost'][0])
    {
        return $this->addTunerHostAsyncWithHttpInfo($add_tuner_host_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addTunerHostAsyncWithHttpInfo
     *
     * Adds a tuner host.
     *
     * @param  \OpenAPI\Client\Model\AddTunerHostRequest $add_tuner_host_request New tuner host. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addTunerHost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addTunerHostAsyncWithHttpInfo($add_tuner_host_request = null, string $contentType = self::contentTypes['addTunerHost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TunerHostInfo';
        $request = $this->addTunerHostRequest($add_tuner_host_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addTunerHost'
     *
     * @param  \OpenAPI\Client\Model\AddTunerHostRequest $add_tuner_host_request New tuner host. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addTunerHost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addTunerHostRequest($add_tuner_host_request = null, string $contentType = self::contentTypes['addTunerHost'][0])
    {



        $resourcePath = '/LiveTv/TunerHosts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($add_tuner_host_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($add_tuner_host_request));
            } else {
                $httpBody = $add_tuner_host_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelSeriesTimer
     *
     * Cancels a live tv series timer.
     *
     * @param  string $timer_id Timer id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelSeriesTimer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cancelSeriesTimer($timer_id, string $contentType = self::contentTypes['cancelSeriesTimer'][0])
    {
        $this->cancelSeriesTimerWithHttpInfo($timer_id, $contentType);
    }

    /**
     * Operation cancelSeriesTimerWithHttpInfo
     *
     * Cancels a live tv series timer.
     *
     * @param  string $timer_id Timer id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelSeriesTimer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelSeriesTimerWithHttpInfo($timer_id, string $contentType = self::contentTypes['cancelSeriesTimer'][0])
    {
        $request = $this->cancelSeriesTimerRequest($timer_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cancelSeriesTimerAsync
     *
     * Cancels a live tv series timer.
     *
     * @param  string $timer_id Timer id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelSeriesTimer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelSeriesTimerAsync($timer_id, string $contentType = self::contentTypes['cancelSeriesTimer'][0])
    {
        return $this->cancelSeriesTimerAsyncWithHttpInfo($timer_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelSeriesTimerAsyncWithHttpInfo
     *
     * Cancels a live tv series timer.
     *
     * @param  string $timer_id Timer id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelSeriesTimer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelSeriesTimerAsyncWithHttpInfo($timer_id, string $contentType = self::contentTypes['cancelSeriesTimer'][0])
    {
        $returnType = '';
        $request = $this->cancelSeriesTimerRequest($timer_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelSeriesTimer'
     *
     * @param  string $timer_id Timer id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelSeriesTimer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cancelSeriesTimerRequest($timer_id, string $contentType = self::contentTypes['cancelSeriesTimer'][0])
    {

        // verify the required parameter 'timer_id' is set
        if ($timer_id === null || (is_array($timer_id) && count($timer_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $timer_id when calling cancelSeriesTimer'
            );
        }


        $resourcePath = '/LiveTv/SeriesTimers/{timerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($timer_id !== null) {
            $resourcePath = str_replace(
                '{' . 'timerId' . '}',
                ObjectSerializer::toPathValue($timer_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelTimer
     *
     * Cancels a live tv timer.
     *
     * @param  string $timer_id Timer id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelTimer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cancelTimer($timer_id, string $contentType = self::contentTypes['cancelTimer'][0])
    {
        $this->cancelTimerWithHttpInfo($timer_id, $contentType);
    }

    /**
     * Operation cancelTimerWithHttpInfo
     *
     * Cancels a live tv timer.
     *
     * @param  string $timer_id Timer id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelTimer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelTimerWithHttpInfo($timer_id, string $contentType = self::contentTypes['cancelTimer'][0])
    {
        $request = $this->cancelTimerRequest($timer_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cancelTimerAsync
     *
     * Cancels a live tv timer.
     *
     * @param  string $timer_id Timer id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelTimer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelTimerAsync($timer_id, string $contentType = self::contentTypes['cancelTimer'][0])
    {
        return $this->cancelTimerAsyncWithHttpInfo($timer_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelTimerAsyncWithHttpInfo
     *
     * Cancels a live tv timer.
     *
     * @param  string $timer_id Timer id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelTimer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelTimerAsyncWithHttpInfo($timer_id, string $contentType = self::contentTypes['cancelTimer'][0])
    {
        $returnType = '';
        $request = $this->cancelTimerRequest($timer_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelTimer'
     *
     * @param  string $timer_id Timer id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelTimer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cancelTimerRequest($timer_id, string $contentType = self::contentTypes['cancelTimer'][0])
    {

        // verify the required parameter 'timer_id' is set
        if ($timer_id === null || (is_array($timer_id) && count($timer_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $timer_id when calling cancelTimer'
            );
        }


        $resourcePath = '/LiveTv/Timers/{timerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($timer_id !== null) {
            $resourcePath = str_replace(
                '{' . 'timerId' . '}',
                ObjectSerializer::toPathValue($timer_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createSeriesTimer
     *
     * Creates a live tv series timer.
     *
     * @param  \OpenAPI\Client\Model\CreateSeriesTimerRequest $create_series_timer_request New series timer info. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSeriesTimer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createSeriesTimer($create_series_timer_request = null, string $contentType = self::contentTypes['createSeriesTimer'][0])
    {
        $this->createSeriesTimerWithHttpInfo($create_series_timer_request, $contentType);
    }

    /**
     * Operation createSeriesTimerWithHttpInfo
     *
     * Creates a live tv series timer.
     *
     * @param  \OpenAPI\Client\Model\CreateSeriesTimerRequest $create_series_timer_request New series timer info. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSeriesTimer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createSeriesTimerWithHttpInfo($create_series_timer_request = null, string $contentType = self::contentTypes['createSeriesTimer'][0])
    {
        $request = $this->createSeriesTimerRequest($create_series_timer_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation createSeriesTimerAsync
     *
     * Creates a live tv series timer.
     *
     * @param  \OpenAPI\Client\Model\CreateSeriesTimerRequest $create_series_timer_request New series timer info. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSeriesTimer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSeriesTimerAsync($create_series_timer_request = null, string $contentType = self::contentTypes['createSeriesTimer'][0])
    {
        return $this->createSeriesTimerAsyncWithHttpInfo($create_series_timer_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createSeriesTimerAsyncWithHttpInfo
     *
     * Creates a live tv series timer.
     *
     * @param  \OpenAPI\Client\Model\CreateSeriesTimerRequest $create_series_timer_request New series timer info. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSeriesTimer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSeriesTimerAsyncWithHttpInfo($create_series_timer_request = null, string $contentType = self::contentTypes['createSeriesTimer'][0])
    {
        $returnType = '';
        $request = $this->createSeriesTimerRequest($create_series_timer_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createSeriesTimer'
     *
     * @param  \OpenAPI\Client\Model\CreateSeriesTimerRequest $create_series_timer_request New series timer info. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSeriesTimer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createSeriesTimerRequest($create_series_timer_request = null, string $contentType = self::contentTypes['createSeriesTimer'][0])
    {



        $resourcePath = '/LiveTv/SeriesTimers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_series_timer_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_series_timer_request));
            } else {
                $httpBody = $create_series_timer_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTimer
     *
     * Creates a live tv timer.
     *
     * @param  \OpenAPI\Client\Model\CreateTimerRequest $create_timer_request New timer info. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTimer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createTimer($create_timer_request = null, string $contentType = self::contentTypes['createTimer'][0])
    {
        $this->createTimerWithHttpInfo($create_timer_request, $contentType);
    }

    /**
     * Operation createTimerWithHttpInfo
     *
     * Creates a live tv timer.
     *
     * @param  \OpenAPI\Client\Model\CreateTimerRequest $create_timer_request New timer info. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTimer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTimerWithHttpInfo($create_timer_request = null, string $contentType = self::contentTypes['createTimer'][0])
    {
        $request = $this->createTimerRequest($create_timer_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation createTimerAsync
     *
     * Creates a live tv timer.
     *
     * @param  \OpenAPI\Client\Model\CreateTimerRequest $create_timer_request New timer info. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTimer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTimerAsync($create_timer_request = null, string $contentType = self::contentTypes['createTimer'][0])
    {
        return $this->createTimerAsyncWithHttpInfo($create_timer_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTimerAsyncWithHttpInfo
     *
     * Creates a live tv timer.
     *
     * @param  \OpenAPI\Client\Model\CreateTimerRequest $create_timer_request New timer info. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTimer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTimerAsyncWithHttpInfo($create_timer_request = null, string $contentType = self::contentTypes['createTimer'][0])
    {
        $returnType = '';
        $request = $this->createTimerRequest($create_timer_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTimer'
     *
     * @param  \OpenAPI\Client\Model\CreateTimerRequest $create_timer_request New timer info. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTimer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createTimerRequest($create_timer_request = null, string $contentType = self::contentTypes['createTimer'][0])
    {



        $resourcePath = '/LiveTv/Timers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_timer_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_timer_request));
            } else {
                $httpBody = $create_timer_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteListingProvider
     *
     * Delete listing provider.
     *
     * @param  string $id Listing provider id. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteListingProvider'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteListingProvider($id = null, string $contentType = self::contentTypes['deleteListingProvider'][0])
    {
        $this->deleteListingProviderWithHttpInfo($id, $contentType);
    }

    /**
     * Operation deleteListingProviderWithHttpInfo
     *
     * Delete listing provider.
     *
     * @param  string $id Listing provider id. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteListingProvider'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteListingProviderWithHttpInfo($id = null, string $contentType = self::contentTypes['deleteListingProvider'][0])
    {
        $request = $this->deleteListingProviderRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteListingProviderAsync
     *
     * Delete listing provider.
     *
     * @param  string $id Listing provider id. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteListingProvider'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteListingProviderAsync($id = null, string $contentType = self::contentTypes['deleteListingProvider'][0])
    {
        return $this->deleteListingProviderAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteListingProviderAsyncWithHttpInfo
     *
     * Delete listing provider.
     *
     * @param  string $id Listing provider id. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteListingProvider'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteListingProviderAsyncWithHttpInfo($id = null, string $contentType = self::contentTypes['deleteListingProvider'][0])
    {
        $returnType = '';
        $request = $this->deleteListingProviderRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteListingProvider'
     *
     * @param  string $id Listing provider id. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteListingProvider'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteListingProviderRequest($id = null, string $contentType = self::contentTypes['deleteListingProvider'][0])
    {



        $resourcePath = '/LiveTv/ListingProviders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRecording
     *
     * Deletes a live tv recording.
     *
     * @param  string $recording_id Recording id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecording'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteRecording($recording_id, string $contentType = self::contentTypes['deleteRecording'][0])
    {
        $this->deleteRecordingWithHttpInfo($recording_id, $contentType);
    }

    /**
     * Operation deleteRecordingWithHttpInfo
     *
     * Deletes a live tv recording.
     *
     * @param  string $recording_id Recording id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecording'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRecordingWithHttpInfo($recording_id, string $contentType = self::contentTypes['deleteRecording'][0])
    {
        $request = $this->deleteRecordingRequest($recording_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteRecordingAsync
     *
     * Deletes a live tv recording.
     *
     * @param  string $recording_id Recording id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecording'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRecordingAsync($recording_id, string $contentType = self::contentTypes['deleteRecording'][0])
    {
        return $this->deleteRecordingAsyncWithHttpInfo($recording_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRecordingAsyncWithHttpInfo
     *
     * Deletes a live tv recording.
     *
     * @param  string $recording_id Recording id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecording'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRecordingAsyncWithHttpInfo($recording_id, string $contentType = self::contentTypes['deleteRecording'][0])
    {
        $returnType = '';
        $request = $this->deleteRecordingRequest($recording_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRecording'
     *
     * @param  string $recording_id Recording id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecording'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteRecordingRequest($recording_id, string $contentType = self::contentTypes['deleteRecording'][0])
    {

        // verify the required parameter 'recording_id' is set
        if ($recording_id === null || (is_array($recording_id) && count($recording_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recording_id when calling deleteRecording'
            );
        }


        $resourcePath = '/LiveTv/Recordings/{recordingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($recording_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recordingId' . '}',
                ObjectSerializer::toPathValue($recording_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTunerHost
     *
     * Deletes a tuner host.
     *
     * @param  string $id Tuner host id. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTunerHost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTunerHost($id = null, string $contentType = self::contentTypes['deleteTunerHost'][0])
    {
        $this->deleteTunerHostWithHttpInfo($id, $contentType);
    }

    /**
     * Operation deleteTunerHostWithHttpInfo
     *
     * Deletes a tuner host.
     *
     * @param  string $id Tuner host id. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTunerHost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTunerHostWithHttpInfo($id = null, string $contentType = self::contentTypes['deleteTunerHost'][0])
    {
        $request = $this->deleteTunerHostRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTunerHostAsync
     *
     * Deletes a tuner host.
     *
     * @param  string $id Tuner host id. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTunerHost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTunerHostAsync($id = null, string $contentType = self::contentTypes['deleteTunerHost'][0])
    {
        return $this->deleteTunerHostAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTunerHostAsyncWithHttpInfo
     *
     * Deletes a tuner host.
     *
     * @param  string $id Tuner host id. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTunerHost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTunerHostAsyncWithHttpInfo($id = null, string $contentType = self::contentTypes['deleteTunerHost'][0])
    {
        $returnType = '';
        $request = $this->deleteTunerHostRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTunerHost'
     *
     * @param  string $id Tuner host id. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTunerHost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteTunerHostRequest($id = null, string $contentType = self::contentTypes['deleteTunerHost'][0])
    {



        $resourcePath = '/LiveTv/TunerHosts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation discoverTuners
     *
     * Discover tuners.
     *
     * @param  bool $new_devices_only Only discover new tuners. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discoverTuners'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TunerHostInfo[]
     */
    public function discoverTuners($new_devices_only = false, string $contentType = self::contentTypes['discoverTuners'][0])
    {
        list($response) = $this->discoverTunersWithHttpInfo($new_devices_only, $contentType);
        return $response;
    }

    /**
     * Operation discoverTunersWithHttpInfo
     *
     * Discover tuners.
     *
     * @param  bool $new_devices_only Only discover new tuners. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discoverTuners'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TunerHostInfo[], HTTP status code, HTTP response headers (array of strings)
     */
    public function discoverTunersWithHttpInfo($new_devices_only = false, string $contentType = self::contentTypes['discoverTuners'][0])
    {
        $request = $this->discoverTunersRequest($new_devices_only, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\TunerHostInfo[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\TunerHostInfo[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TunerHostInfo[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TunerHostInfo[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TunerHostInfo[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation discoverTunersAsync
     *
     * Discover tuners.
     *
     * @param  bool $new_devices_only Only discover new tuners. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discoverTuners'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function discoverTunersAsync($new_devices_only = false, string $contentType = self::contentTypes['discoverTuners'][0])
    {
        return $this->discoverTunersAsyncWithHttpInfo($new_devices_only, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation discoverTunersAsyncWithHttpInfo
     *
     * Discover tuners.
     *
     * @param  bool $new_devices_only Only discover new tuners. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discoverTuners'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function discoverTunersAsyncWithHttpInfo($new_devices_only = false, string $contentType = self::contentTypes['discoverTuners'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TunerHostInfo[]';
        $request = $this->discoverTunersRequest($new_devices_only, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'discoverTuners'
     *
     * @param  bool $new_devices_only Only discover new tuners. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discoverTuners'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function discoverTunersRequest($new_devices_only = false, string $contentType = self::contentTypes['discoverTuners'][0])
    {



        $resourcePath = '/LiveTv/Tuners/Discover';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $new_devices_only,
            'newDevicesOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation discvoverTuners
     *
     * Discover tuners.
     *
     * @param  bool $new_devices_only Only discover new tuners. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discvoverTuners'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TunerHostInfo[]
     */
    public function discvoverTuners($new_devices_only = false, string $contentType = self::contentTypes['discvoverTuners'][0])
    {
        list($response) = $this->discvoverTunersWithHttpInfo($new_devices_only, $contentType);
        return $response;
    }

    /**
     * Operation discvoverTunersWithHttpInfo
     *
     * Discover tuners.
     *
     * @param  bool $new_devices_only Only discover new tuners. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discvoverTuners'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TunerHostInfo[], HTTP status code, HTTP response headers (array of strings)
     */
    public function discvoverTunersWithHttpInfo($new_devices_only = false, string $contentType = self::contentTypes['discvoverTuners'][0])
    {
        $request = $this->discvoverTunersRequest($new_devices_only, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\TunerHostInfo[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\TunerHostInfo[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TunerHostInfo[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TunerHostInfo[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TunerHostInfo[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation discvoverTunersAsync
     *
     * Discover tuners.
     *
     * @param  bool $new_devices_only Only discover new tuners. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discvoverTuners'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function discvoverTunersAsync($new_devices_only = false, string $contentType = self::contentTypes['discvoverTuners'][0])
    {
        return $this->discvoverTunersAsyncWithHttpInfo($new_devices_only, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation discvoverTunersAsyncWithHttpInfo
     *
     * Discover tuners.
     *
     * @param  bool $new_devices_only Only discover new tuners. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discvoverTuners'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function discvoverTunersAsyncWithHttpInfo($new_devices_only = false, string $contentType = self::contentTypes['discvoverTuners'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TunerHostInfo[]';
        $request = $this->discvoverTunersRequest($new_devices_only, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'discvoverTuners'
     *
     * @param  bool $new_devices_only Only discover new tuners. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['discvoverTuners'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function discvoverTunersRequest($new_devices_only = false, string $contentType = self::contentTypes['discvoverTuners'][0])
    {



        $resourcePath = '/LiveTv/Tuners/Discvover';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $new_devices_only,
            'newDevicesOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getChannel
     *
     * Gets a live tv channel.
     *
     * @param  string $channel_id Channel id. (required)
     * @param  string $user_id Optional. Attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChannel'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BaseItemDto
     */
    public function getChannel($channel_id, $user_id = null, string $contentType = self::contentTypes['getChannel'][0])
    {
        list($response) = $this->getChannelWithHttpInfo($channel_id, $user_id, $contentType);
        return $response;
    }

    /**
     * Operation getChannelWithHttpInfo
     *
     * Gets a live tv channel.
     *
     * @param  string $channel_id Channel id. (required)
     * @param  string $user_id Optional. Attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChannel'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BaseItemDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getChannelWithHttpInfo($channel_id, $user_id = null, string $contentType = self::contentTypes['getChannel'][0])
    {
        $request = $this->getChannelRequest($channel_id, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\BaseItemDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BaseItemDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BaseItemDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\BaseItemDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BaseItemDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getChannelAsync
     *
     * Gets a live tv channel.
     *
     * @param  string $channel_id Channel id. (required)
     * @param  string $user_id Optional. Attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChannel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChannelAsync($channel_id, $user_id = null, string $contentType = self::contentTypes['getChannel'][0])
    {
        return $this->getChannelAsyncWithHttpInfo($channel_id, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getChannelAsyncWithHttpInfo
     *
     * Gets a live tv channel.
     *
     * @param  string $channel_id Channel id. (required)
     * @param  string $user_id Optional. Attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChannel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChannelAsyncWithHttpInfo($channel_id, $user_id = null, string $contentType = self::contentTypes['getChannel'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BaseItemDto';
        $request = $this->getChannelRequest($channel_id, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getChannel'
     *
     * @param  string $channel_id Channel id. (required)
     * @param  string $user_id Optional. Attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChannel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getChannelRequest($channel_id, $user_id = null, string $contentType = self::contentTypes['getChannel'][0])
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling getChannel'
            );
        }



        $resourcePath = '/LiveTv/Channels/{channelId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'userId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getChannelMappingOptions
     *
     * Get channel mapping options.
     *
     * @param  string $provider_id Provider id. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChannelMappingOptions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ChannelMappingOptionsDto
     */
    public function getChannelMappingOptions($provider_id = null, string $contentType = self::contentTypes['getChannelMappingOptions'][0])
    {
        list($response) = $this->getChannelMappingOptionsWithHttpInfo($provider_id, $contentType);
        return $response;
    }

    /**
     * Operation getChannelMappingOptionsWithHttpInfo
     *
     * Get channel mapping options.
     *
     * @param  string $provider_id Provider id. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChannelMappingOptions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ChannelMappingOptionsDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getChannelMappingOptionsWithHttpInfo($provider_id = null, string $contentType = self::contentTypes['getChannelMappingOptions'][0])
    {
        $request = $this->getChannelMappingOptionsRequest($provider_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ChannelMappingOptionsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ChannelMappingOptionsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ChannelMappingOptionsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ChannelMappingOptionsDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ChannelMappingOptionsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getChannelMappingOptionsAsync
     *
     * Get channel mapping options.
     *
     * @param  string $provider_id Provider id. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChannelMappingOptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChannelMappingOptionsAsync($provider_id = null, string $contentType = self::contentTypes['getChannelMappingOptions'][0])
    {
        return $this->getChannelMappingOptionsAsyncWithHttpInfo($provider_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getChannelMappingOptionsAsyncWithHttpInfo
     *
     * Get channel mapping options.
     *
     * @param  string $provider_id Provider id. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChannelMappingOptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChannelMappingOptionsAsyncWithHttpInfo($provider_id = null, string $contentType = self::contentTypes['getChannelMappingOptions'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ChannelMappingOptionsDto';
        $request = $this->getChannelMappingOptionsRequest($provider_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getChannelMappingOptions'
     *
     * @param  string $provider_id Provider id. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChannelMappingOptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getChannelMappingOptionsRequest($provider_id = null, string $contentType = self::contentTypes['getChannelMappingOptions'][0])
    {



        $resourcePath = '/LiveTv/ChannelMappingOptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_id,
            'providerId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDefaultListingProvider
     *
     * Gets default listings provider info.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDefaultListingProvider'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListingsProviderInfo
     */
    public function getDefaultListingProvider(string $contentType = self::contentTypes['getDefaultListingProvider'][0])
    {
        list($response) = $this->getDefaultListingProviderWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getDefaultListingProviderWithHttpInfo
     *
     * Gets default listings provider info.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDefaultListingProvider'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListingsProviderInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDefaultListingProviderWithHttpInfo(string $contentType = self::contentTypes['getDefaultListingProvider'][0])
    {
        $request = $this->getDefaultListingProviderRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListingsProviderInfo' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListingsProviderInfo' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListingsProviderInfo', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ListingsProviderInfo';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListingsProviderInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDefaultListingProviderAsync
     *
     * Gets default listings provider info.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDefaultListingProvider'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDefaultListingProviderAsync(string $contentType = self::contentTypes['getDefaultListingProvider'][0])
    {
        return $this->getDefaultListingProviderAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDefaultListingProviderAsyncWithHttpInfo
     *
     * Gets default listings provider info.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDefaultListingProvider'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDefaultListingProviderAsyncWithHttpInfo(string $contentType = self::contentTypes['getDefaultListingProvider'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListingsProviderInfo';
        $request = $this->getDefaultListingProviderRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDefaultListingProvider'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDefaultListingProvider'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDefaultListingProviderRequest(string $contentType = self::contentTypes['getDefaultListingProvider'][0])
    {


        $resourcePath = '/LiveTv/ListingProviders/Default';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDefaultTimer
     *
     * Gets the default values for a new timer.
     *
     * @param  string $program_id Optional. To attach default values based on a program. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDefaultTimer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SeriesTimerInfoDto
     */
    public function getDefaultTimer($program_id = null, string $contentType = self::contentTypes['getDefaultTimer'][0])
    {
        list($response) = $this->getDefaultTimerWithHttpInfo($program_id, $contentType);
        return $response;
    }

    /**
     * Operation getDefaultTimerWithHttpInfo
     *
     * Gets the default values for a new timer.
     *
     * @param  string $program_id Optional. To attach default values based on a program. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDefaultTimer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SeriesTimerInfoDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDefaultTimerWithHttpInfo($program_id = null, string $contentType = self::contentTypes['getDefaultTimer'][0])
    {
        $request = $this->getDefaultTimerRequest($program_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SeriesTimerInfoDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SeriesTimerInfoDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SeriesTimerInfoDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SeriesTimerInfoDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SeriesTimerInfoDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDefaultTimerAsync
     *
     * Gets the default values for a new timer.
     *
     * @param  string $program_id Optional. To attach default values based on a program. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDefaultTimer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDefaultTimerAsync($program_id = null, string $contentType = self::contentTypes['getDefaultTimer'][0])
    {
        return $this->getDefaultTimerAsyncWithHttpInfo($program_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDefaultTimerAsyncWithHttpInfo
     *
     * Gets the default values for a new timer.
     *
     * @param  string $program_id Optional. To attach default values based on a program. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDefaultTimer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDefaultTimerAsyncWithHttpInfo($program_id = null, string $contentType = self::contentTypes['getDefaultTimer'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SeriesTimerInfoDto';
        $request = $this->getDefaultTimerRequest($program_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDefaultTimer'
     *
     * @param  string $program_id Optional. To attach default values based on a program. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDefaultTimer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDefaultTimerRequest($program_id = null, string $contentType = self::contentTypes['getDefaultTimer'][0])
    {



        $resourcePath = '/LiveTv/Timers/Defaults';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $program_id,
            'programId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuideInfo
     *
     * Get guid info.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuideInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuideInfo
     */
    public function getGuideInfo(string $contentType = self::contentTypes['getGuideInfo'][0])
    {
        list($response) = $this->getGuideInfoWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getGuideInfoWithHttpInfo
     *
     * Get guid info.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuideInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuideInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuideInfoWithHttpInfo(string $contentType = self::contentTypes['getGuideInfo'][0])
    {
        $request = $this->getGuideInfoRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuideInfo' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuideInfo' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuideInfo', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\GuideInfo';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuideInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGuideInfoAsync
     *
     * Get guid info.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuideInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGuideInfoAsync(string $contentType = self::contentTypes['getGuideInfo'][0])
    {
        return $this->getGuideInfoAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuideInfoAsyncWithHttpInfo
     *
     * Get guid info.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuideInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGuideInfoAsyncWithHttpInfo(string $contentType = self::contentTypes['getGuideInfo'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GuideInfo';
        $request = $this->getGuideInfoRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuideInfo'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuideInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGuideInfoRequest(string $contentType = self::contentTypes['getGuideInfo'][0])
    {


        $resourcePath = '/LiveTv/GuideInfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLineups
     *
     * Gets available lineups.
     *
     * @param  string $id Provider id. (optional)
     * @param  string $type Provider type. (optional)
     * @param  string $location Location. (optional)
     * @param  string $country Country. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLineups'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\NameIdPair[]
     */
    public function getLineups($id = null, $type = null, $location = null, $country = null, string $contentType = self::contentTypes['getLineups'][0])
    {
        list($response) = $this->getLineupsWithHttpInfo($id, $type, $location, $country, $contentType);
        return $response;
    }

    /**
     * Operation getLineupsWithHttpInfo
     *
     * Gets available lineups.
     *
     * @param  string $id Provider id. (optional)
     * @param  string $type Provider type. (optional)
     * @param  string $location Location. (optional)
     * @param  string $country Country. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLineups'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\NameIdPair[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getLineupsWithHttpInfo($id = null, $type = null, $location = null, $country = null, string $contentType = self::contentTypes['getLineups'][0])
    {
        $request = $this->getLineupsRequest($id, $type, $location, $country, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\NameIdPair[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\NameIdPair[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\NameIdPair[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\NameIdPair[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\NameIdPair[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLineupsAsync
     *
     * Gets available lineups.
     *
     * @param  string $id Provider id. (optional)
     * @param  string $type Provider type. (optional)
     * @param  string $location Location. (optional)
     * @param  string $country Country. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLineups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLineupsAsync($id = null, $type = null, $location = null, $country = null, string $contentType = self::contentTypes['getLineups'][0])
    {
        return $this->getLineupsAsyncWithHttpInfo($id, $type, $location, $country, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLineupsAsyncWithHttpInfo
     *
     * Gets available lineups.
     *
     * @param  string $id Provider id. (optional)
     * @param  string $type Provider type. (optional)
     * @param  string $location Location. (optional)
     * @param  string $country Country. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLineups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLineupsAsyncWithHttpInfo($id = null, $type = null, $location = null, $country = null, string $contentType = self::contentTypes['getLineups'][0])
    {
        $returnType = '\OpenAPI\Client\Model\NameIdPair[]';
        $request = $this->getLineupsRequest($id, $type, $location, $country, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLineups'
     *
     * @param  string $id Provider id. (optional)
     * @param  string $type Provider type. (optional)
     * @param  string $location Location. (optional)
     * @param  string $country Country. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLineups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getLineupsRequest($id = null, $type = null, $location = null, $country = null, string $contentType = self::contentTypes['getLineups'][0])
    {






        $resourcePath = '/LiveTv/ListingProviders/Lineups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $location,
            'location', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $country,
            'country', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLiveRecordingFile
     *
     * Gets a live tv recording stream.
     *
     * @param  string $recording_id Recording id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveRecordingFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function getLiveRecordingFile($recording_id, string $contentType = self::contentTypes['getLiveRecordingFile'][0])
    {
        list($response) = $this->getLiveRecordingFileWithHttpInfo($recording_id, $contentType);
        return $response;
    }

    /**
     * Operation getLiveRecordingFileWithHttpInfo
     *
     * Gets a live tv recording stream.
     *
     * @param  string $recording_id Recording id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveRecordingFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLiveRecordingFileWithHttpInfo($recording_id, string $contentType = self::contentTypes['getLiveRecordingFile'][0])
    {
        $request = $this->getLiveRecordingFileRequest($recording_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLiveRecordingFileAsync
     *
     * Gets a live tv recording stream.
     *
     * @param  string $recording_id Recording id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveRecordingFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLiveRecordingFileAsync($recording_id, string $contentType = self::contentTypes['getLiveRecordingFile'][0])
    {
        return $this->getLiveRecordingFileAsyncWithHttpInfo($recording_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLiveRecordingFileAsyncWithHttpInfo
     *
     * Gets a live tv recording stream.
     *
     * @param  string $recording_id Recording id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveRecordingFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLiveRecordingFileAsyncWithHttpInfo($recording_id, string $contentType = self::contentTypes['getLiveRecordingFile'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getLiveRecordingFileRequest($recording_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLiveRecordingFile'
     *
     * @param  string $recording_id Recording id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveRecordingFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getLiveRecordingFileRequest($recording_id, string $contentType = self::contentTypes['getLiveRecordingFile'][0])
    {

        // verify the required parameter 'recording_id' is set
        if ($recording_id === null || (is_array($recording_id) && count($recording_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recording_id when calling getLiveRecordingFile'
            );
        }


        $resourcePath = '/LiveTv/LiveRecordings/{recordingId}/stream';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($recording_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recordingId' . '}',
                ObjectSerializer::toPathValue($recording_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['video/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLiveStreamFile
     *
     * Gets a live tv channel stream.
     *
     * @param  string $stream_id Stream id. (required)
     * @param  string $container Container type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveStreamFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ProblemDetails
     */
    public function getLiveStreamFile($stream_id, $container, string $contentType = self::contentTypes['getLiveStreamFile'][0])
    {
        list($response) = $this->getLiveStreamFileWithHttpInfo($stream_id, $container, $contentType);
        return $response;
    }

    /**
     * Operation getLiveStreamFileWithHttpInfo
     *
     * Gets a live tv channel stream.
     *
     * @param  string $stream_id Stream id. (required)
     * @param  string $container Container type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveStreamFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLiveStreamFileWithHttpInfo($stream_id, $container, string $contentType = self::contentTypes['getLiveStreamFile'][0])
    {
        $request = $this->getLiveStreamFileRequest($stream_id, $container, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLiveStreamFileAsync
     *
     * Gets a live tv channel stream.
     *
     * @param  string $stream_id Stream id. (required)
     * @param  string $container Container type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveStreamFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLiveStreamFileAsync($stream_id, $container, string $contentType = self::contentTypes['getLiveStreamFile'][0])
    {
        return $this->getLiveStreamFileAsyncWithHttpInfo($stream_id, $container, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLiveStreamFileAsyncWithHttpInfo
     *
     * Gets a live tv channel stream.
     *
     * @param  string $stream_id Stream id. (required)
     * @param  string $container Container type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveStreamFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLiveStreamFileAsyncWithHttpInfo($stream_id, $container, string $contentType = self::contentTypes['getLiveStreamFile'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getLiveStreamFileRequest($stream_id, $container, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLiveStreamFile'
     *
     * @param  string $stream_id Stream id. (required)
     * @param  string $container Container type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveStreamFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getLiveStreamFileRequest($stream_id, $container, string $contentType = self::contentTypes['getLiveStreamFile'][0])
    {

        // verify the required parameter 'stream_id' is set
        if ($stream_id === null || (is_array($stream_id) && count($stream_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stream_id when calling getLiveStreamFile'
            );
        }

        // verify the required parameter 'container' is set
        if ($container === null || (is_array($container) && count($container) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $container when calling getLiveStreamFile'
            );
        }


        $resourcePath = '/LiveTv/LiveStreamFiles/{streamId}/stream.{container}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($stream_id !== null) {
            $resourcePath = str_replace(
                '{' . 'streamId' . '}',
                ObjectSerializer::toPathValue($stream_id),
                $resourcePath
            );
        }
        // path params
        if ($container !== null) {
            $resourcePath = str_replace(
                '{' . 'container' . '}',
                ObjectSerializer::toPathValue($container),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['video/*', 'application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLiveTvChannels
     *
     * Gets available live tv channels.
     *
     * @param  \OpenAPI\Client\Model\ChannelType $type Optional. Filter by channel type. (optional)
     * @param  string $user_id Optional. Filter by user and attach user data. (optional)
     * @param  int $start_index Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)
     * @param  bool $is_movie Optional. Filter for movies. (optional)
     * @param  bool $is_series Optional. Filter for series. (optional)
     * @param  bool $is_news Optional. Filter for news. (optional)
     * @param  bool $is_kids Optional. Filter for kids. (optional)
     * @param  bool $is_sports Optional. Filter for sports. (optional)
     * @param  int $limit Optional. The maximum number of records to return. (optional)
     * @param  bool $is_favorite Optional. Filter by channels that are favorites, or not. (optional)
     * @param  bool $is_liked Optional. Filter by channels that are liked, or not. (optional)
     * @param  bool $is_disliked Optional. Filter by channels that are disliked, or not. (optional)
     * @param  bool $enable_images Optional. Include image information in output. (optional)
     * @param  int $image_type_limit Optional. The max number of images to return, per image type. (optional)
     * @param  \OpenAPI\Client\Model\ImageType[] $enable_image_types \&quot;Optional. The image types to include in the output. (optional)
     * @param  \OpenAPI\Client\Model\ItemFields[] $fields Optional. Specify additional fields of information to return in the output. (optional)
     * @param  bool $enable_user_data Optional. Include user data. (optional)
     * @param  string[] $sort_by Optional. Key to sort by. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder $sort_order Optional. Sort order. (optional)
     * @param  bool $enable_favorite_sorting Optional. Incorporate favorite and like status into channel sorting. (optional, default to false)
     * @param  bool $add_current_program Optional. Adds current program info to each channel. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveTvChannels'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BaseItemDtoQueryResult
     */
    public function getLiveTvChannels($type = null, $user_id = null, $start_index = null, $is_movie = null, $is_series = null, $is_news = null, $is_kids = null, $is_sports = null, $limit = null, $is_favorite = null, $is_liked = null, $is_disliked = null, $enable_images = null, $image_type_limit = null, $enable_image_types = null, $fields = null, $enable_user_data = null, $sort_by = null, $sort_order = null, $enable_favorite_sorting = false, $add_current_program = true, string $contentType = self::contentTypes['getLiveTvChannels'][0])
    {
        list($response) = $this->getLiveTvChannelsWithHttpInfo($type, $user_id, $start_index, $is_movie, $is_series, $is_news, $is_kids, $is_sports, $limit, $is_favorite, $is_liked, $is_disliked, $enable_images, $image_type_limit, $enable_image_types, $fields, $enable_user_data, $sort_by, $sort_order, $enable_favorite_sorting, $add_current_program, $contentType);
        return $response;
    }

    /**
     * Operation getLiveTvChannelsWithHttpInfo
     *
     * Gets available live tv channels.
     *
     * @param  \OpenAPI\Client\Model\ChannelType $type Optional. Filter by channel type. (optional)
     * @param  string $user_id Optional. Filter by user and attach user data. (optional)
     * @param  int $start_index Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)
     * @param  bool $is_movie Optional. Filter for movies. (optional)
     * @param  bool $is_series Optional. Filter for series. (optional)
     * @param  bool $is_news Optional. Filter for news. (optional)
     * @param  bool $is_kids Optional. Filter for kids. (optional)
     * @param  bool $is_sports Optional. Filter for sports. (optional)
     * @param  int $limit Optional. The maximum number of records to return. (optional)
     * @param  bool $is_favorite Optional. Filter by channels that are favorites, or not. (optional)
     * @param  bool $is_liked Optional. Filter by channels that are liked, or not. (optional)
     * @param  bool $is_disliked Optional. Filter by channels that are disliked, or not. (optional)
     * @param  bool $enable_images Optional. Include image information in output. (optional)
     * @param  int $image_type_limit Optional. The max number of images to return, per image type. (optional)
     * @param  \OpenAPI\Client\Model\ImageType[] $enable_image_types \&quot;Optional. The image types to include in the output. (optional)
     * @param  \OpenAPI\Client\Model\ItemFields[] $fields Optional. Specify additional fields of information to return in the output. (optional)
     * @param  bool $enable_user_data Optional. Include user data. (optional)
     * @param  string[] $sort_by Optional. Key to sort by. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder $sort_order Optional. Sort order. (optional)
     * @param  bool $enable_favorite_sorting Optional. Incorporate favorite and like status into channel sorting. (optional, default to false)
     * @param  bool $add_current_program Optional. Adds current program info to each channel. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveTvChannels'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BaseItemDtoQueryResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLiveTvChannelsWithHttpInfo($type = null, $user_id = null, $start_index = null, $is_movie = null, $is_series = null, $is_news = null, $is_kids = null, $is_sports = null, $limit = null, $is_favorite = null, $is_liked = null, $is_disliked = null, $enable_images = null, $image_type_limit = null, $enable_image_types = null, $fields = null, $enable_user_data = null, $sort_by = null, $sort_order = null, $enable_favorite_sorting = false, $add_current_program = true, string $contentType = self::contentTypes['getLiveTvChannels'][0])
    {
        $request = $this->getLiveTvChannelsRequest($type, $user_id, $start_index, $is_movie, $is_series, $is_news, $is_kids, $is_sports, $limit, $is_favorite, $is_liked, $is_disliked, $enable_images, $image_type_limit, $enable_image_types, $fields, $enable_user_data, $sort_by, $sort_order, $enable_favorite_sorting, $add_current_program, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\BaseItemDtoQueryResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BaseItemDtoQueryResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BaseItemDtoQueryResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\BaseItemDtoQueryResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BaseItemDtoQueryResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLiveTvChannelsAsync
     *
     * Gets available live tv channels.
     *
     * @param  \OpenAPI\Client\Model\ChannelType $type Optional. Filter by channel type. (optional)
     * @param  string $user_id Optional. Filter by user and attach user data. (optional)
     * @param  int $start_index Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)
     * @param  bool $is_movie Optional. Filter for movies. (optional)
     * @param  bool $is_series Optional. Filter for series. (optional)
     * @param  bool $is_news Optional. Filter for news. (optional)
     * @param  bool $is_kids Optional. Filter for kids. (optional)
     * @param  bool $is_sports Optional. Filter for sports. (optional)
     * @param  int $limit Optional. The maximum number of records to return. (optional)
     * @param  bool $is_favorite Optional. Filter by channels that are favorites, or not. (optional)
     * @param  bool $is_liked Optional. Filter by channels that are liked, or not. (optional)
     * @param  bool $is_disliked Optional. Filter by channels that are disliked, or not. (optional)
     * @param  bool $enable_images Optional. Include image information in output. (optional)
     * @param  int $image_type_limit Optional. The max number of images to return, per image type. (optional)
     * @param  \OpenAPI\Client\Model\ImageType[] $enable_image_types \&quot;Optional. The image types to include in the output. (optional)
     * @param  \OpenAPI\Client\Model\ItemFields[] $fields Optional. Specify additional fields of information to return in the output. (optional)
     * @param  bool $enable_user_data Optional. Include user data. (optional)
     * @param  string[] $sort_by Optional. Key to sort by. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder $sort_order Optional. Sort order. (optional)
     * @param  bool $enable_favorite_sorting Optional. Incorporate favorite and like status into channel sorting. (optional, default to false)
     * @param  bool $add_current_program Optional. Adds current program info to each channel. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveTvChannels'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLiveTvChannelsAsync($type = null, $user_id = null, $start_index = null, $is_movie = null, $is_series = null, $is_news = null, $is_kids = null, $is_sports = null, $limit = null, $is_favorite = null, $is_liked = null, $is_disliked = null, $enable_images = null, $image_type_limit = null, $enable_image_types = null, $fields = null, $enable_user_data = null, $sort_by = null, $sort_order = null, $enable_favorite_sorting = false, $add_current_program = true, string $contentType = self::contentTypes['getLiveTvChannels'][0])
    {
        return $this->getLiveTvChannelsAsyncWithHttpInfo($type, $user_id, $start_index, $is_movie, $is_series, $is_news, $is_kids, $is_sports, $limit, $is_favorite, $is_liked, $is_disliked, $enable_images, $image_type_limit, $enable_image_types, $fields, $enable_user_data, $sort_by, $sort_order, $enable_favorite_sorting, $add_current_program, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLiveTvChannelsAsyncWithHttpInfo
     *
     * Gets available live tv channels.
     *
     * @param  \OpenAPI\Client\Model\ChannelType $type Optional. Filter by channel type. (optional)
     * @param  string $user_id Optional. Filter by user and attach user data. (optional)
     * @param  int $start_index Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)
     * @param  bool $is_movie Optional. Filter for movies. (optional)
     * @param  bool $is_series Optional. Filter for series. (optional)
     * @param  bool $is_news Optional. Filter for news. (optional)
     * @param  bool $is_kids Optional. Filter for kids. (optional)
     * @param  bool $is_sports Optional. Filter for sports. (optional)
     * @param  int $limit Optional. The maximum number of records to return. (optional)
     * @param  bool $is_favorite Optional. Filter by channels that are favorites, or not. (optional)
     * @param  bool $is_liked Optional. Filter by channels that are liked, or not. (optional)
     * @param  bool $is_disliked Optional. Filter by channels that are disliked, or not. (optional)
     * @param  bool $enable_images Optional. Include image information in output. (optional)
     * @param  int $image_type_limit Optional. The max number of images to return, per image type. (optional)
     * @param  \OpenAPI\Client\Model\ImageType[] $enable_image_types \&quot;Optional. The image types to include in the output. (optional)
     * @param  \OpenAPI\Client\Model\ItemFields[] $fields Optional. Specify additional fields of information to return in the output. (optional)
     * @param  bool $enable_user_data Optional. Include user data. (optional)
     * @param  string[] $sort_by Optional. Key to sort by. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder $sort_order Optional. Sort order. (optional)
     * @param  bool $enable_favorite_sorting Optional. Incorporate favorite and like status into channel sorting. (optional, default to false)
     * @param  bool $add_current_program Optional. Adds current program info to each channel. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveTvChannels'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLiveTvChannelsAsyncWithHttpInfo($type = null, $user_id = null, $start_index = null, $is_movie = null, $is_series = null, $is_news = null, $is_kids = null, $is_sports = null, $limit = null, $is_favorite = null, $is_liked = null, $is_disliked = null, $enable_images = null, $image_type_limit = null, $enable_image_types = null, $fields = null, $enable_user_data = null, $sort_by = null, $sort_order = null, $enable_favorite_sorting = false, $add_current_program = true, string $contentType = self::contentTypes['getLiveTvChannels'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BaseItemDtoQueryResult';
        $request = $this->getLiveTvChannelsRequest($type, $user_id, $start_index, $is_movie, $is_series, $is_news, $is_kids, $is_sports, $limit, $is_favorite, $is_liked, $is_disliked, $enable_images, $image_type_limit, $enable_image_types, $fields, $enable_user_data, $sort_by, $sort_order, $enable_favorite_sorting, $add_current_program, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLiveTvChannels'
     *
     * @param  \OpenAPI\Client\Model\ChannelType $type Optional. Filter by channel type. (optional)
     * @param  string $user_id Optional. Filter by user and attach user data. (optional)
     * @param  int $start_index Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)
     * @param  bool $is_movie Optional. Filter for movies. (optional)
     * @param  bool $is_series Optional. Filter for series. (optional)
     * @param  bool $is_news Optional. Filter for news. (optional)
     * @param  bool $is_kids Optional. Filter for kids. (optional)
     * @param  bool $is_sports Optional. Filter for sports. (optional)
     * @param  int $limit Optional. The maximum number of records to return. (optional)
     * @param  bool $is_favorite Optional. Filter by channels that are favorites, or not. (optional)
     * @param  bool $is_liked Optional. Filter by channels that are liked, or not. (optional)
     * @param  bool $is_disliked Optional. Filter by channels that are disliked, or not. (optional)
     * @param  bool $enable_images Optional. Include image information in output. (optional)
     * @param  int $image_type_limit Optional. The max number of images to return, per image type. (optional)
     * @param  \OpenAPI\Client\Model\ImageType[] $enable_image_types \&quot;Optional. The image types to include in the output. (optional)
     * @param  \OpenAPI\Client\Model\ItemFields[] $fields Optional. Specify additional fields of information to return in the output. (optional)
     * @param  bool $enable_user_data Optional. Include user data. (optional)
     * @param  string[] $sort_by Optional. Key to sort by. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder $sort_order Optional. Sort order. (optional)
     * @param  bool $enable_favorite_sorting Optional. Incorporate favorite and like status into channel sorting. (optional, default to false)
     * @param  bool $add_current_program Optional. Adds current program info to each channel. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveTvChannels'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getLiveTvChannelsRequest($type = null, $user_id = null, $start_index = null, $is_movie = null, $is_series = null, $is_news = null, $is_kids = null, $is_sports = null, $limit = null, $is_favorite = null, $is_liked = null, $is_disliked = null, $enable_images = null, $image_type_limit = null, $enable_image_types = null, $fields = null, $enable_user_data = null, $sort_by = null, $sort_order = null, $enable_favorite_sorting = false, $add_current_program = true, string $contentType = self::contentTypes['getLiveTvChannels'][0])
    {























        $resourcePath = '/LiveTv/Channels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'ChannelType', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'userId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_index,
            'startIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_movie,
            'isMovie', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_series,
            'isSeries', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_news,
            'isNews', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_kids,
            'isKids', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_sports,
            'isSports', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_favorite,
            'isFavorite', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_liked,
            'isLiked', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_disliked,
            'isDisliked', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_images,
            'enableImages', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_type_limit,
            'imageTypeLimit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_image_types,
            'enableImageTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fields,
            'fields', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_user_data,
            'enableUserData', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_by,
            'sortBy', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sortOrder', // param base name
            'SortOrder', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_favorite_sorting,
            'enableFavoriteSorting', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_current_program,
            'addCurrentProgram', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLiveTvInfo
     *
     * Gets available live tv services.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveTvInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\LiveTvInfo
     */
    public function getLiveTvInfo(string $contentType = self::contentTypes['getLiveTvInfo'][0])
    {
        list($response) = $this->getLiveTvInfoWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getLiveTvInfoWithHttpInfo
     *
     * Gets available live tv services.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveTvInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\LiveTvInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLiveTvInfoWithHttpInfo(string $contentType = self::contentTypes['getLiveTvInfo'][0])
    {
        $request = $this->getLiveTvInfoRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\LiveTvInfo' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\LiveTvInfo' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\LiveTvInfo', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\LiveTvInfo';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\LiveTvInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLiveTvInfoAsync
     *
     * Gets available live tv services.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveTvInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLiveTvInfoAsync(string $contentType = self::contentTypes['getLiveTvInfo'][0])
    {
        return $this->getLiveTvInfoAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLiveTvInfoAsyncWithHttpInfo
     *
     * Gets available live tv services.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveTvInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLiveTvInfoAsyncWithHttpInfo(string $contentType = self::contentTypes['getLiveTvInfo'][0])
    {
        $returnType = '\OpenAPI\Client\Model\LiveTvInfo';
        $request = $this->getLiveTvInfoRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLiveTvInfo'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveTvInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getLiveTvInfoRequest(string $contentType = self::contentTypes['getLiveTvInfo'][0])
    {


        $resourcePath = '/LiveTv/Info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLiveTvPrograms
     *
     * Gets available live tv epgs.
     *
     * @param  string[] $channel_ids The channels to return guide information for. (optional)
     * @param  string $user_id Optional. Filter by user id. (optional)
     * @param  \DateTime $min_start_date Optional. The minimum premiere start date. (optional)
     * @param  bool $has_aired Optional. Filter by programs that have completed airing, or not. (optional)
     * @param  bool $is_airing Optional. Filter by programs that are currently airing, or not. (optional)
     * @param  \DateTime $max_start_date Optional. The maximum premiere start date. (optional)
     * @param  \DateTime $min_end_date Optional. The minimum premiere end date. (optional)
     * @param  \DateTime $max_end_date Optional. The maximum premiere end date. (optional)
     * @param  bool $is_movie Optional. Filter for movies. (optional)
     * @param  bool $is_series Optional. Filter for series. (optional)
     * @param  bool $is_news Optional. Filter for news. (optional)
     * @param  bool $is_kids Optional. Filter for kids. (optional)
     * @param  bool $is_sports Optional. Filter for sports. (optional)
     * @param  int $start_index Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)
     * @param  int $limit Optional. The maximum number of records to return. (optional)
     * @param  string[] $sort_by Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder[] $sort_order Sort Order - Ascending,Descending. (optional)
     * @param  string[] $genres The genres to return guide information for. (optional)
     * @param  string[] $genre_ids The genre ids to return guide information for. (optional)
     * @param  bool $enable_images Optional. Include image information in output. (optional)
     * @param  int $image_type_limit Optional. The max number of images to return, per image type. (optional)
     * @param  \OpenAPI\Client\Model\ImageType[] $enable_image_types Optional. The image types to include in the output. (optional)
     * @param  bool $enable_user_data Optional. Include user data. (optional)
     * @param  string $series_timer_id Optional. Filter by series timer id. (optional)
     * @param  string $library_series_id Optional. Filter by library series id. (optional)
     * @param  \OpenAPI\Client\Model\ItemFields[] $fields Optional. Specify additional fields of information to return in the output. (optional)
     * @param  bool $enable_total_record_count Retrieve total record count. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveTvPrograms'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BaseItemDtoQueryResult
     */
    public function getLiveTvPrograms($channel_ids = null, $user_id = null, $min_start_date = null, $has_aired = null, $is_airing = null, $max_start_date = null, $min_end_date = null, $max_end_date = null, $is_movie = null, $is_series = null, $is_news = null, $is_kids = null, $is_sports = null, $start_index = null, $limit = null, $sort_by = null, $sort_order = null, $genres = null, $genre_ids = null, $enable_images = null, $image_type_limit = null, $enable_image_types = null, $enable_user_data = null, $series_timer_id = null, $library_series_id = null, $fields = null, $enable_total_record_count = true, string $contentType = self::contentTypes['getLiveTvPrograms'][0])
    {
        list($response) = $this->getLiveTvProgramsWithHttpInfo($channel_ids, $user_id, $min_start_date, $has_aired, $is_airing, $max_start_date, $min_end_date, $max_end_date, $is_movie, $is_series, $is_news, $is_kids, $is_sports, $start_index, $limit, $sort_by, $sort_order, $genres, $genre_ids, $enable_images, $image_type_limit, $enable_image_types, $enable_user_data, $series_timer_id, $library_series_id, $fields, $enable_total_record_count, $contentType);
        return $response;
    }

    /**
     * Operation getLiveTvProgramsWithHttpInfo
     *
     * Gets available live tv epgs.
     *
     * @param  string[] $channel_ids The channels to return guide information for. (optional)
     * @param  string $user_id Optional. Filter by user id. (optional)
     * @param  \DateTime $min_start_date Optional. The minimum premiere start date. (optional)
     * @param  bool $has_aired Optional. Filter by programs that have completed airing, or not. (optional)
     * @param  bool $is_airing Optional. Filter by programs that are currently airing, or not. (optional)
     * @param  \DateTime $max_start_date Optional. The maximum premiere start date. (optional)
     * @param  \DateTime $min_end_date Optional. The minimum premiere end date. (optional)
     * @param  \DateTime $max_end_date Optional. The maximum premiere end date. (optional)
     * @param  bool $is_movie Optional. Filter for movies. (optional)
     * @param  bool $is_series Optional. Filter for series. (optional)
     * @param  bool $is_news Optional. Filter for news. (optional)
     * @param  bool $is_kids Optional. Filter for kids. (optional)
     * @param  bool $is_sports Optional. Filter for sports. (optional)
     * @param  int $start_index Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)
     * @param  int $limit Optional. The maximum number of records to return. (optional)
     * @param  string[] $sort_by Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder[] $sort_order Sort Order - Ascending,Descending. (optional)
     * @param  string[] $genres The genres to return guide information for. (optional)
     * @param  string[] $genre_ids The genre ids to return guide information for. (optional)
     * @param  bool $enable_images Optional. Include image information in output. (optional)
     * @param  int $image_type_limit Optional. The max number of images to return, per image type. (optional)
     * @param  \OpenAPI\Client\Model\ImageType[] $enable_image_types Optional. The image types to include in the output. (optional)
     * @param  bool $enable_user_data Optional. Include user data. (optional)
     * @param  string $series_timer_id Optional. Filter by series timer id. (optional)
     * @param  string $library_series_id Optional. Filter by library series id. (optional)
     * @param  \OpenAPI\Client\Model\ItemFields[] $fields Optional. Specify additional fields of information to return in the output. (optional)
     * @param  bool $enable_total_record_count Retrieve total record count. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveTvPrograms'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BaseItemDtoQueryResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLiveTvProgramsWithHttpInfo($channel_ids = null, $user_id = null, $min_start_date = null, $has_aired = null, $is_airing = null, $max_start_date = null, $min_end_date = null, $max_end_date = null, $is_movie = null, $is_series = null, $is_news = null, $is_kids = null, $is_sports = null, $start_index = null, $limit = null, $sort_by = null, $sort_order = null, $genres = null, $genre_ids = null, $enable_images = null, $image_type_limit = null, $enable_image_types = null, $enable_user_data = null, $series_timer_id = null, $library_series_id = null, $fields = null, $enable_total_record_count = true, string $contentType = self::contentTypes['getLiveTvPrograms'][0])
    {
        $request = $this->getLiveTvProgramsRequest($channel_ids, $user_id, $min_start_date, $has_aired, $is_airing, $max_start_date, $min_end_date, $max_end_date, $is_movie, $is_series, $is_news, $is_kids, $is_sports, $start_index, $limit, $sort_by, $sort_order, $genres, $genre_ids, $enable_images, $image_type_limit, $enable_image_types, $enable_user_data, $series_timer_id, $library_series_id, $fields, $enable_total_record_count, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\BaseItemDtoQueryResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BaseItemDtoQueryResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BaseItemDtoQueryResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\BaseItemDtoQueryResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BaseItemDtoQueryResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLiveTvProgramsAsync
     *
     * Gets available live tv epgs.
     *
     * @param  string[] $channel_ids The channels to return guide information for. (optional)
     * @param  string $user_id Optional. Filter by user id. (optional)
     * @param  \DateTime $min_start_date Optional. The minimum premiere start date. (optional)
     * @param  bool $has_aired Optional. Filter by programs that have completed airing, or not. (optional)
     * @param  bool $is_airing Optional. Filter by programs that are currently airing, or not. (optional)
     * @param  \DateTime $max_start_date Optional. The maximum premiere start date. (optional)
     * @param  \DateTime $min_end_date Optional. The minimum premiere end date. (optional)
     * @param  \DateTime $max_end_date Optional. The maximum premiere end date. (optional)
     * @param  bool $is_movie Optional. Filter for movies. (optional)
     * @param  bool $is_series Optional. Filter for series. (optional)
     * @param  bool $is_news Optional. Filter for news. (optional)
     * @param  bool $is_kids Optional. Filter for kids. (optional)
     * @param  bool $is_sports Optional. Filter for sports. (optional)
     * @param  int $start_index Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)
     * @param  int $limit Optional. The maximum number of records to return. (optional)
     * @param  string[] $sort_by Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder[] $sort_order Sort Order - Ascending,Descending. (optional)
     * @param  string[] $genres The genres to return guide information for. (optional)
     * @param  string[] $genre_ids The genre ids to return guide information for. (optional)
     * @param  bool $enable_images Optional. Include image information in output. (optional)
     * @param  int $image_type_limit Optional. The max number of images to return, per image type. (optional)
     * @param  \OpenAPI\Client\Model\ImageType[] $enable_image_types Optional. The image types to include in the output. (optional)
     * @param  bool $enable_user_data Optional. Include user data. (optional)
     * @param  string $series_timer_id Optional. Filter by series timer id. (optional)
     * @param  string $library_series_id Optional. Filter by library series id. (optional)
     * @param  \OpenAPI\Client\Model\ItemFields[] $fields Optional. Specify additional fields of information to return in the output. (optional)
     * @param  bool $enable_total_record_count Retrieve total record count. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveTvPrograms'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLiveTvProgramsAsync($channel_ids = null, $user_id = null, $min_start_date = null, $has_aired = null, $is_airing = null, $max_start_date = null, $min_end_date = null, $max_end_date = null, $is_movie = null, $is_series = null, $is_news = null, $is_kids = null, $is_sports = null, $start_index = null, $limit = null, $sort_by = null, $sort_order = null, $genres = null, $genre_ids = null, $enable_images = null, $image_type_limit = null, $enable_image_types = null, $enable_user_data = null, $series_timer_id = null, $library_series_id = null, $fields = null, $enable_total_record_count = true, string $contentType = self::contentTypes['getLiveTvPrograms'][0])
    {
        return $this->getLiveTvProgramsAsyncWithHttpInfo($channel_ids, $user_id, $min_start_date, $has_aired, $is_airing, $max_start_date, $min_end_date, $max_end_date, $is_movie, $is_series, $is_news, $is_kids, $is_sports, $start_index, $limit, $sort_by, $sort_order, $genres, $genre_ids, $enable_images, $image_type_limit, $enable_image_types, $enable_user_data, $series_timer_id, $library_series_id, $fields, $enable_total_record_count, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLiveTvProgramsAsyncWithHttpInfo
     *
     * Gets available live tv epgs.
     *
     * @param  string[] $channel_ids The channels to return guide information for. (optional)
     * @param  string $user_id Optional. Filter by user id. (optional)
     * @param  \DateTime $min_start_date Optional. The minimum premiere start date. (optional)
     * @param  bool $has_aired Optional. Filter by programs that have completed airing, or not. (optional)
     * @param  bool $is_airing Optional. Filter by programs that are currently airing, or not. (optional)
     * @param  \DateTime $max_start_date Optional. The maximum premiere start date. (optional)
     * @param  \DateTime $min_end_date Optional. The minimum premiere end date. (optional)
     * @param  \DateTime $max_end_date Optional. The maximum premiere end date. (optional)
     * @param  bool $is_movie Optional. Filter for movies. (optional)
     * @param  bool $is_series Optional. Filter for series. (optional)
     * @param  bool $is_news Optional. Filter for news. (optional)
     * @param  bool $is_kids Optional. Filter for kids. (optional)
     * @param  bool $is_sports Optional. Filter for sports. (optional)
     * @param  int $start_index Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)
     * @param  int $limit Optional. The maximum number of records to return. (optional)
     * @param  string[] $sort_by Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder[] $sort_order Sort Order - Ascending,Descending. (optional)
     * @param  string[] $genres The genres to return guide information for. (optional)
     * @param  string[] $genre_ids The genre ids to return guide information for. (optional)
     * @param  bool $enable_images Optional. Include image information in output. (optional)
     * @param  int $image_type_limit Optional. The max number of images to return, per image type. (optional)
     * @param  \OpenAPI\Client\Model\ImageType[] $enable_image_types Optional. The image types to include in the output. (optional)
     * @param  bool $enable_user_data Optional. Include user data. (optional)
     * @param  string $series_timer_id Optional. Filter by series timer id. (optional)
     * @param  string $library_series_id Optional. Filter by library series id. (optional)
     * @param  \OpenAPI\Client\Model\ItemFields[] $fields Optional. Specify additional fields of information to return in the output. (optional)
     * @param  bool $enable_total_record_count Retrieve total record count. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveTvPrograms'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLiveTvProgramsAsyncWithHttpInfo($channel_ids = null, $user_id = null, $min_start_date = null, $has_aired = null, $is_airing = null, $max_start_date = null, $min_end_date = null, $max_end_date = null, $is_movie = null, $is_series = null, $is_news = null, $is_kids = null, $is_sports = null, $start_index = null, $limit = null, $sort_by = null, $sort_order = null, $genres = null, $genre_ids = null, $enable_images = null, $image_type_limit = null, $enable_image_types = null, $enable_user_data = null, $series_timer_id = null, $library_series_id = null, $fields = null, $enable_total_record_count = true, string $contentType = self::contentTypes['getLiveTvPrograms'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BaseItemDtoQueryResult';
        $request = $this->getLiveTvProgramsRequest($channel_ids, $user_id, $min_start_date, $has_aired, $is_airing, $max_start_date, $min_end_date, $max_end_date, $is_movie, $is_series, $is_news, $is_kids, $is_sports, $start_index, $limit, $sort_by, $sort_order, $genres, $genre_ids, $enable_images, $image_type_limit, $enable_image_types, $enable_user_data, $series_timer_id, $library_series_id, $fields, $enable_total_record_count, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLiveTvPrograms'
     *
     * @param  string[] $channel_ids The channels to return guide information for. (optional)
     * @param  string $user_id Optional. Filter by user id. (optional)
     * @param  \DateTime $min_start_date Optional. The minimum premiere start date. (optional)
     * @param  bool $has_aired Optional. Filter by programs that have completed airing, or not. (optional)
     * @param  bool $is_airing Optional. Filter by programs that are currently airing, or not. (optional)
     * @param  \DateTime $max_start_date Optional. The maximum premiere start date. (optional)
     * @param  \DateTime $min_end_date Optional. The minimum premiere end date. (optional)
     * @param  \DateTime $max_end_date Optional. The maximum premiere end date. (optional)
     * @param  bool $is_movie Optional. Filter for movies. (optional)
     * @param  bool $is_series Optional. Filter for series. (optional)
     * @param  bool $is_news Optional. Filter for news. (optional)
     * @param  bool $is_kids Optional. Filter for kids. (optional)
     * @param  bool $is_sports Optional. Filter for sports. (optional)
     * @param  int $start_index Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)
     * @param  int $limit Optional. The maximum number of records to return. (optional)
     * @param  string[] $sort_by Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder[] $sort_order Sort Order - Ascending,Descending. (optional)
     * @param  string[] $genres The genres to return guide information for. (optional)
     * @param  string[] $genre_ids The genre ids to return guide information for. (optional)
     * @param  bool $enable_images Optional. Include image information in output. (optional)
     * @param  int $image_type_limit Optional. The max number of images to return, per image type. (optional)
     * @param  \OpenAPI\Client\Model\ImageType[] $enable_image_types Optional. The image types to include in the output. (optional)
     * @param  bool $enable_user_data Optional. Include user data. (optional)
     * @param  string $series_timer_id Optional. Filter by series timer id. (optional)
     * @param  string $library_series_id Optional. Filter by library series id. (optional)
     * @param  \OpenAPI\Client\Model\ItemFields[] $fields Optional. Specify additional fields of information to return in the output. (optional)
     * @param  bool $enable_total_record_count Retrieve total record count. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getLiveTvPrograms'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getLiveTvProgramsRequest($channel_ids = null, $user_id = null, $min_start_date = null, $has_aired = null, $is_airing = null, $max_start_date = null, $min_end_date = null, $max_end_date = null, $is_movie = null, $is_series = null, $is_news = null, $is_kids = null, $is_sports = null, $start_index = null, $limit = null, $sort_by = null, $sort_order = null, $genres = null, $genre_ids = null, $enable_images = null, $image_type_limit = null, $enable_image_types = null, $enable_user_data = null, $series_timer_id = null, $library_series_id = null, $fields = null, $enable_total_record_count = true, string $contentType = self::contentTypes['getLiveTvPrograms'][0])
    {





























        $resourcePath = '/LiveTv/Programs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $channel_ids,
            'channelIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'userId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_start_date,
            'minStartDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $has_aired,
            'hasAired', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_airing,
            'isAiring', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_start_date,
            'maxStartDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_end_date,
            'minEndDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_end_date,
            'maxEndDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_movie,
            'isMovie', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_series,
            'isSeries', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_news,
            'isNews', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_kids,
            'isKids', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_sports,
            'isSports', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_index,
            'startIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_by,
            'sortBy', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sortOrder', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $genres,
            'genres', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $genre_ids,
            'genreIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_images,
            'enableImages', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_type_limit,
            'imageTypeLimit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_image_types,
            'enableImageTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_user_data,
            'enableUserData', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $series_timer_id,
            'seriesTimerId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $library_series_id,
            'librarySeriesId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fields,
            'fields', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_total_record_count,
            'enableTotalRecordCount', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProgram
     *
     * Gets a live tv program.
     *
     * @param  string $program_id Program id. (required)
     * @param  string $user_id Optional. Attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProgram'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BaseItemDto
     */
    public function getProgram($program_id, $user_id = null, string $contentType = self::contentTypes['getProgram'][0])
    {
        list($response) = $this->getProgramWithHttpInfo($program_id, $user_id, $contentType);
        return $response;
    }

    /**
     * Operation getProgramWithHttpInfo
     *
     * Gets a live tv program.
     *
     * @param  string $program_id Program id. (required)
     * @param  string $user_id Optional. Attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProgram'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BaseItemDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProgramWithHttpInfo($program_id, $user_id = null, string $contentType = self::contentTypes['getProgram'][0])
    {
        $request = $this->getProgramRequest($program_id, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\BaseItemDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BaseItemDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BaseItemDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\BaseItemDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BaseItemDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProgramAsync
     *
     * Gets a live tv program.
     *
     * @param  string $program_id Program id. (required)
     * @param  string $user_id Optional. Attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProgram'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProgramAsync($program_id, $user_id = null, string $contentType = self::contentTypes['getProgram'][0])
    {
        return $this->getProgramAsyncWithHttpInfo($program_id, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProgramAsyncWithHttpInfo
     *
     * Gets a live tv program.
     *
     * @param  string $program_id Program id. (required)
     * @param  string $user_id Optional. Attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProgram'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProgramAsyncWithHttpInfo($program_id, $user_id = null, string $contentType = self::contentTypes['getProgram'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BaseItemDto';
        $request = $this->getProgramRequest($program_id, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProgram'
     *
     * @param  string $program_id Program id. (required)
     * @param  string $user_id Optional. Attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProgram'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getProgramRequest($program_id, $user_id = null, string $contentType = self::contentTypes['getProgram'][0])
    {

        // verify the required parameter 'program_id' is set
        if ($program_id === null || (is_array($program_id) && count($program_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $program_id when calling getProgram'
            );
        }



        $resourcePath = '/LiveTv/Programs/{programId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'userId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($program_id !== null) {
            $resourcePath = str_replace(
                '{' . 'programId' . '}',
                ObjectSerializer::toPathValue($program_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPrograms
     *
     * Gets available live tv epgs.
     *
     * @param  \OpenAPI\Client\Model\GetProgramsRequest $get_programs_request Request body. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPrograms'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BaseItemDtoQueryResult
     */
    public function getPrograms($get_programs_request = null, string $contentType = self::contentTypes['getPrograms'][0])
    {
        list($response) = $this->getProgramsWithHttpInfo($get_programs_request, $contentType);
        return $response;
    }

    /**
     * Operation getProgramsWithHttpInfo
     *
     * Gets available live tv epgs.
     *
     * @param  \OpenAPI\Client\Model\GetProgramsRequest $get_programs_request Request body. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPrograms'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BaseItemDtoQueryResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProgramsWithHttpInfo($get_programs_request = null, string $contentType = self::contentTypes['getPrograms'][0])
    {
        $request = $this->getProgramsRequest($get_programs_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\BaseItemDtoQueryResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BaseItemDtoQueryResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BaseItemDtoQueryResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\BaseItemDtoQueryResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BaseItemDtoQueryResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProgramsAsync
     *
     * Gets available live tv epgs.
     *
     * @param  \OpenAPI\Client\Model\GetProgramsRequest $get_programs_request Request body. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPrograms'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProgramsAsync($get_programs_request = null, string $contentType = self::contentTypes['getPrograms'][0])
    {
        return $this->getProgramsAsyncWithHttpInfo($get_programs_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProgramsAsyncWithHttpInfo
     *
     * Gets available live tv epgs.
     *
     * @param  \OpenAPI\Client\Model\GetProgramsRequest $get_programs_request Request body. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPrograms'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProgramsAsyncWithHttpInfo($get_programs_request = null, string $contentType = self::contentTypes['getPrograms'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BaseItemDtoQueryResult';
        $request = $this->getProgramsRequest($get_programs_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPrograms'
     *
     * @param  \OpenAPI\Client\Model\GetProgramsRequest $get_programs_request Request body. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPrograms'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getProgramsRequest($get_programs_request = null, string $contentType = self::contentTypes['getPrograms'][0])
    {



        $resourcePath = '/LiveTv/Programs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($get_programs_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($get_programs_request));
            } else {
                $httpBody = $get_programs_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecommendedPrograms
     *
     * Gets recommended live tv epgs.
     *
     * @param  string $user_id Optional. filter by user id. (optional)
     * @param  int $limit Optional. The maximum number of records to return. (optional)
     * @param  bool $is_airing Optional. Filter by programs that are currently airing, or not. (optional)
     * @param  bool $has_aired Optional. Filter by programs that have completed airing, or not. (optional)
     * @param  bool $is_series Optional. Filter for series. (optional)
     * @param  bool $is_movie Optional. Filter for movies. (optional)
     * @param  bool $is_news Optional. Filter for news. (optional)
     * @param  bool $is_kids Optional. Filter for kids. (optional)
     * @param  bool $is_sports Optional. Filter for sports. (optional)
     * @param  bool $enable_images Optional. Include image information in output. (optional)
     * @param  int $image_type_limit Optional. The max number of images to return, per image type. (optional)
     * @param  \OpenAPI\Client\Model\ImageType[] $enable_image_types Optional. The image types to include in the output. (optional)
     * @param  string[] $genre_ids The genres to return guide information for. (optional)
     * @param  \OpenAPI\Client\Model\ItemFields[] $fields Optional. Specify additional fields of information to return in the output. (optional)
     * @param  bool $enable_user_data Optional. include user data. (optional)
     * @param  bool $enable_total_record_count Retrieve total record count. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecommendedPrograms'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BaseItemDtoQueryResult
     */
    public function getRecommendedPrograms($user_id = null, $limit = null, $is_airing = null, $has_aired = null, $is_series = null, $is_movie = null, $is_news = null, $is_kids = null, $is_sports = null, $enable_images = null, $image_type_limit = null, $enable_image_types = null, $genre_ids = null, $fields = null, $enable_user_data = null, $enable_total_record_count = true, string $contentType = self::contentTypes['getRecommendedPrograms'][0])
    {
        list($response) = $this->getRecommendedProgramsWithHttpInfo($user_id, $limit, $is_airing, $has_aired, $is_series, $is_movie, $is_news, $is_kids, $is_sports, $enable_images, $image_type_limit, $enable_image_types, $genre_ids, $fields, $enable_user_data, $enable_total_record_count, $contentType);
        return $response;
    }

    /**
     * Operation getRecommendedProgramsWithHttpInfo
     *
     * Gets recommended live tv epgs.
     *
     * @param  string $user_id Optional. filter by user id. (optional)
     * @param  int $limit Optional. The maximum number of records to return. (optional)
     * @param  bool $is_airing Optional. Filter by programs that are currently airing, or not. (optional)
     * @param  bool $has_aired Optional. Filter by programs that have completed airing, or not. (optional)
     * @param  bool $is_series Optional. Filter for series. (optional)
     * @param  bool $is_movie Optional. Filter for movies. (optional)
     * @param  bool $is_news Optional. Filter for news. (optional)
     * @param  bool $is_kids Optional. Filter for kids. (optional)
     * @param  bool $is_sports Optional. Filter for sports. (optional)
     * @param  bool $enable_images Optional. Include image information in output. (optional)
     * @param  int $image_type_limit Optional. The max number of images to return, per image type. (optional)
     * @param  \OpenAPI\Client\Model\ImageType[] $enable_image_types Optional. The image types to include in the output. (optional)
     * @param  string[] $genre_ids The genres to return guide information for. (optional)
     * @param  \OpenAPI\Client\Model\ItemFields[] $fields Optional. Specify additional fields of information to return in the output. (optional)
     * @param  bool $enable_user_data Optional. include user data. (optional)
     * @param  bool $enable_total_record_count Retrieve total record count. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecommendedPrograms'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BaseItemDtoQueryResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecommendedProgramsWithHttpInfo($user_id = null, $limit = null, $is_airing = null, $has_aired = null, $is_series = null, $is_movie = null, $is_news = null, $is_kids = null, $is_sports = null, $enable_images = null, $image_type_limit = null, $enable_image_types = null, $genre_ids = null, $fields = null, $enable_user_data = null, $enable_total_record_count = true, string $contentType = self::contentTypes['getRecommendedPrograms'][0])
    {
        $request = $this->getRecommendedProgramsRequest($user_id, $limit, $is_airing, $has_aired, $is_series, $is_movie, $is_news, $is_kids, $is_sports, $enable_images, $image_type_limit, $enable_image_types, $genre_ids, $fields, $enable_user_data, $enable_total_record_count, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\BaseItemDtoQueryResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BaseItemDtoQueryResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BaseItemDtoQueryResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\BaseItemDtoQueryResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BaseItemDtoQueryResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecommendedProgramsAsync
     *
     * Gets recommended live tv epgs.
     *
     * @param  string $user_id Optional. filter by user id. (optional)
     * @param  int $limit Optional. The maximum number of records to return. (optional)
     * @param  bool $is_airing Optional. Filter by programs that are currently airing, or not. (optional)
     * @param  bool $has_aired Optional. Filter by programs that have completed airing, or not. (optional)
     * @param  bool $is_series Optional. Filter for series. (optional)
     * @param  bool $is_movie Optional. Filter for movies. (optional)
     * @param  bool $is_news Optional. Filter for news. (optional)
     * @param  bool $is_kids Optional. Filter for kids. (optional)
     * @param  bool $is_sports Optional. Filter for sports. (optional)
     * @param  bool $enable_images Optional. Include image information in output. (optional)
     * @param  int $image_type_limit Optional. The max number of images to return, per image type. (optional)
     * @param  \OpenAPI\Client\Model\ImageType[] $enable_image_types Optional. The image types to include in the output. (optional)
     * @param  string[] $genre_ids The genres to return guide information for. (optional)
     * @param  \OpenAPI\Client\Model\ItemFields[] $fields Optional. Specify additional fields of information to return in the output. (optional)
     * @param  bool $enable_user_data Optional. include user data. (optional)
     * @param  bool $enable_total_record_count Retrieve total record count. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecommendedPrograms'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecommendedProgramsAsync($user_id = null, $limit = null, $is_airing = null, $has_aired = null, $is_series = null, $is_movie = null, $is_news = null, $is_kids = null, $is_sports = null, $enable_images = null, $image_type_limit = null, $enable_image_types = null, $genre_ids = null, $fields = null, $enable_user_data = null, $enable_total_record_count = true, string $contentType = self::contentTypes['getRecommendedPrograms'][0])
    {
        return $this->getRecommendedProgramsAsyncWithHttpInfo($user_id, $limit, $is_airing, $has_aired, $is_series, $is_movie, $is_news, $is_kids, $is_sports, $enable_images, $image_type_limit, $enable_image_types, $genre_ids, $fields, $enable_user_data, $enable_total_record_count, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecommendedProgramsAsyncWithHttpInfo
     *
     * Gets recommended live tv epgs.
     *
     * @param  string $user_id Optional. filter by user id. (optional)
     * @param  int $limit Optional. The maximum number of records to return. (optional)
     * @param  bool $is_airing Optional. Filter by programs that are currently airing, or not. (optional)
     * @param  bool $has_aired Optional. Filter by programs that have completed airing, or not. (optional)
     * @param  bool $is_series Optional. Filter for series. (optional)
     * @param  bool $is_movie Optional. Filter for movies. (optional)
     * @param  bool $is_news Optional. Filter for news. (optional)
     * @param  bool $is_kids Optional. Filter for kids. (optional)
     * @param  bool $is_sports Optional. Filter for sports. (optional)
     * @param  bool $enable_images Optional. Include image information in output. (optional)
     * @param  int $image_type_limit Optional. The max number of images to return, per image type. (optional)
     * @param  \OpenAPI\Client\Model\ImageType[] $enable_image_types Optional. The image types to include in the output. (optional)
     * @param  string[] $genre_ids The genres to return guide information for. (optional)
     * @param  \OpenAPI\Client\Model\ItemFields[] $fields Optional. Specify additional fields of information to return in the output. (optional)
     * @param  bool $enable_user_data Optional. include user data. (optional)
     * @param  bool $enable_total_record_count Retrieve total record count. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecommendedPrograms'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecommendedProgramsAsyncWithHttpInfo($user_id = null, $limit = null, $is_airing = null, $has_aired = null, $is_series = null, $is_movie = null, $is_news = null, $is_kids = null, $is_sports = null, $enable_images = null, $image_type_limit = null, $enable_image_types = null, $genre_ids = null, $fields = null, $enable_user_data = null, $enable_total_record_count = true, string $contentType = self::contentTypes['getRecommendedPrograms'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BaseItemDtoQueryResult';
        $request = $this->getRecommendedProgramsRequest($user_id, $limit, $is_airing, $has_aired, $is_series, $is_movie, $is_news, $is_kids, $is_sports, $enable_images, $image_type_limit, $enable_image_types, $genre_ids, $fields, $enable_user_data, $enable_total_record_count, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecommendedPrograms'
     *
     * @param  string $user_id Optional. filter by user id. (optional)
     * @param  int $limit Optional. The maximum number of records to return. (optional)
     * @param  bool $is_airing Optional. Filter by programs that are currently airing, or not. (optional)
     * @param  bool $has_aired Optional. Filter by programs that have completed airing, or not. (optional)
     * @param  bool $is_series Optional. Filter for series. (optional)
     * @param  bool $is_movie Optional. Filter for movies. (optional)
     * @param  bool $is_news Optional. Filter for news. (optional)
     * @param  bool $is_kids Optional. Filter for kids. (optional)
     * @param  bool $is_sports Optional. Filter for sports. (optional)
     * @param  bool $enable_images Optional. Include image information in output. (optional)
     * @param  int $image_type_limit Optional. The max number of images to return, per image type. (optional)
     * @param  \OpenAPI\Client\Model\ImageType[] $enable_image_types Optional. The image types to include in the output. (optional)
     * @param  string[] $genre_ids The genres to return guide information for. (optional)
     * @param  \OpenAPI\Client\Model\ItemFields[] $fields Optional. Specify additional fields of information to return in the output. (optional)
     * @param  bool $enable_user_data Optional. include user data. (optional)
     * @param  bool $enable_total_record_count Retrieve total record count. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecommendedPrograms'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecommendedProgramsRequest($user_id = null, $limit = null, $is_airing = null, $has_aired = null, $is_series = null, $is_movie = null, $is_news = null, $is_kids = null, $is_sports = null, $enable_images = null, $image_type_limit = null, $enable_image_types = null, $genre_ids = null, $fields = null, $enable_user_data = null, $enable_total_record_count = true, string $contentType = self::contentTypes['getRecommendedPrograms'][0])
    {


















        $resourcePath = '/LiveTv/Programs/Recommended';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'userId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_airing,
            'isAiring', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $has_aired,
            'hasAired', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_series,
            'isSeries', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_movie,
            'isMovie', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_news,
            'isNews', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_kids,
            'isKids', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_sports,
            'isSports', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_images,
            'enableImages', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_type_limit,
            'imageTypeLimit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_image_types,
            'enableImageTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $genre_ids,
            'genreIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fields,
            'fields', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_user_data,
            'enableUserData', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_total_record_count,
            'enableTotalRecordCount', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecording
     *
     * Gets a live tv recording.
     *
     * @param  string $recording_id Recording id. (required)
     * @param  string $user_id Optional. Attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecording'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BaseItemDto
     */
    public function getRecording($recording_id, $user_id = null, string $contentType = self::contentTypes['getRecording'][0])
    {
        list($response) = $this->getRecordingWithHttpInfo($recording_id, $user_id, $contentType);
        return $response;
    }

    /**
     * Operation getRecordingWithHttpInfo
     *
     * Gets a live tv recording.
     *
     * @param  string $recording_id Recording id. (required)
     * @param  string $user_id Optional. Attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecording'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BaseItemDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecordingWithHttpInfo($recording_id, $user_id = null, string $contentType = self::contentTypes['getRecording'][0])
    {
        $request = $this->getRecordingRequest($recording_id, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\BaseItemDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BaseItemDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BaseItemDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\BaseItemDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BaseItemDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecordingAsync
     *
     * Gets a live tv recording.
     *
     * @param  string $recording_id Recording id. (required)
     * @param  string $user_id Optional. Attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecording'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordingAsync($recording_id, $user_id = null, string $contentType = self::contentTypes['getRecording'][0])
    {
        return $this->getRecordingAsyncWithHttpInfo($recording_id, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecordingAsyncWithHttpInfo
     *
     * Gets a live tv recording.
     *
     * @param  string $recording_id Recording id. (required)
     * @param  string $user_id Optional. Attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecording'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordingAsyncWithHttpInfo($recording_id, $user_id = null, string $contentType = self::contentTypes['getRecording'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BaseItemDto';
        $request = $this->getRecordingRequest($recording_id, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecording'
     *
     * @param  string $recording_id Recording id. (required)
     * @param  string $user_id Optional. Attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecording'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecordingRequest($recording_id, $user_id = null, string $contentType = self::contentTypes['getRecording'][0])
    {

        // verify the required parameter 'recording_id' is set
        if ($recording_id === null || (is_array($recording_id) && count($recording_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recording_id when calling getRecording'
            );
        }



        $resourcePath = '/LiveTv/Recordings/{recordingId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'userId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($recording_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recordingId' . '}',
                ObjectSerializer::toPathValue($recording_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecordingFolders
     *
     * Gets recording folders.
     *
     * @param  string $user_id Optional. Filter by user and attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordingFolders'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BaseItemDtoQueryResult
     */
    public function getRecordingFolders($user_id = null, string $contentType = self::contentTypes['getRecordingFolders'][0])
    {
        list($response) = $this->getRecordingFoldersWithHttpInfo($user_id, $contentType);
        return $response;
    }

    /**
     * Operation getRecordingFoldersWithHttpInfo
     *
     * Gets recording folders.
     *
     * @param  string $user_id Optional. Filter by user and attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordingFolders'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BaseItemDtoQueryResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecordingFoldersWithHttpInfo($user_id = null, string $contentType = self::contentTypes['getRecordingFolders'][0])
    {
        $request = $this->getRecordingFoldersRequest($user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\BaseItemDtoQueryResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BaseItemDtoQueryResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BaseItemDtoQueryResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\BaseItemDtoQueryResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BaseItemDtoQueryResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecordingFoldersAsync
     *
     * Gets recording folders.
     *
     * @param  string $user_id Optional. Filter by user and attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordingFolders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordingFoldersAsync($user_id = null, string $contentType = self::contentTypes['getRecordingFolders'][0])
    {
        return $this->getRecordingFoldersAsyncWithHttpInfo($user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecordingFoldersAsyncWithHttpInfo
     *
     * Gets recording folders.
     *
     * @param  string $user_id Optional. Filter by user and attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordingFolders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordingFoldersAsyncWithHttpInfo($user_id = null, string $contentType = self::contentTypes['getRecordingFolders'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BaseItemDtoQueryResult';
        $request = $this->getRecordingFoldersRequest($user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecordingFolders'
     *
     * @param  string $user_id Optional. Filter by user and attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordingFolders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecordingFoldersRequest($user_id = null, string $contentType = self::contentTypes['getRecordingFolders'][0])
    {



        $resourcePath = '/LiveTv/Recordings/Folders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'userId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecordingGroup
     *
     * Get recording group.
     *
     * @param  string $group_id Group id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordingGroup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     * @deprecated
     */
    public function getRecordingGroup($group_id, string $contentType = self::contentTypes['getRecordingGroup'][0])
    {
        $this->getRecordingGroupWithHttpInfo($group_id, $contentType);
    }

    /**
     * Operation getRecordingGroupWithHttpInfo
     *
     * Get recording group.
     *
     * @param  string $group_id Group id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordingGroup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function getRecordingGroupWithHttpInfo($group_id, string $contentType = self::contentTypes['getRecordingGroup'][0])
    {
        $request = $this->getRecordingGroupRequest($group_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecordingGroupAsync
     *
     * Get recording group.
     *
     * @param  string $group_id Group id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordingGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function getRecordingGroupAsync($group_id, string $contentType = self::contentTypes['getRecordingGroup'][0])
    {
        return $this->getRecordingGroupAsyncWithHttpInfo($group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecordingGroupAsyncWithHttpInfo
     *
     * Get recording group.
     *
     * @param  string $group_id Group id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordingGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function getRecordingGroupAsyncWithHttpInfo($group_id, string $contentType = self::contentTypes['getRecordingGroup'][0])
    {
        $returnType = '';
        $request = $this->getRecordingGroupRequest($group_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecordingGroup'
     *
     * @param  string $group_id Group id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordingGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function getRecordingGroupRequest($group_id, string $contentType = self::contentTypes['getRecordingGroup'][0])
    {

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling getRecordingGroup'
            );
        }


        $resourcePath = '/LiveTv/Recordings/Groups/{groupId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecordingGroups
     *
     * Gets live tv recording groups.
     *
     * @param  string $user_id Optional. Filter by user and attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordingGroups'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BaseItemDtoQueryResult
     * @deprecated
     */
    public function getRecordingGroups($user_id = null, string $contentType = self::contentTypes['getRecordingGroups'][0])
    {
        list($response) = $this->getRecordingGroupsWithHttpInfo($user_id, $contentType);
        return $response;
    }

    /**
     * Operation getRecordingGroupsWithHttpInfo
     *
     * Gets live tv recording groups.
     *
     * @param  string $user_id Optional. Filter by user and attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordingGroups'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BaseItemDtoQueryResult, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function getRecordingGroupsWithHttpInfo($user_id = null, string $contentType = self::contentTypes['getRecordingGroups'][0])
    {
        $request = $this->getRecordingGroupsRequest($user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\BaseItemDtoQueryResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BaseItemDtoQueryResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BaseItemDtoQueryResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\BaseItemDtoQueryResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BaseItemDtoQueryResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecordingGroupsAsync
     *
     * Gets live tv recording groups.
     *
     * @param  string $user_id Optional. Filter by user and attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordingGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function getRecordingGroupsAsync($user_id = null, string $contentType = self::contentTypes['getRecordingGroups'][0])
    {
        return $this->getRecordingGroupsAsyncWithHttpInfo($user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecordingGroupsAsyncWithHttpInfo
     *
     * Gets live tv recording groups.
     *
     * @param  string $user_id Optional. Filter by user and attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordingGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function getRecordingGroupsAsyncWithHttpInfo($user_id = null, string $contentType = self::contentTypes['getRecordingGroups'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BaseItemDtoQueryResult';
        $request = $this->getRecordingGroupsRequest($user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecordingGroups'
     *
     * @param  string $user_id Optional. Filter by user and attach user data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordingGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function getRecordingGroupsRequest($user_id = null, string $contentType = self::contentTypes['getRecordingGroups'][0])
    {



        $resourcePath = '/LiveTv/Recordings/Groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'userId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecordings
     *
     * Gets live tv recordings.
     *
     * @param  string $channel_id Optional. Filter by channel id. (optional)
     * @param  string $user_id Optional. Filter by user and attach user data. (optional)
     * @param  int $start_index Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)
     * @param  int $limit Optional. The maximum number of records to return. (optional)
     * @param  \OpenAPI\Client\Model\RecordingStatus $status Optional. Filter by recording status. (optional)
     * @param  bool $is_in_progress Optional. Filter by recordings that are in progress, or not. (optional)
     * @param  string $series_timer_id Optional. Filter by recordings belonging to a series timer. (optional)
     * @param  bool $enable_images Optional. Include image information in output. (optional)
     * @param  int $image_type_limit Optional. The max number of images to return, per image type. (optional)
     * @param  \OpenAPI\Client\Model\ImageType[] $enable_image_types Optional. The image types to include in the output. (optional)
     * @param  \OpenAPI\Client\Model\ItemFields[] $fields Optional. Specify additional fields of information to return in the output. (optional)
     * @param  bool $enable_user_data Optional. Include user data. (optional)
     * @param  bool $is_movie Optional. Filter for movies. (optional)
     * @param  bool $is_series Optional. Filter for series. (optional)
     * @param  bool $is_kids Optional. Filter for kids. (optional)
     * @param  bool $is_sports Optional. Filter for sports. (optional)
     * @param  bool $is_news Optional. Filter for news. (optional)
     * @param  bool $is_library_item Optional. Filter for is library item. (optional)
     * @param  bool $enable_total_record_count Optional. Return total record count. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BaseItemDtoQueryResult
     */
    public function getRecordings($channel_id = null, $user_id = null, $start_index = null, $limit = null, $status = null, $is_in_progress = null, $series_timer_id = null, $enable_images = null, $image_type_limit = null, $enable_image_types = null, $fields = null, $enable_user_data = null, $is_movie = null, $is_series = null, $is_kids = null, $is_sports = null, $is_news = null, $is_library_item = null, $enable_total_record_count = true, string $contentType = self::contentTypes['getRecordings'][0])
    {
        list($response) = $this->getRecordingsWithHttpInfo($channel_id, $user_id, $start_index, $limit, $status, $is_in_progress, $series_timer_id, $enable_images, $image_type_limit, $enable_image_types, $fields, $enable_user_data, $is_movie, $is_series, $is_kids, $is_sports, $is_news, $is_library_item, $enable_total_record_count, $contentType);
        return $response;
    }

    /**
     * Operation getRecordingsWithHttpInfo
     *
     * Gets live tv recordings.
     *
     * @param  string $channel_id Optional. Filter by channel id. (optional)
     * @param  string $user_id Optional. Filter by user and attach user data. (optional)
     * @param  int $start_index Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)
     * @param  int $limit Optional. The maximum number of records to return. (optional)
     * @param  \OpenAPI\Client\Model\RecordingStatus $status Optional. Filter by recording status. (optional)
     * @param  bool $is_in_progress Optional. Filter by recordings that are in progress, or not. (optional)
     * @param  string $series_timer_id Optional. Filter by recordings belonging to a series timer. (optional)
     * @param  bool $enable_images Optional. Include image information in output. (optional)
     * @param  int $image_type_limit Optional. The max number of images to return, per image type. (optional)
     * @param  \OpenAPI\Client\Model\ImageType[] $enable_image_types Optional. The image types to include in the output. (optional)
     * @param  \OpenAPI\Client\Model\ItemFields[] $fields Optional. Specify additional fields of information to return in the output. (optional)
     * @param  bool $enable_user_data Optional. Include user data. (optional)
     * @param  bool $is_movie Optional. Filter for movies. (optional)
     * @param  bool $is_series Optional. Filter for series. (optional)
     * @param  bool $is_kids Optional. Filter for kids. (optional)
     * @param  bool $is_sports Optional. Filter for sports. (optional)
     * @param  bool $is_news Optional. Filter for news. (optional)
     * @param  bool $is_library_item Optional. Filter for is library item. (optional)
     * @param  bool $enable_total_record_count Optional. Return total record count. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BaseItemDtoQueryResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecordingsWithHttpInfo($channel_id = null, $user_id = null, $start_index = null, $limit = null, $status = null, $is_in_progress = null, $series_timer_id = null, $enable_images = null, $image_type_limit = null, $enable_image_types = null, $fields = null, $enable_user_data = null, $is_movie = null, $is_series = null, $is_kids = null, $is_sports = null, $is_news = null, $is_library_item = null, $enable_total_record_count = true, string $contentType = self::contentTypes['getRecordings'][0])
    {
        $request = $this->getRecordingsRequest($channel_id, $user_id, $start_index, $limit, $status, $is_in_progress, $series_timer_id, $enable_images, $image_type_limit, $enable_image_types, $fields, $enable_user_data, $is_movie, $is_series, $is_kids, $is_sports, $is_news, $is_library_item, $enable_total_record_count, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\BaseItemDtoQueryResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BaseItemDtoQueryResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BaseItemDtoQueryResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\BaseItemDtoQueryResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BaseItemDtoQueryResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecordingsAsync
     *
     * Gets live tv recordings.
     *
     * @param  string $channel_id Optional. Filter by channel id. (optional)
     * @param  string $user_id Optional. Filter by user and attach user data. (optional)
     * @param  int $start_index Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)
     * @param  int $limit Optional. The maximum number of records to return. (optional)
     * @param  \OpenAPI\Client\Model\RecordingStatus $status Optional. Filter by recording status. (optional)
     * @param  bool $is_in_progress Optional. Filter by recordings that are in progress, or not. (optional)
     * @param  string $series_timer_id Optional. Filter by recordings belonging to a series timer. (optional)
     * @param  bool $enable_images Optional. Include image information in output. (optional)
     * @param  int $image_type_limit Optional. The max number of images to return, per image type. (optional)
     * @param  \OpenAPI\Client\Model\ImageType[] $enable_image_types Optional. The image types to include in the output. (optional)
     * @param  \OpenAPI\Client\Model\ItemFields[] $fields Optional. Specify additional fields of information to return in the output. (optional)
     * @param  bool $enable_user_data Optional. Include user data. (optional)
     * @param  bool $is_movie Optional. Filter for movies. (optional)
     * @param  bool $is_series Optional. Filter for series. (optional)
     * @param  bool $is_kids Optional. Filter for kids. (optional)
     * @param  bool $is_sports Optional. Filter for sports. (optional)
     * @param  bool $is_news Optional. Filter for news. (optional)
     * @param  bool $is_library_item Optional. Filter for is library item. (optional)
     * @param  bool $enable_total_record_count Optional. Return total record count. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordingsAsync($channel_id = null, $user_id = null, $start_index = null, $limit = null, $status = null, $is_in_progress = null, $series_timer_id = null, $enable_images = null, $image_type_limit = null, $enable_image_types = null, $fields = null, $enable_user_data = null, $is_movie = null, $is_series = null, $is_kids = null, $is_sports = null, $is_news = null, $is_library_item = null, $enable_total_record_count = true, string $contentType = self::contentTypes['getRecordings'][0])
    {
        return $this->getRecordingsAsyncWithHttpInfo($channel_id, $user_id, $start_index, $limit, $status, $is_in_progress, $series_timer_id, $enable_images, $image_type_limit, $enable_image_types, $fields, $enable_user_data, $is_movie, $is_series, $is_kids, $is_sports, $is_news, $is_library_item, $enable_total_record_count, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecordingsAsyncWithHttpInfo
     *
     * Gets live tv recordings.
     *
     * @param  string $channel_id Optional. Filter by channel id. (optional)
     * @param  string $user_id Optional. Filter by user and attach user data. (optional)
     * @param  int $start_index Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)
     * @param  int $limit Optional. The maximum number of records to return. (optional)
     * @param  \OpenAPI\Client\Model\RecordingStatus $status Optional. Filter by recording status. (optional)
     * @param  bool $is_in_progress Optional. Filter by recordings that are in progress, or not. (optional)
     * @param  string $series_timer_id Optional. Filter by recordings belonging to a series timer. (optional)
     * @param  bool $enable_images Optional. Include image information in output. (optional)
     * @param  int $image_type_limit Optional. The max number of images to return, per image type. (optional)
     * @param  \OpenAPI\Client\Model\ImageType[] $enable_image_types Optional. The image types to include in the output. (optional)
     * @param  \OpenAPI\Client\Model\ItemFields[] $fields Optional. Specify additional fields of information to return in the output. (optional)
     * @param  bool $enable_user_data Optional. Include user data. (optional)
     * @param  bool $is_movie Optional. Filter for movies. (optional)
     * @param  bool $is_series Optional. Filter for series. (optional)
     * @param  bool $is_kids Optional. Filter for kids. (optional)
     * @param  bool $is_sports Optional. Filter for sports. (optional)
     * @param  bool $is_news Optional. Filter for news. (optional)
     * @param  bool $is_library_item Optional. Filter for is library item. (optional)
     * @param  bool $enable_total_record_count Optional. Return total record count. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordingsAsyncWithHttpInfo($channel_id = null, $user_id = null, $start_index = null, $limit = null, $status = null, $is_in_progress = null, $series_timer_id = null, $enable_images = null, $image_type_limit = null, $enable_image_types = null, $fields = null, $enable_user_data = null, $is_movie = null, $is_series = null, $is_kids = null, $is_sports = null, $is_news = null, $is_library_item = null, $enable_total_record_count = true, string $contentType = self::contentTypes['getRecordings'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BaseItemDtoQueryResult';
        $request = $this->getRecordingsRequest($channel_id, $user_id, $start_index, $limit, $status, $is_in_progress, $series_timer_id, $enable_images, $image_type_limit, $enable_image_types, $fields, $enable_user_data, $is_movie, $is_series, $is_kids, $is_sports, $is_news, $is_library_item, $enable_total_record_count, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecordings'
     *
     * @param  string $channel_id Optional. Filter by channel id. (optional)
     * @param  string $user_id Optional. Filter by user and attach user data. (optional)
     * @param  int $start_index Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)
     * @param  int $limit Optional. The maximum number of records to return. (optional)
     * @param  \OpenAPI\Client\Model\RecordingStatus $status Optional. Filter by recording status. (optional)
     * @param  bool $is_in_progress Optional. Filter by recordings that are in progress, or not. (optional)
     * @param  string $series_timer_id Optional. Filter by recordings belonging to a series timer. (optional)
     * @param  bool $enable_images Optional. Include image information in output. (optional)
     * @param  int $image_type_limit Optional. The max number of images to return, per image type. (optional)
     * @param  \OpenAPI\Client\Model\ImageType[] $enable_image_types Optional. The image types to include in the output. (optional)
     * @param  \OpenAPI\Client\Model\ItemFields[] $fields Optional. Specify additional fields of information to return in the output. (optional)
     * @param  bool $enable_user_data Optional. Include user data. (optional)
     * @param  bool $is_movie Optional. Filter for movies. (optional)
     * @param  bool $is_series Optional. Filter for series. (optional)
     * @param  bool $is_kids Optional. Filter for kids. (optional)
     * @param  bool $is_sports Optional. Filter for sports. (optional)
     * @param  bool $is_news Optional. Filter for news. (optional)
     * @param  bool $is_library_item Optional. Filter for is library item. (optional)
     * @param  bool $enable_total_record_count Optional. Return total record count. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecordingsRequest($channel_id = null, $user_id = null, $start_index = null, $limit = null, $status = null, $is_in_progress = null, $series_timer_id = null, $enable_images = null, $image_type_limit = null, $enable_image_types = null, $fields = null, $enable_user_data = null, $is_movie = null, $is_series = null, $is_kids = null, $is_sports = null, $is_news = null, $is_library_item = null, $enable_total_record_count = true, string $contentType = self::contentTypes['getRecordings'][0])
    {





















        $resourcePath = '/LiveTv/Recordings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $channel_id,
            'channelId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'userId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_index,
            'startIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'RecordingStatus', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_in_progress,
            'isInProgress', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $series_timer_id,
            'seriesTimerId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_images,
            'enableImages', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_type_limit,
            'imageTypeLimit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_image_types,
            'enableImageTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fields,
            'fields', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_user_data,
            'enableUserData', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_movie,
            'isMovie', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_series,
            'isSeries', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_kids,
            'isKids', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_sports,
            'isSports', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_news,
            'isNews', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_library_item,
            'isLibraryItem', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_total_record_count,
            'enableTotalRecordCount', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecordingsSeries
     *
     * Gets live tv recording series.
     *
     * @param  string $channel_id Optional. Filter by channel id. (optional)
     * @param  string $user_id Optional. Filter by user and attach user data. (optional)
     * @param  string $group_id Optional. Filter by recording group. (optional)
     * @param  int $start_index Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)
     * @param  int $limit Optional. The maximum number of records to return. (optional)
     * @param  \OpenAPI\Client\Model\RecordingStatus $status Optional. Filter by recording status. (optional)
     * @param  bool $is_in_progress Optional. Filter by recordings that are in progress, or not. (optional)
     * @param  string $series_timer_id Optional. Filter by recordings belonging to a series timer. (optional)
     * @param  bool $enable_images Optional. Include image information in output. (optional)
     * @param  int $image_type_limit Optional. The max number of images to return, per image type. (optional)
     * @param  \OpenAPI\Client\Model\ImageType[] $enable_image_types Optional. The image types to include in the output. (optional)
     * @param  \OpenAPI\Client\Model\ItemFields[] $fields Optional. Specify additional fields of information to return in the output. (optional)
     * @param  bool $enable_user_data Optional. Include user data. (optional)
     * @param  bool $enable_total_record_count Optional. Return total record count. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordingsSeries'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BaseItemDtoQueryResult
     * @deprecated
     */
    public function getRecordingsSeries($channel_id = null, $user_id = null, $group_id = null, $start_index = null, $limit = null, $status = null, $is_in_progress = null, $series_timer_id = null, $enable_images = null, $image_type_limit = null, $enable_image_types = null, $fields = null, $enable_user_data = null, $enable_total_record_count = true, string $contentType = self::contentTypes['getRecordingsSeries'][0])
    {
        list($response) = $this->getRecordingsSeriesWithHttpInfo($channel_id, $user_id, $group_id, $start_index, $limit, $status, $is_in_progress, $series_timer_id, $enable_images, $image_type_limit, $enable_image_types, $fields, $enable_user_data, $enable_total_record_count, $contentType);
        return $response;
    }

    /**
     * Operation getRecordingsSeriesWithHttpInfo
     *
     * Gets live tv recording series.
     *
     * @param  string $channel_id Optional. Filter by channel id. (optional)
     * @param  string $user_id Optional. Filter by user and attach user data. (optional)
     * @param  string $group_id Optional. Filter by recording group. (optional)
     * @param  int $start_index Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)
     * @param  int $limit Optional. The maximum number of records to return. (optional)
     * @param  \OpenAPI\Client\Model\RecordingStatus $status Optional. Filter by recording status. (optional)
     * @param  bool $is_in_progress Optional. Filter by recordings that are in progress, or not. (optional)
     * @param  string $series_timer_id Optional. Filter by recordings belonging to a series timer. (optional)
     * @param  bool $enable_images Optional. Include image information in output. (optional)
     * @param  int $image_type_limit Optional. The max number of images to return, per image type. (optional)
     * @param  \OpenAPI\Client\Model\ImageType[] $enable_image_types Optional. The image types to include in the output. (optional)
     * @param  \OpenAPI\Client\Model\ItemFields[] $fields Optional. Specify additional fields of information to return in the output. (optional)
     * @param  bool $enable_user_data Optional. Include user data. (optional)
     * @param  bool $enable_total_record_count Optional. Return total record count. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordingsSeries'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BaseItemDtoQueryResult, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function getRecordingsSeriesWithHttpInfo($channel_id = null, $user_id = null, $group_id = null, $start_index = null, $limit = null, $status = null, $is_in_progress = null, $series_timer_id = null, $enable_images = null, $image_type_limit = null, $enable_image_types = null, $fields = null, $enable_user_data = null, $enable_total_record_count = true, string $contentType = self::contentTypes['getRecordingsSeries'][0])
    {
        $request = $this->getRecordingsSeriesRequest($channel_id, $user_id, $group_id, $start_index, $limit, $status, $is_in_progress, $series_timer_id, $enable_images, $image_type_limit, $enable_image_types, $fields, $enable_user_data, $enable_total_record_count, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\BaseItemDtoQueryResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BaseItemDtoQueryResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BaseItemDtoQueryResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\BaseItemDtoQueryResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BaseItemDtoQueryResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecordingsSeriesAsync
     *
     * Gets live tv recording series.
     *
     * @param  string $channel_id Optional. Filter by channel id. (optional)
     * @param  string $user_id Optional. Filter by user and attach user data. (optional)
     * @param  string $group_id Optional. Filter by recording group. (optional)
     * @param  int $start_index Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)
     * @param  int $limit Optional. The maximum number of records to return. (optional)
     * @param  \OpenAPI\Client\Model\RecordingStatus $status Optional. Filter by recording status. (optional)
     * @param  bool $is_in_progress Optional. Filter by recordings that are in progress, or not. (optional)
     * @param  string $series_timer_id Optional. Filter by recordings belonging to a series timer. (optional)
     * @param  bool $enable_images Optional. Include image information in output. (optional)
     * @param  int $image_type_limit Optional. The max number of images to return, per image type. (optional)
     * @param  \OpenAPI\Client\Model\ImageType[] $enable_image_types Optional. The image types to include in the output. (optional)
     * @param  \OpenAPI\Client\Model\ItemFields[] $fields Optional. Specify additional fields of information to return in the output. (optional)
     * @param  bool $enable_user_data Optional. Include user data. (optional)
     * @param  bool $enable_total_record_count Optional. Return total record count. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordingsSeries'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function getRecordingsSeriesAsync($channel_id = null, $user_id = null, $group_id = null, $start_index = null, $limit = null, $status = null, $is_in_progress = null, $series_timer_id = null, $enable_images = null, $image_type_limit = null, $enable_image_types = null, $fields = null, $enable_user_data = null, $enable_total_record_count = true, string $contentType = self::contentTypes['getRecordingsSeries'][0])
    {
        return $this->getRecordingsSeriesAsyncWithHttpInfo($channel_id, $user_id, $group_id, $start_index, $limit, $status, $is_in_progress, $series_timer_id, $enable_images, $image_type_limit, $enable_image_types, $fields, $enable_user_data, $enable_total_record_count, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecordingsSeriesAsyncWithHttpInfo
     *
     * Gets live tv recording series.
     *
     * @param  string $channel_id Optional. Filter by channel id. (optional)
     * @param  string $user_id Optional. Filter by user and attach user data. (optional)
     * @param  string $group_id Optional. Filter by recording group. (optional)
     * @param  int $start_index Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)
     * @param  int $limit Optional. The maximum number of records to return. (optional)
     * @param  \OpenAPI\Client\Model\RecordingStatus $status Optional. Filter by recording status. (optional)
     * @param  bool $is_in_progress Optional. Filter by recordings that are in progress, or not. (optional)
     * @param  string $series_timer_id Optional. Filter by recordings belonging to a series timer. (optional)
     * @param  bool $enable_images Optional. Include image information in output. (optional)
     * @param  int $image_type_limit Optional. The max number of images to return, per image type. (optional)
     * @param  \OpenAPI\Client\Model\ImageType[] $enable_image_types Optional. The image types to include in the output. (optional)
     * @param  \OpenAPI\Client\Model\ItemFields[] $fields Optional. Specify additional fields of information to return in the output. (optional)
     * @param  bool $enable_user_data Optional. Include user data. (optional)
     * @param  bool $enable_total_record_count Optional. Return total record count. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordingsSeries'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function getRecordingsSeriesAsyncWithHttpInfo($channel_id = null, $user_id = null, $group_id = null, $start_index = null, $limit = null, $status = null, $is_in_progress = null, $series_timer_id = null, $enable_images = null, $image_type_limit = null, $enable_image_types = null, $fields = null, $enable_user_data = null, $enable_total_record_count = true, string $contentType = self::contentTypes['getRecordingsSeries'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BaseItemDtoQueryResult';
        $request = $this->getRecordingsSeriesRequest($channel_id, $user_id, $group_id, $start_index, $limit, $status, $is_in_progress, $series_timer_id, $enable_images, $image_type_limit, $enable_image_types, $fields, $enable_user_data, $enable_total_record_count, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecordingsSeries'
     *
     * @param  string $channel_id Optional. Filter by channel id. (optional)
     * @param  string $user_id Optional. Filter by user and attach user data. (optional)
     * @param  string $group_id Optional. Filter by recording group. (optional)
     * @param  int $start_index Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)
     * @param  int $limit Optional. The maximum number of records to return. (optional)
     * @param  \OpenAPI\Client\Model\RecordingStatus $status Optional. Filter by recording status. (optional)
     * @param  bool $is_in_progress Optional. Filter by recordings that are in progress, or not. (optional)
     * @param  string $series_timer_id Optional. Filter by recordings belonging to a series timer. (optional)
     * @param  bool $enable_images Optional. Include image information in output. (optional)
     * @param  int $image_type_limit Optional. The max number of images to return, per image type. (optional)
     * @param  \OpenAPI\Client\Model\ImageType[] $enable_image_types Optional. The image types to include in the output. (optional)
     * @param  \OpenAPI\Client\Model\ItemFields[] $fields Optional. Specify additional fields of information to return in the output. (optional)
     * @param  bool $enable_user_data Optional. Include user data. (optional)
     * @param  bool $enable_total_record_count Optional. Return total record count. (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecordingsSeries'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function getRecordingsSeriesRequest($channel_id = null, $user_id = null, $group_id = null, $start_index = null, $limit = null, $status = null, $is_in_progress = null, $series_timer_id = null, $enable_images = null, $image_type_limit = null, $enable_image_types = null, $fields = null, $enable_user_data = null, $enable_total_record_count = true, string $contentType = self::contentTypes['getRecordingsSeries'][0])
    {
















        $resourcePath = '/LiveTv/Recordings/Series';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $channel_id,
            'channelId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'userId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_id,
            'groupId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_index,
            'startIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'RecordingStatus', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_in_progress,
            'isInProgress', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $series_timer_id,
            'seriesTimerId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_images,
            'enableImages', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_type_limit,
            'imageTypeLimit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_image_types,
            'enableImageTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fields,
            'fields', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_user_data,
            'enableUserData', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_total_record_count,
            'enableTotalRecordCount', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSchedulesDirectCountries
     *
     * Gets available countries.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSchedulesDirectCountries'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getSchedulesDirectCountries(string $contentType = self::contentTypes['getSchedulesDirectCountries'][0])
    {
        list($response) = $this->getSchedulesDirectCountriesWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getSchedulesDirectCountriesWithHttpInfo
     *
     * Gets available countries.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSchedulesDirectCountries'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSchedulesDirectCountriesWithHttpInfo(string $contentType = self::contentTypes['getSchedulesDirectCountries'][0])
    {
        $request = $this->getSchedulesDirectCountriesRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSchedulesDirectCountriesAsync
     *
     * Gets available countries.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSchedulesDirectCountries'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSchedulesDirectCountriesAsync(string $contentType = self::contentTypes['getSchedulesDirectCountries'][0])
    {
        return $this->getSchedulesDirectCountriesAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSchedulesDirectCountriesAsyncWithHttpInfo
     *
     * Gets available countries.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSchedulesDirectCountries'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSchedulesDirectCountriesAsyncWithHttpInfo(string $contentType = self::contentTypes['getSchedulesDirectCountries'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->getSchedulesDirectCountriesRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSchedulesDirectCountries'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSchedulesDirectCountries'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSchedulesDirectCountriesRequest(string $contentType = self::contentTypes['getSchedulesDirectCountries'][0])
    {


        $resourcePath = '/LiveTv/ListingProviders/SchedulesDirect/Countries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSeriesTimer
     *
     * Gets a live tv series timer.
     *
     * @param  string $timer_id Timer id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSeriesTimer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SeriesTimerInfoDto|\OpenAPI\Client\Model\ProblemDetails
     */
    public function getSeriesTimer($timer_id, string $contentType = self::contentTypes['getSeriesTimer'][0])
    {
        list($response) = $this->getSeriesTimerWithHttpInfo($timer_id, $contentType);
        return $response;
    }

    /**
     * Operation getSeriesTimerWithHttpInfo
     *
     * Gets a live tv series timer.
     *
     * @param  string $timer_id Timer id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSeriesTimer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SeriesTimerInfoDto|\OpenAPI\Client\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSeriesTimerWithHttpInfo($timer_id, string $contentType = self::contentTypes['getSeriesTimer'][0])
    {
        $request = $this->getSeriesTimerRequest($timer_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SeriesTimerInfoDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SeriesTimerInfoDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SeriesTimerInfoDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProblemDetails' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SeriesTimerInfoDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SeriesTimerInfoDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSeriesTimerAsync
     *
     * Gets a live tv series timer.
     *
     * @param  string $timer_id Timer id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSeriesTimer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSeriesTimerAsync($timer_id, string $contentType = self::contentTypes['getSeriesTimer'][0])
    {
        return $this->getSeriesTimerAsyncWithHttpInfo($timer_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSeriesTimerAsyncWithHttpInfo
     *
     * Gets a live tv series timer.
     *
     * @param  string $timer_id Timer id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSeriesTimer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSeriesTimerAsyncWithHttpInfo($timer_id, string $contentType = self::contentTypes['getSeriesTimer'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SeriesTimerInfoDto';
        $request = $this->getSeriesTimerRequest($timer_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSeriesTimer'
     *
     * @param  string $timer_id Timer id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSeriesTimer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSeriesTimerRequest($timer_id, string $contentType = self::contentTypes['getSeriesTimer'][0])
    {

        // verify the required parameter 'timer_id' is set
        if ($timer_id === null || (is_array($timer_id) && count($timer_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $timer_id when calling getSeriesTimer'
            );
        }


        $resourcePath = '/LiveTv/SeriesTimers/{timerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($timer_id !== null) {
            $resourcePath = str_replace(
                '{' . 'timerId' . '}',
                ObjectSerializer::toPathValue($timer_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSeriesTimers
     *
     * Gets live tv series timers.
     *
     * @param  string $sort_by Optional. Sort by SortName or Priority. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder $sort_order Optional. Sort in Ascending or Descending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSeriesTimers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SeriesTimerInfoDtoQueryResult
     */
    public function getSeriesTimers($sort_by = null, $sort_order = null, string $contentType = self::contentTypes['getSeriesTimers'][0])
    {
        list($response) = $this->getSeriesTimersWithHttpInfo($sort_by, $sort_order, $contentType);
        return $response;
    }

    /**
     * Operation getSeriesTimersWithHttpInfo
     *
     * Gets live tv series timers.
     *
     * @param  string $sort_by Optional. Sort by SortName or Priority. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder $sort_order Optional. Sort in Ascending or Descending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSeriesTimers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SeriesTimerInfoDtoQueryResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSeriesTimersWithHttpInfo($sort_by = null, $sort_order = null, string $contentType = self::contentTypes['getSeriesTimers'][0])
    {
        $request = $this->getSeriesTimersRequest($sort_by, $sort_order, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SeriesTimerInfoDtoQueryResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SeriesTimerInfoDtoQueryResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SeriesTimerInfoDtoQueryResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SeriesTimerInfoDtoQueryResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SeriesTimerInfoDtoQueryResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSeriesTimersAsync
     *
     * Gets live tv series timers.
     *
     * @param  string $sort_by Optional. Sort by SortName or Priority. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder $sort_order Optional. Sort in Ascending or Descending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSeriesTimers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSeriesTimersAsync($sort_by = null, $sort_order = null, string $contentType = self::contentTypes['getSeriesTimers'][0])
    {
        return $this->getSeriesTimersAsyncWithHttpInfo($sort_by, $sort_order, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSeriesTimersAsyncWithHttpInfo
     *
     * Gets live tv series timers.
     *
     * @param  string $sort_by Optional. Sort by SortName or Priority. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder $sort_order Optional. Sort in Ascending or Descending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSeriesTimers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSeriesTimersAsyncWithHttpInfo($sort_by = null, $sort_order = null, string $contentType = self::contentTypes['getSeriesTimers'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SeriesTimerInfoDtoQueryResult';
        $request = $this->getSeriesTimersRequest($sort_by, $sort_order, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSeriesTimers'
     *
     * @param  string $sort_by Optional. Sort by SortName or Priority. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder $sort_order Optional. Sort in Ascending or Descending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSeriesTimers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSeriesTimersRequest($sort_by = null, $sort_order = null, string $contentType = self::contentTypes['getSeriesTimers'][0])
    {




        $resourcePath = '/LiveTv/SeriesTimers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_by,
            'sortBy', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sortOrder', // param base name
            'SortOrder', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTimer
     *
     * Gets a timer.
     *
     * @param  string $timer_id Timer id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTimer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TimerInfoDto
     */
    public function getTimer($timer_id, string $contentType = self::contentTypes['getTimer'][0])
    {
        list($response) = $this->getTimerWithHttpInfo($timer_id, $contentType);
        return $response;
    }

    /**
     * Operation getTimerWithHttpInfo
     *
     * Gets a timer.
     *
     * @param  string $timer_id Timer id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTimer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TimerInfoDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTimerWithHttpInfo($timer_id, string $contentType = self::contentTypes['getTimer'][0])
    {
        $request = $this->getTimerRequest($timer_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\TimerInfoDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\TimerInfoDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TimerInfoDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TimerInfoDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TimerInfoDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTimerAsync
     *
     * Gets a timer.
     *
     * @param  string $timer_id Timer id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTimer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTimerAsync($timer_id, string $contentType = self::contentTypes['getTimer'][0])
    {
        return $this->getTimerAsyncWithHttpInfo($timer_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTimerAsyncWithHttpInfo
     *
     * Gets a timer.
     *
     * @param  string $timer_id Timer id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTimer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTimerAsyncWithHttpInfo($timer_id, string $contentType = self::contentTypes['getTimer'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TimerInfoDto';
        $request = $this->getTimerRequest($timer_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTimer'
     *
     * @param  string $timer_id Timer id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTimer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTimerRequest($timer_id, string $contentType = self::contentTypes['getTimer'][0])
    {

        // verify the required parameter 'timer_id' is set
        if ($timer_id === null || (is_array($timer_id) && count($timer_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $timer_id when calling getTimer'
            );
        }


        $resourcePath = '/LiveTv/Timers/{timerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($timer_id !== null) {
            $resourcePath = str_replace(
                '{' . 'timerId' . '}',
                ObjectSerializer::toPathValue($timer_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTimers
     *
     * Gets the live tv timers.
     *
     * @param  string $channel_id Optional. Filter by channel id. (optional)
     * @param  string $series_timer_id Optional. Filter by timers belonging to a series timer. (optional)
     * @param  bool $is_active Optional. Filter by timers that are active. (optional)
     * @param  bool $is_scheduled Optional. Filter by timers that are scheduled. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTimers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TimerInfoDtoQueryResult
     */
    public function getTimers($channel_id = null, $series_timer_id = null, $is_active = null, $is_scheduled = null, string $contentType = self::contentTypes['getTimers'][0])
    {
        list($response) = $this->getTimersWithHttpInfo($channel_id, $series_timer_id, $is_active, $is_scheduled, $contentType);
        return $response;
    }

    /**
     * Operation getTimersWithHttpInfo
     *
     * Gets the live tv timers.
     *
     * @param  string $channel_id Optional. Filter by channel id. (optional)
     * @param  string $series_timer_id Optional. Filter by timers belonging to a series timer. (optional)
     * @param  bool $is_active Optional. Filter by timers that are active. (optional)
     * @param  bool $is_scheduled Optional. Filter by timers that are scheduled. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTimers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TimerInfoDtoQueryResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTimersWithHttpInfo($channel_id = null, $series_timer_id = null, $is_active = null, $is_scheduled = null, string $contentType = self::contentTypes['getTimers'][0])
    {
        $request = $this->getTimersRequest($channel_id, $series_timer_id, $is_active, $is_scheduled, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\TimerInfoDtoQueryResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\TimerInfoDtoQueryResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TimerInfoDtoQueryResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TimerInfoDtoQueryResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TimerInfoDtoQueryResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTimersAsync
     *
     * Gets the live tv timers.
     *
     * @param  string $channel_id Optional. Filter by channel id. (optional)
     * @param  string $series_timer_id Optional. Filter by timers belonging to a series timer. (optional)
     * @param  bool $is_active Optional. Filter by timers that are active. (optional)
     * @param  bool $is_scheduled Optional. Filter by timers that are scheduled. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTimers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTimersAsync($channel_id = null, $series_timer_id = null, $is_active = null, $is_scheduled = null, string $contentType = self::contentTypes['getTimers'][0])
    {
        return $this->getTimersAsyncWithHttpInfo($channel_id, $series_timer_id, $is_active, $is_scheduled, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTimersAsyncWithHttpInfo
     *
     * Gets the live tv timers.
     *
     * @param  string $channel_id Optional. Filter by channel id. (optional)
     * @param  string $series_timer_id Optional. Filter by timers belonging to a series timer. (optional)
     * @param  bool $is_active Optional. Filter by timers that are active. (optional)
     * @param  bool $is_scheduled Optional. Filter by timers that are scheduled. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTimers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTimersAsyncWithHttpInfo($channel_id = null, $series_timer_id = null, $is_active = null, $is_scheduled = null, string $contentType = self::contentTypes['getTimers'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TimerInfoDtoQueryResult';
        $request = $this->getTimersRequest($channel_id, $series_timer_id, $is_active, $is_scheduled, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTimers'
     *
     * @param  string $channel_id Optional. Filter by channel id. (optional)
     * @param  string $series_timer_id Optional. Filter by timers belonging to a series timer. (optional)
     * @param  bool $is_active Optional. Filter by timers that are active. (optional)
     * @param  bool $is_scheduled Optional. Filter by timers that are scheduled. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTimers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTimersRequest($channel_id = null, $series_timer_id = null, $is_active = null, $is_scheduled = null, string $contentType = self::contentTypes['getTimers'][0])
    {






        $resourcePath = '/LiveTv/Timers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $channel_id,
            'channelId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $series_timer_id,
            'seriesTimerId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_active,
            'isActive', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_scheduled,
            'isScheduled', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTunerHostTypes
     *
     * Get tuner host types.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTunerHostTypes'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\NameIdPair[]
     */
    public function getTunerHostTypes(string $contentType = self::contentTypes['getTunerHostTypes'][0])
    {
        list($response) = $this->getTunerHostTypesWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getTunerHostTypesWithHttpInfo
     *
     * Get tuner host types.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTunerHostTypes'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\NameIdPair[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getTunerHostTypesWithHttpInfo(string $contentType = self::contentTypes['getTunerHostTypes'][0])
    {
        $request = $this->getTunerHostTypesRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\NameIdPair[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\NameIdPair[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\NameIdPair[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\NameIdPair[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\NameIdPair[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTunerHostTypesAsync
     *
     * Get tuner host types.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTunerHostTypes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTunerHostTypesAsync(string $contentType = self::contentTypes['getTunerHostTypes'][0])
    {
        return $this->getTunerHostTypesAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTunerHostTypesAsyncWithHttpInfo
     *
     * Get tuner host types.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTunerHostTypes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTunerHostTypesAsyncWithHttpInfo(string $contentType = self::contentTypes['getTunerHostTypes'][0])
    {
        $returnType = '\OpenAPI\Client\Model\NameIdPair[]';
        $request = $this->getTunerHostTypesRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTunerHostTypes'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTunerHostTypes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTunerHostTypesRequest(string $contentType = self::contentTypes['getTunerHostTypes'][0])
    {


        $resourcePath = '/LiveTv/TunerHosts/Types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation resetTuner
     *
     * Resets a tv tuner.
     *
     * @param  string $tuner_id Tuner id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resetTuner'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function resetTuner($tuner_id, string $contentType = self::contentTypes['resetTuner'][0])
    {
        $this->resetTunerWithHttpInfo($tuner_id, $contentType);
    }

    /**
     * Operation resetTunerWithHttpInfo
     *
     * Resets a tv tuner.
     *
     * @param  string $tuner_id Tuner id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resetTuner'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function resetTunerWithHttpInfo($tuner_id, string $contentType = self::contentTypes['resetTuner'][0])
    {
        $request = $this->resetTunerRequest($tuner_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation resetTunerAsync
     *
     * Resets a tv tuner.
     *
     * @param  string $tuner_id Tuner id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resetTuner'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resetTunerAsync($tuner_id, string $contentType = self::contentTypes['resetTuner'][0])
    {
        return $this->resetTunerAsyncWithHttpInfo($tuner_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation resetTunerAsyncWithHttpInfo
     *
     * Resets a tv tuner.
     *
     * @param  string $tuner_id Tuner id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resetTuner'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resetTunerAsyncWithHttpInfo($tuner_id, string $contentType = self::contentTypes['resetTuner'][0])
    {
        $returnType = '';
        $request = $this->resetTunerRequest($tuner_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'resetTuner'
     *
     * @param  string $tuner_id Tuner id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resetTuner'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function resetTunerRequest($tuner_id, string $contentType = self::contentTypes['resetTuner'][0])
    {

        // verify the required parameter 'tuner_id' is set
        if ($tuner_id === null || (is_array($tuner_id) && count($tuner_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tuner_id when calling resetTuner'
            );
        }


        $resourcePath = '/LiveTv/Tuners/{tunerId}/Reset';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($tuner_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tunerId' . '}',
                ObjectSerializer::toPathValue($tuner_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setChannelMapping
     *
     * Set channel mappings.
     *
     * @param  \OpenAPI\Client\Model\SetChannelMappingRequest $set_channel_mapping_request The set channel mapping dto. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setChannelMapping'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TunerChannelMapping
     */
    public function setChannelMapping($set_channel_mapping_request, string $contentType = self::contentTypes['setChannelMapping'][0])
    {
        list($response) = $this->setChannelMappingWithHttpInfo($set_channel_mapping_request, $contentType);
        return $response;
    }

    /**
     * Operation setChannelMappingWithHttpInfo
     *
     * Set channel mappings.
     *
     * @param  \OpenAPI\Client\Model\SetChannelMappingRequest $set_channel_mapping_request The set channel mapping dto. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setChannelMapping'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TunerChannelMapping, HTTP status code, HTTP response headers (array of strings)
     */
    public function setChannelMappingWithHttpInfo($set_channel_mapping_request, string $contentType = self::contentTypes['setChannelMapping'][0])
    {
        $request = $this->setChannelMappingRequest($set_channel_mapping_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\TunerChannelMapping' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\TunerChannelMapping' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TunerChannelMapping', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TunerChannelMapping';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TunerChannelMapping',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setChannelMappingAsync
     *
     * Set channel mappings.
     *
     * @param  \OpenAPI\Client\Model\SetChannelMappingRequest $set_channel_mapping_request The set channel mapping dto. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setChannelMapping'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setChannelMappingAsync($set_channel_mapping_request, string $contentType = self::contentTypes['setChannelMapping'][0])
    {
        return $this->setChannelMappingAsyncWithHttpInfo($set_channel_mapping_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setChannelMappingAsyncWithHttpInfo
     *
     * Set channel mappings.
     *
     * @param  \OpenAPI\Client\Model\SetChannelMappingRequest $set_channel_mapping_request The set channel mapping dto. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setChannelMapping'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setChannelMappingAsyncWithHttpInfo($set_channel_mapping_request, string $contentType = self::contentTypes['setChannelMapping'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TunerChannelMapping';
        $request = $this->setChannelMappingRequest($set_channel_mapping_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setChannelMapping'
     *
     * @param  \OpenAPI\Client\Model\SetChannelMappingRequest $set_channel_mapping_request The set channel mapping dto. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setChannelMapping'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setChannelMappingRequest($set_channel_mapping_request, string $contentType = self::contentTypes['setChannelMapping'][0])
    {

        // verify the required parameter 'set_channel_mapping_request' is set
        if ($set_channel_mapping_request === null || (is_array($set_channel_mapping_request) && count($set_channel_mapping_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $set_channel_mapping_request when calling setChannelMapping'
            );
        }


        $resourcePath = '/LiveTv/ChannelMappings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/json; profile="CamelCase"', 'application/json; profile="PascalCase"', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($set_channel_mapping_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($set_channel_mapping_request));
            } else {
                $httpBody = $set_channel_mapping_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateSeriesTimer
     *
     * Updates a live tv series timer.
     *
     * @param  string $timer_id Timer id. (required)
     * @param  \OpenAPI\Client\Model\CreateSeriesTimerRequest $create_series_timer_request New series timer info. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSeriesTimer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateSeriesTimer($timer_id, $create_series_timer_request = null, string $contentType = self::contentTypes['updateSeriesTimer'][0])
    {
        $this->updateSeriesTimerWithHttpInfo($timer_id, $create_series_timer_request, $contentType);
    }

    /**
     * Operation updateSeriesTimerWithHttpInfo
     *
     * Updates a live tv series timer.
     *
     * @param  string $timer_id Timer id. (required)
     * @param  \OpenAPI\Client\Model\CreateSeriesTimerRequest $create_series_timer_request New series timer info. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSeriesTimer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateSeriesTimerWithHttpInfo($timer_id, $create_series_timer_request = null, string $contentType = self::contentTypes['updateSeriesTimer'][0])
    {
        $request = $this->updateSeriesTimerRequest($timer_id, $create_series_timer_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateSeriesTimerAsync
     *
     * Updates a live tv series timer.
     *
     * @param  string $timer_id Timer id. (required)
     * @param  \OpenAPI\Client\Model\CreateSeriesTimerRequest $create_series_timer_request New series timer info. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSeriesTimer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateSeriesTimerAsync($timer_id, $create_series_timer_request = null, string $contentType = self::contentTypes['updateSeriesTimer'][0])
    {
        return $this->updateSeriesTimerAsyncWithHttpInfo($timer_id, $create_series_timer_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateSeriesTimerAsyncWithHttpInfo
     *
     * Updates a live tv series timer.
     *
     * @param  string $timer_id Timer id. (required)
     * @param  \OpenAPI\Client\Model\CreateSeriesTimerRequest $create_series_timer_request New series timer info. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSeriesTimer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateSeriesTimerAsyncWithHttpInfo($timer_id, $create_series_timer_request = null, string $contentType = self::contentTypes['updateSeriesTimer'][0])
    {
        $returnType = '';
        $request = $this->updateSeriesTimerRequest($timer_id, $create_series_timer_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateSeriesTimer'
     *
     * @param  string $timer_id Timer id. (required)
     * @param  \OpenAPI\Client\Model\CreateSeriesTimerRequest $create_series_timer_request New series timer info. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSeriesTimer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateSeriesTimerRequest($timer_id, $create_series_timer_request = null, string $contentType = self::contentTypes['updateSeriesTimer'][0])
    {

        // verify the required parameter 'timer_id' is set
        if ($timer_id === null || (is_array($timer_id) && count($timer_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $timer_id when calling updateSeriesTimer'
            );
        }



        $resourcePath = '/LiveTv/SeriesTimers/{timerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($timer_id !== null) {
            $resourcePath = str_replace(
                '{' . 'timerId' . '}',
                ObjectSerializer::toPathValue($timer_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_series_timer_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_series_timer_request));
            } else {
                $httpBody = $create_series_timer_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateTimer
     *
     * Updates a live tv timer.
     *
     * @param  string $timer_id Timer id. (required)
     * @param  \OpenAPI\Client\Model\CreateTimerRequest $create_timer_request New timer info. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTimer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateTimer($timer_id, $create_timer_request = null, string $contentType = self::contentTypes['updateTimer'][0])
    {
        $this->updateTimerWithHttpInfo($timer_id, $create_timer_request, $contentType);
    }

    /**
     * Operation updateTimerWithHttpInfo
     *
     * Updates a live tv timer.
     *
     * @param  string $timer_id Timer id. (required)
     * @param  \OpenAPI\Client\Model\CreateTimerRequest $create_timer_request New timer info. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTimer'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateTimerWithHttpInfo($timer_id, $create_timer_request = null, string $contentType = self::contentTypes['updateTimer'][0])
    {
        $request = $this->updateTimerRequest($timer_id, $create_timer_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateTimerAsync
     *
     * Updates a live tv timer.
     *
     * @param  string $timer_id Timer id. (required)
     * @param  \OpenAPI\Client\Model\CreateTimerRequest $create_timer_request New timer info. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTimer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTimerAsync($timer_id, $create_timer_request = null, string $contentType = self::contentTypes['updateTimer'][0])
    {
        return $this->updateTimerAsyncWithHttpInfo($timer_id, $create_timer_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateTimerAsyncWithHttpInfo
     *
     * Updates a live tv timer.
     *
     * @param  string $timer_id Timer id. (required)
     * @param  \OpenAPI\Client\Model\CreateTimerRequest $create_timer_request New timer info. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTimer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTimerAsyncWithHttpInfo($timer_id, $create_timer_request = null, string $contentType = self::contentTypes['updateTimer'][0])
    {
        $returnType = '';
        $request = $this->updateTimerRequest($timer_id, $create_timer_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateTimer'
     *
     * @param  string $timer_id Timer id. (required)
     * @param  \OpenAPI\Client\Model\CreateTimerRequest $create_timer_request New timer info. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTimer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateTimerRequest($timer_id, $create_timer_request = null, string $contentType = self::contentTypes['updateTimer'][0])
    {

        // verify the required parameter 'timer_id' is set
        if ($timer_id === null || (is_array($timer_id) && count($timer_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $timer_id when calling updateTimer'
            );
        }



        $resourcePath = '/LiveTv/Timers/{timerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($timer_id !== null) {
            $resourcePath = str_replace(
                '{' . 'timerId' . '}',
                ObjectSerializer::toPathValue($timer_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_timer_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_timer_request));
            } else {
                $httpBody = $create_timer_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
